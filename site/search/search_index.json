{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This is the main documentation of \"Chess App\". Refer to \"chessapp\" for the code documentation.</p>"},{"location":"project_setup/","title":"Project Setup","text":"<ul> <li>make sure all software requirements are met beforehand</li> <li>create new pip environment</li> </ul> <p><pre><code>pip freeze\npipenv shell\n</code></pre> - installing python packages is handled via pipenv</p> <pre><code>pipenv install [package name...]\n</code></pre>"},{"location":"project_setup/#github-stuff","title":"Git(hub) stuff","text":"<ul> <li>init repository <pre><code>git init\n</code></pre></li> <li>create github repository <pre><code>gh auth login\ngh repo create\n</code></pre></li> </ul>"},{"location":"software_requirements/","title":"Software Requirements","text":""},{"location":"software_requirements/#software","title":"Software","text":"<ul> <li>Visual Studio Code</li> <li>Github CLI (gh)</li> <li>git</li> <li>python 3.11 64 bit</li> <li>pip<ul> <li>py -m ensurepip --upgrade</li> <li>pip install pipenv</li> </ul> </li> </ul>"},{"location":"software_requirements/#optional-visual-studio-code-extensions","title":"(optional) Visual Studio Code Extensions","text":"<ul> <li>Markdown Preview Enhanced</li> <li>Github Copilot</li> <li>Python (v2023.18.0, because the newer version has some weird bugs..)</li> <li>better Comments</li> <li>autoDocstring</li> <li>Rainbow CSV</li> <li>Markdown All in One</li> </ul>"},{"location":"chessapp/","title":"chessapp","text":""},{"location":"chessapp/chessapp/","title":"chessapp","text":""},{"location":"chessapp/chessapp/#chessapp.chessapp.ChessApp","title":"<code>chessapp.chessapp.ChessApp</code>","text":"<p>             Bases: <code>QApplication</code></p> <p>This is the main application and derives from QApplication. It handles the main window (View) and all the modules (Controller). The app also has a threadpool that can be used to dispatch tasks on non-GUI threads.</p> Source code in <code>chessapp\\chessapp.py</code> <pre><code>class ChessApp(QApplication):\n    \"\"\" This is the main application and derives from QApplication. It handles the main window (View) and all the modules (Controller).\n    The app also has a threadpool that can be used to dispatch tasks on non-GUI threads.\n    \"\"\"\n\n    changing_central_widget = pyqtSignal(QWidget)\n\n    def __init__(self, tree: ChessTree, argv: list[str]):\n        \"\"\" initialises the application. This should be called by the main method of the application and only by that method.\n\n\n        Args:\n            tree (ChessTree): the tree that should be used by the application\n            argv (list[str]): arguments passed to the application by the command line/shell/operating system/parent process/...\n        \"\"\"\n        super().__init__(argv)\n        # set this at the start so other parts of the program work already before this construtor is finished...\n        self.is_closed = False\n        self.threadpool = QThreadPool()\n        self.window = AppWindow(self)\n        self.window.showMaximized()\n        opening_tree = OpeningTree(self)\n        explorer = Explorer(self, tree)\n        self.modules: [BaseModule] = [\n            Analyser(self, tree),\n            explorer,\n            opening_tree,\n            Puzzles(self, explorer, tree),\n            Saver(self, tree),\n            Updater(self, tree),\n            Quiz(self, tree, opening_tree, explorer)\n        ]\n        self.widgets = []\n        self.changing_central_widget.connect(self.__set_central_widget)\n        # register modules\n        for module in self.modules:\n            module.init()\n            module.register()\n        register_all_sounds()\n\n    def unfocus_all_modules(self):\n        \"\"\" call this method to assure that no module is focused. @See BaseModule.focus for more information.\n        \"\"\"\n        for module in self.modules:\n            module.unfocus()\n\n    def set_central_widget(self, central_widget: QWidget):\n        \"\"\" sets the central widget of the main window. This is the main method to change the view of the application. The\n        change of the central widget is not instantanious. Instead this method dispatches this task onto the GUI thread that\n        processes it at some point in the future.\n\n        Args:\n            central_widget (QWidget): the widget that should be shown in the main window\n        \"\"\"\n        self.changing_central_widget.emit(central_widget)\n\n    def __set_central_widget(self, central_widget: QWidget):\n        \"\"\" directly changes the central widget of the main window. This method should not be called directly as this is\n        a GUI action and should only be called on the GUI thread. Use set_central_widget instead.\n\n        Args:\n            central_widget (QWidget): the widget that should be shown in the main window\n        \"\"\"\n        if self.window.centralWidget():\n            self.window.centralWidget().setParent(None)\n        self.window.setCentralWidget(central_widget)\n\n    def show_status_message(self, text: str, timeout_milliseconds: int = 2000):\n        \"\"\" call this method to show a status message on the bottom of the main window.\n\n        Args:\n            text (str): the text that should be shown\n            timeout_milliseconds (int, optional): Defaults to 2000. the time in milliseconds after which the message should disappear\n        \"\"\"\n        if self.is_closed:\n            return\n        self.window.status_message_shown.emit(\n            StatusMessage(text, timeout_milliseconds))\n\n    def close(self):\n        \"\"\" closes the application and all modules.\n        \"\"\"\n        if self.is_closed:\n            return\n        self.is_closed = True\n        for module in self.modules:\n            module.close()\n        self.deleteLater()\n</code></pre>"},{"location":"chessapp/chessapp/#chessapp.chessapp.ChessApp.__init__","title":"<code>__init__(tree, argv)</code>","text":"<p>initialises the application. This should be called by the main method of the application and only by that method.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>ChessTree</code> <p>the tree that should be used by the application</p> required <code>argv</code> <code>list[str]</code> <p>arguments passed to the application by the command line/shell/operating system/parent process/...</p> required Source code in <code>chessapp\\chessapp.py</code> <pre><code>def __init__(self, tree: ChessTree, argv: list[str]):\n    \"\"\" initialises the application. This should be called by the main method of the application and only by that method.\n\n\n    Args:\n        tree (ChessTree): the tree that should be used by the application\n        argv (list[str]): arguments passed to the application by the command line/shell/operating system/parent process/...\n    \"\"\"\n    super().__init__(argv)\n    # set this at the start so other parts of the program work already before this construtor is finished...\n    self.is_closed = False\n    self.threadpool = QThreadPool()\n    self.window = AppWindow(self)\n    self.window.showMaximized()\n    opening_tree = OpeningTree(self)\n    explorer = Explorer(self, tree)\n    self.modules: [BaseModule] = [\n        Analyser(self, tree),\n        explorer,\n        opening_tree,\n        Puzzles(self, explorer, tree),\n        Saver(self, tree),\n        Updater(self, tree),\n        Quiz(self, tree, opening_tree, explorer)\n    ]\n    self.widgets = []\n    self.changing_central_widget.connect(self.__set_central_widget)\n    # register modules\n    for module in self.modules:\n        module.init()\n        module.register()\n    register_all_sounds()\n</code></pre>"},{"location":"chessapp/chessapp/#chessapp.chessapp.ChessApp.__set_central_widget","title":"<code>__set_central_widget(central_widget)</code>","text":"<p>directly changes the central widget of the main window. This method should not be called directly as this is a GUI action and should only be called on the GUI thread. Use set_central_widget instead.</p> <p>Parameters:</p> Name Type Description Default <code>central_widget</code> <code>QWidget</code> <p>the widget that should be shown in the main window</p> required Source code in <code>chessapp\\chessapp.py</code> <pre><code>def __set_central_widget(self, central_widget: QWidget):\n    \"\"\" directly changes the central widget of the main window. This method should not be called directly as this is\n    a GUI action and should only be called on the GUI thread. Use set_central_widget instead.\n\n    Args:\n        central_widget (QWidget): the widget that should be shown in the main window\n    \"\"\"\n    if self.window.centralWidget():\n        self.window.centralWidget().setParent(None)\n    self.window.setCentralWidget(central_widget)\n</code></pre>"},{"location":"chessapp/chessapp/#chessapp.chessapp.ChessApp.close","title":"<code>close()</code>","text":"<p>closes the application and all modules.</p> Source code in <code>chessapp\\chessapp.py</code> <pre><code>def close(self):\n    \"\"\" closes the application and all modules.\n    \"\"\"\n    if self.is_closed:\n        return\n    self.is_closed = True\n    for module in self.modules:\n        module.close()\n    self.deleteLater()\n</code></pre>"},{"location":"chessapp/chessapp/#chessapp.chessapp.ChessApp.set_central_widget","title":"<code>set_central_widget(central_widget)</code>","text":"<p>sets the central widget of the main window. This is the main method to change the view of the application. The change of the central widget is not instantanious. Instead this method dispatches this task onto the GUI thread that processes it at some point in the future.</p> <p>Parameters:</p> Name Type Description Default <code>central_widget</code> <code>QWidget</code> <p>the widget that should be shown in the main window</p> required Source code in <code>chessapp\\chessapp.py</code> <pre><code>def set_central_widget(self, central_widget: QWidget):\n    \"\"\" sets the central widget of the main window. This is the main method to change the view of the application. The\n    change of the central widget is not instantanious. Instead this method dispatches this task onto the GUI thread that\n    processes it at some point in the future.\n\n    Args:\n        central_widget (QWidget): the widget that should be shown in the main window\n    \"\"\"\n    self.changing_central_widget.emit(central_widget)\n</code></pre>"},{"location":"chessapp/chessapp/#chessapp.chessapp.ChessApp.show_status_message","title":"<code>show_status_message(text, timeout_milliseconds=2000)</code>","text":"<p>call this method to show a status message on the bottom of the main window.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the text that should be shown</p> required <code>timeout_milliseconds</code> <code>int</code> <p>Defaults to 2000. the time in milliseconds after which the message should disappear</p> <code>2000</code> Source code in <code>chessapp\\chessapp.py</code> <pre><code>def show_status_message(self, text: str, timeout_milliseconds: int = 2000):\n    \"\"\" call this method to show a status message on the bottom of the main window.\n\n    Args:\n        text (str): the text that should be shown\n        timeout_milliseconds (int, optional): Defaults to 2000. the time in milliseconds after which the message should disappear\n    \"\"\"\n    if self.is_closed:\n        return\n    self.window.status_message_shown.emit(\n        StatusMessage(text, timeout_milliseconds))\n</code></pre>"},{"location":"chessapp/chessapp/#chessapp.chessapp.ChessApp.unfocus_all_modules","title":"<code>unfocus_all_modules()</code>","text":"<p>call this method to assure that no module is focused. @See BaseModule.focus for more information.</p> Source code in <code>chessapp\\chessapp.py</code> <pre><code>def unfocus_all_modules(self):\n    \"\"\" call this method to assure that no module is focused. @See BaseModule.focus for more information.\n    \"\"\"\n    for module in self.modules:\n        module.unfocus()\n</code></pre>"},{"location":"chessapp/chessapp/#source","title":"Source","text":"<pre><code>from PyQt5.QtWidgets import QApplication, QWidget\nfrom chessapp.view.appwindow import AppWindow, StatusMessage\nfrom chessapp.controller.updater import Updater\nfrom chessapp.controller.saver import Saver\nfrom chessapp.controller.quiz import Quiz\nfrom chessapp.model.chesstree import ChessTree\nfrom PyQt5.QtCore import QThreadPool, pyqtSignal\nfrom chessapp.controller.analyser import Analyser\nfrom chessapp.controller.explorer import Explorer\nfrom chessapp.view.module import BaseModule\nfrom chessapp.controller.openingtree import OpeningTree\nfrom chessapp.controller.puzzles import Puzzles\nfrom chessapp.sound.chessboardsound import register_all_sounds\n\n\nclass ChessApp(QApplication):\n    \"\"\" This is the main application and derives from QApplication. It handles the main window (View) and all the modules (Controller).\n    The app also has a threadpool that can be used to dispatch tasks on non-GUI threads.\n    \"\"\"\n\n    changing_central_widget = pyqtSignal(QWidget)\n\n    def __init__(self, tree: ChessTree, argv: list[str]):\n        \"\"\" initialises the application. This should be called by the main method of the application and only by that method.\n\n\n        Args:\n            tree (ChessTree): the tree that should be used by the application\n            argv (list[str]): arguments passed to the application by the command line/shell/operating system/parent process/...\n        \"\"\"\n        super().__init__(argv)\n        # set this at the start so other parts of the program work already before this construtor is finished...\n        self.is_closed = False\n        self.threadpool = QThreadPool()\n        self.window = AppWindow(self)\n        self.window.showMaximized()\n        opening_tree = OpeningTree(self)\n        explorer = Explorer(self, tree)\n        self.modules: [BaseModule] = [\n            Analyser(self, tree),\n            explorer,\n            opening_tree,\n            Puzzles(self, explorer, tree),\n            Saver(self, tree),\n            Updater(self, tree),\n            Quiz(self, tree, opening_tree, explorer)\n        ]\n        self.widgets = []\n        self.changing_central_widget.connect(self.__set_central_widget)\n        # register modules\n        for module in self.modules:\n            module.init()\n            module.register()\n        register_all_sounds()\n\n    def unfocus_all_modules(self):\n        \"\"\" call this method to assure that no module is focused. @See BaseModule.focus for more information.\n        \"\"\"\n        for module in self.modules:\n            module.unfocus()\n\n    def set_central_widget(self, central_widget: QWidget):\n        \"\"\" sets the central widget of the main window. This is the main method to change the view of the application. The\n        change of the central widget is not instantanious. Instead this method dispatches this task onto the GUI thread that\n        processes it at some point in the future.\n\n        Args:\n            central_widget (QWidget): the widget that should be shown in the main window\n        \"\"\"\n        self.changing_central_widget.emit(central_widget)\n\n    def __set_central_widget(self, central_widget: QWidget):\n        \"\"\" directly changes the central widget of the main window. This method should not be called directly as this is\n        a GUI action and should only be called on the GUI thread. Use set_central_widget instead.\n\n        Args:\n            central_widget (QWidget): the widget that should be shown in the main window\n        \"\"\"\n        if self.window.centralWidget():\n            self.window.centralWidget().setParent(None)\n        self.window.setCentralWidget(central_widget)\n\n    def show_status_message(self, text: str, timeout_milliseconds: int = 2000):\n        \"\"\" call this method to show a status message on the bottom of the main window.\n\n        Args:\n            text (str): the text that should be shown\n            timeout_milliseconds (int, optional): Defaults to 2000. the time in milliseconds after which the message should disappear\n        \"\"\"\n        if self.is_closed:\n            return\n        self.window.status_message_shown.emit(\n            StatusMessage(text, timeout_milliseconds))\n\n    def close(self):\n        \"\"\" closes the application and all modules.\n        \"\"\"\n        if self.is_closed:\n            return\n        self.is_closed = True\n        for module in self.modules:\n            module.close()\n        self.deleteLater()\n</code></pre>"},{"location":"chessapp/configuration/","title":"configuration","text":""},{"location":"chessapp/configuration/#source","title":"Source","text":"<pre><code>from pathlib import Path\nfrom chessapp.model.sourcetype import SourceType\n\nROOT_DIR: Path = Path(__file__).parent.parent\nSTR_DEFAULT_ENCODING: str = \"utf-8\"\nDEFAULT_STYLESHEET: str = \"background-color: black; color: green;\"\nMAX_EVALBAR_VALUE_ABS: int = 10\nSQUARE_ICON_SQUARE_PERCENTAGE: float = 1 / 3\nQUIZ_ACCEPT_EVAL_DIFF: float = 0.25\nQUIZ_ACCEPT_EVAL_DIFF_RELAXED: float = 0.35\nQUIZ_ACCEPT_RELAXED_SOURCES = [SourceType.THEORY_VIDEO,\n                               SourceType.BOOK, SourceType.GM_GAME]\nPIECES_IMAGES_FOLDER_NAME: str = \"default\"\n</code></pre>"},{"location":"chessapp/controller/","title":"Controller","text":"<p>Controller are modules that can have a GUI component (many are derived from chessapp.modules.module) but mostly are concerned with controlling the logic of the app, e.g. consuming user interactions on the chessboard and changing data in chessapp.model.</p>"},{"location":"chessapp/controller/analyser/","title":"analyser","text":""},{"location":"chessapp/controller/analyser/#chessapp.controller.analyser.Analyser","title":"<code>chessapp.controller.analyser.Analyser</code>","text":"<p>             Bases: <code>ChessboardAndLogModule</code></p> Source code in <code>chessapp\\controller\\analyser.py</code> <pre><code>class Analyser(ChessboardAndLogModule):\n    def __init__(self, app, tree: ChessTree):\n        \"\"\"initialises the analyser with the given app and tree. the analyser has two actions: analyse and statistics.\n\n        Args:\n            app (chessapp.Chessapp): the main application\n            tree (ChessTree): the tree to analyse\n        \"\"\"\n        super().__init__(app, \"Analyser\", [\n            create_method_action(app, \"Analyse\", self.analyse),\n            create_method_action(app, \"Statistics\", self.print_statistics)])\n        self.tree: ChessTree = tree\n        self.app = app\n        self.engine = Engine()\n\n    def print_statistics(self):\n        \"\"\"prints statistics about the tree to the log, specifically: the number of nodes in the tree;\n        the number of nodes, average depth and number of nodes below preferred depth for each source;\n        the number of nodes with each depth; and the average depth of all nodes\n        \"\"\"\n        self.log_message(\"gathering data for statistics\")\n        depth_map = {}\n        source_depth_total = {}\n        source_depth_amount = {}\n        source_depth_below_preferal = {}\n        source_depth_preferal = {}\n        for source in SourceType:\n            source_depth_total[source] = 0\n            source_depth_amount[source] = 0\n            source_depth_below_preferal[source] = 0\n            source_depth_preferal[source] = s_analyse_desired_depth\n            if source in s_source_to_depth_map:\n                source_depth_preferal[source] = s_source_to_depth_map[source]\n        self.log_message(\"number of nodes in tree: \" +\n                         str(len(self.tree.nodes)))\n        for fen in self.tree.nodes:\n            node: Node = self.tree.nodes[fen]\n            if node.is_mate:\n                continue\n            if not node.eval_depth in depth_map:\n                depth_map[node.eval_depth] = 0\n            depth_map[node.eval_depth] += 1\n            source_depth_total[node.source()] += node.eval_depth\n            source_depth_amount[node.source()] += 1\n            if node.eval_depth &lt; source_depth_preferal[node.source()]:\n                source_depth_below_preferal[node.source()] += 1\n        for source in SourceType:\n            if source_depth_amount[source] == 0:\n                self.log_message(\"no nodes of source \" + source.sformat())\n            else:\n                self.log_message(\"source \" + source.sformat() + \" has \" + str(source_depth_amount[source]) + \" nodes with an average depth of \" + str(\n                    source_depth_total[source] / source_depth_amount[source]) + \" and \" + str(source_depth_below_preferal[source]) + \" nodes below preferred depth of \" + str(source_depth_preferal[source]))\n        average_depth: float = 0\n        for depth in depth_map:\n            self.log_message(\n                \"there are \" + str(depth_map[depth]) + \" nodes with depth \" + str(depth))\n            average_depth += depth_map[depth] * depth / len(self.tree.nodes)\n        self.log_message(\"the average depth is \" + str(average_depth))\n\n    def analyse(self):\n        \"\"\"analyses the tree up to the desired depth and time. the engine is given s_analyse_desired_time_seconds seconds to analyse each position.\n        \"\"\"\n        self.log_message(\"analysing...\")\n        self.log_message(\n            \" \".join((\"analysing up to\", str(s_analyse_max_positions), \"positions\")))\n        max_positions = s_analyse_max_positions\n        while max_positions &gt; 0 and not self.about_to_close():\n            analyse_positions = min(\n                max_positions, s_analyse_break_every_position_amount)\n            analyed_positions = self.analyse_at_depth(\n                s_analyse_desired_time_seconds, analyse_positions)\n            # if no positions have been analysed or the engine aborted/closed\n            if analyed_positions == 0 or analyed_positions == None:\n                break\n            max_positions -= analyed_positions\n            self.log_message(\n                \" \".join((str(max_positions), \"remaining\")))\n\n        self.log_message(\"analysing done\")\n\n    def analyse_at_depth(self, time_seconds: int, max_positions: int) -&gt; int:\n        \"\"\" analyses up to max_positions positions at the given depth. only positions with a lower depth than the desired depth are analysed.\n        the depth of the position is updated if the engine finds a higher depth. the engine is given time_seconds seconds to analyse each position.\n        nodes of source ENGINE_SYNTHETIC are ignored.\n\n        Args:\n            time_seconds (int): seconds the engine is given to analyse each position\n            max_positions (int): maximum amount of positions to analyse\n\n        Returns:\n            int: amount of positions analysed\n        \"\"\"\n        position_count = 0\n        # pre filter tree to avoid concurrent modification issues (RuntimeError: dictionary changed size during iteration)\n        viable_fens = []\n        for fen in self.tree.nodes:\n            if not (position_count &lt; max_positions and not self.about_to_close()):\n                break\n            node: Node = self.tree.nodes[fen]\n            source = node.source()\n            if not node.is_mate and node.source() != SourceType.ENGINE_SYNTHETIC and ((source in s_source_to_depth_map and node.eval_depth &lt; s_source_to_depth_map[source]) or (node.eval_depth &lt; s_analyse_desired_depth)):\n                viable_fens.append(fen)\n            if len(viable_fens) &gt;= max_positions - 1:\n                break\n        while position_count &lt; max_positions and not self.about_to_close():\n            found_node: bool = False\n            for source in SourceType:\n                if not (position_count &lt; max_positions and not self.about_to_close()):\n                    break\n                if source == SourceType.ENGINE_SYNTHETIC:\n                    continue\n                target_depth: int = s_analyse_desired_depth\n                if source in s_source_to_depth_map:\n                    target_depth = s_source_to_depth_map[source]\n                for fen in viable_fens:\n                    if not (position_count &lt; max_positions and not self.about_to_close()):\n                        break\n                    node = self.tree.nodes[fen]\n                    if node.source() == source and node.eval_depth &lt; target_depth and not node.is_mate:\n                        self.log_message(\" \".join((\"evaluating position\", str(node.state), \"(\" + node.source(\n                        ).sformat() + \") at depth\", str(target_depth), \"for up to\", str(time_seconds), \"seconds\")))\n                        board = Board(fen=node.state)\n                        if board.turn == WHITE:\n                            self.chess_board_widget.view_white()\n                        else:\n                            self.chess_board_widget.view_black()\n                        self.chess_board_widget.display(board)\n                        try:\n                            score_eval, score_depth, is_mate = self.engine.score(\n                                board, time_seconds, target_depth)\n                        except Exception as e:\n                            print(\"error while analysing position in analyse\")\n                            print(e)\n                            return\n                        if is_mate or score_depth &gt; node.eval_depth:\n                            self.log_message(\" \".join(\n                                (\"updating depth from\", str(node.eval_depth), \"to\", str(score_depth), \"and eval from\", str(node.eval), \"to\", str(score_eval))))\n                            node.update(score_eval, score_depth, is_mate)\n                        else:\n                            self.log_message(\" \".join((\"new depth of\", str(target_depth),\n                                                       \"does not exceed\", str(node.eval_depth))))\n                        found_node = True\n                        position_count += 1\n            if not found_node:\n                self.log_message(\"no node found, aborting\")\n                break\n        return position_count\n\n    def on_close(self):\n        \"\"\"closes the engine\n        \"\"\"\n        super().on_close()\n        self.engine.close()\n</code></pre>"},{"location":"chessapp/controller/analyser/#chessapp.controller.analyser.Analyser.__init__","title":"<code>__init__(app, tree)</code>","text":"<p>initialises the analyser with the given app and tree. the analyser has two actions: analyse and statistics.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Chessapp</code> <p>the main application</p> required <code>tree</code> <code>ChessTree</code> <p>the tree to analyse</p> required Source code in <code>chessapp\\controller\\analyser.py</code> <pre><code>def __init__(self, app, tree: ChessTree):\n    \"\"\"initialises the analyser with the given app and tree. the analyser has two actions: analyse and statistics.\n\n    Args:\n        app (chessapp.Chessapp): the main application\n        tree (ChessTree): the tree to analyse\n    \"\"\"\n    super().__init__(app, \"Analyser\", [\n        create_method_action(app, \"Analyse\", self.analyse),\n        create_method_action(app, \"Statistics\", self.print_statistics)])\n    self.tree: ChessTree = tree\n    self.app = app\n    self.engine = Engine()\n</code></pre>"},{"location":"chessapp/controller/analyser/#chessapp.controller.analyser.Analyser.analyse","title":"<code>analyse()</code>","text":"<p>analyses the tree up to the desired depth and time. the engine is given s_analyse_desired_time_seconds seconds to analyse each position.</p> Source code in <code>chessapp\\controller\\analyser.py</code> <pre><code>def analyse(self):\n    \"\"\"analyses the tree up to the desired depth and time. the engine is given s_analyse_desired_time_seconds seconds to analyse each position.\n    \"\"\"\n    self.log_message(\"analysing...\")\n    self.log_message(\n        \" \".join((\"analysing up to\", str(s_analyse_max_positions), \"positions\")))\n    max_positions = s_analyse_max_positions\n    while max_positions &gt; 0 and not self.about_to_close():\n        analyse_positions = min(\n            max_positions, s_analyse_break_every_position_amount)\n        analyed_positions = self.analyse_at_depth(\n            s_analyse_desired_time_seconds, analyse_positions)\n        # if no positions have been analysed or the engine aborted/closed\n        if analyed_positions == 0 or analyed_positions == None:\n            break\n        max_positions -= analyed_positions\n        self.log_message(\n            \" \".join((str(max_positions), \"remaining\")))\n\n    self.log_message(\"analysing done\")\n</code></pre>"},{"location":"chessapp/controller/analyser/#chessapp.controller.analyser.Analyser.analyse_at_depth","title":"<code>analyse_at_depth(time_seconds, max_positions)</code>","text":"<p>analyses up to max_positions positions at the given depth. only positions with a lower depth than the desired depth are analysed. the depth of the position is updated if the engine finds a higher depth. the engine is given time_seconds seconds to analyse each position. nodes of source ENGINE_SYNTHETIC are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>time_seconds</code> <code>int</code> <p>seconds the engine is given to analyse each position</p> required <code>max_positions</code> <code>int</code> <p>maximum amount of positions to analyse</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>amount of positions analysed</p> Source code in <code>chessapp\\controller\\analyser.py</code> <pre><code>def analyse_at_depth(self, time_seconds: int, max_positions: int) -&gt; int:\n    \"\"\" analyses up to max_positions positions at the given depth. only positions with a lower depth than the desired depth are analysed.\n    the depth of the position is updated if the engine finds a higher depth. the engine is given time_seconds seconds to analyse each position.\n    nodes of source ENGINE_SYNTHETIC are ignored.\n\n    Args:\n        time_seconds (int): seconds the engine is given to analyse each position\n        max_positions (int): maximum amount of positions to analyse\n\n    Returns:\n        int: amount of positions analysed\n    \"\"\"\n    position_count = 0\n    # pre filter tree to avoid concurrent modification issues (RuntimeError: dictionary changed size during iteration)\n    viable_fens = []\n    for fen in self.tree.nodes:\n        if not (position_count &lt; max_positions and not self.about_to_close()):\n            break\n        node: Node = self.tree.nodes[fen]\n        source = node.source()\n        if not node.is_mate and node.source() != SourceType.ENGINE_SYNTHETIC and ((source in s_source_to_depth_map and node.eval_depth &lt; s_source_to_depth_map[source]) or (node.eval_depth &lt; s_analyse_desired_depth)):\n            viable_fens.append(fen)\n        if len(viable_fens) &gt;= max_positions - 1:\n            break\n    while position_count &lt; max_positions and not self.about_to_close():\n        found_node: bool = False\n        for source in SourceType:\n            if not (position_count &lt; max_positions and not self.about_to_close()):\n                break\n            if source == SourceType.ENGINE_SYNTHETIC:\n                continue\n            target_depth: int = s_analyse_desired_depth\n            if source in s_source_to_depth_map:\n                target_depth = s_source_to_depth_map[source]\n            for fen in viable_fens:\n                if not (position_count &lt; max_positions and not self.about_to_close()):\n                    break\n                node = self.tree.nodes[fen]\n                if node.source() == source and node.eval_depth &lt; target_depth and not node.is_mate:\n                    self.log_message(\" \".join((\"evaluating position\", str(node.state), \"(\" + node.source(\n                    ).sformat() + \") at depth\", str(target_depth), \"for up to\", str(time_seconds), \"seconds\")))\n                    board = Board(fen=node.state)\n                    if board.turn == WHITE:\n                        self.chess_board_widget.view_white()\n                    else:\n                        self.chess_board_widget.view_black()\n                    self.chess_board_widget.display(board)\n                    try:\n                        score_eval, score_depth, is_mate = self.engine.score(\n                            board, time_seconds, target_depth)\n                    except Exception as e:\n                        print(\"error while analysing position in analyse\")\n                        print(e)\n                        return\n                    if is_mate or score_depth &gt; node.eval_depth:\n                        self.log_message(\" \".join(\n                            (\"updating depth from\", str(node.eval_depth), \"to\", str(score_depth), \"and eval from\", str(node.eval), \"to\", str(score_eval))))\n                        node.update(score_eval, score_depth, is_mate)\n                    else:\n                        self.log_message(\" \".join((\"new depth of\", str(target_depth),\n                                                   \"does not exceed\", str(node.eval_depth))))\n                    found_node = True\n                    position_count += 1\n        if not found_node:\n            self.log_message(\"no node found, aborting\")\n            break\n    return position_count\n</code></pre>"},{"location":"chessapp/controller/analyser/#chessapp.controller.analyser.Analyser.on_close","title":"<code>on_close()</code>","text":"<p>closes the engine</p> Source code in <code>chessapp\\controller\\analyser.py</code> <pre><code>def on_close(self):\n    \"\"\"closes the engine\n    \"\"\"\n    super().on_close()\n    self.engine.close()\n</code></pre>"},{"location":"chessapp/controller/analyser/#chessapp.controller.analyser.Analyser.print_statistics","title":"<code>print_statistics()</code>","text":"<p>prints statistics about the tree to the log, specifically: the number of nodes in the tree; the number of nodes, average depth and number of nodes below preferred depth for each source; the number of nodes with each depth; and the average depth of all nodes</p> Source code in <code>chessapp\\controller\\analyser.py</code> <pre><code>def print_statistics(self):\n    \"\"\"prints statistics about the tree to the log, specifically: the number of nodes in the tree;\n    the number of nodes, average depth and number of nodes below preferred depth for each source;\n    the number of nodes with each depth; and the average depth of all nodes\n    \"\"\"\n    self.log_message(\"gathering data for statistics\")\n    depth_map = {}\n    source_depth_total = {}\n    source_depth_amount = {}\n    source_depth_below_preferal = {}\n    source_depth_preferal = {}\n    for source in SourceType:\n        source_depth_total[source] = 0\n        source_depth_amount[source] = 0\n        source_depth_below_preferal[source] = 0\n        source_depth_preferal[source] = s_analyse_desired_depth\n        if source in s_source_to_depth_map:\n            source_depth_preferal[source] = s_source_to_depth_map[source]\n    self.log_message(\"number of nodes in tree: \" +\n                     str(len(self.tree.nodes)))\n    for fen in self.tree.nodes:\n        node: Node = self.tree.nodes[fen]\n        if node.is_mate:\n            continue\n        if not node.eval_depth in depth_map:\n            depth_map[node.eval_depth] = 0\n        depth_map[node.eval_depth] += 1\n        source_depth_total[node.source()] += node.eval_depth\n        source_depth_amount[node.source()] += 1\n        if node.eval_depth &lt; source_depth_preferal[node.source()]:\n            source_depth_below_preferal[node.source()] += 1\n    for source in SourceType:\n        if source_depth_amount[source] == 0:\n            self.log_message(\"no nodes of source \" + source.sformat())\n        else:\n            self.log_message(\"source \" + source.sformat() + \" has \" + str(source_depth_amount[source]) + \" nodes with an average depth of \" + str(\n                source_depth_total[source] / source_depth_amount[source]) + \" and \" + str(source_depth_below_preferal[source]) + \" nodes below preferred depth of \" + str(source_depth_preferal[source]))\n    average_depth: float = 0\n    for depth in depth_map:\n        self.log_message(\n            \"there are \" + str(depth_map[depth]) + \" nodes with depth \" + str(depth))\n        average_depth += depth_map[depth] * depth / len(self.tree.nodes)\n    self.log_message(\"the average depth is \" + str(average_depth))\n</code></pre>"},{"location":"chessapp/controller/analyser/#source","title":"Source","text":"<pre><code>from chessapp.model.chesstree import ChessTree\nfrom chessapp.controller.engine import Engine\nfrom chessapp.model.sourcetype import SourceType\nfrom chess import Board, WHITE\nfrom chessapp.view.module import ChessboardAndLogModule, create_method_action\nfrom chessapp.model.node import Node\n\n\ns_analyse_desired_depth = 20\ns_analyse_desired_time_seconds = 60\ns_analyse_max_positions = 1000\ns_analyse_break_every_position_amount = 10\ns_max_depth = 30\ns_source_to_depth_map = {\n    SourceType.BOOK: s_max_depth,\n    SourceType.THEORY_VIDEO: 28,\n    SourceType.QUIZ_EXPLORATION: 25,\n    SourceType.MANUAL_EXPLORATION: 23,\n    SourceType.MANUAL: 23,\n    SourceType.ENGINE_SYNTHETIC: -1,\n    SourceType.GM_GAME: 25\n}\n\n\nclass Analyser(ChessboardAndLogModule):\n    def __init__(self, app, tree: ChessTree):\n        \"\"\"initialises the analyser with the given app and tree. the analyser has two actions: analyse and statistics.\n\n        Args:\n            app (chessapp.Chessapp): the main application\n            tree (ChessTree): the tree to analyse\n        \"\"\"\n        super().__init__(app, \"Analyser\", [\n            create_method_action(app, \"Analyse\", self.analyse),\n            create_method_action(app, \"Statistics\", self.print_statistics)])\n        self.tree: ChessTree = tree\n        self.app = app\n        self.engine = Engine()\n\n    def print_statistics(self):\n        \"\"\"prints statistics about the tree to the log, specifically: the number of nodes in the tree;\n        the number of nodes, average depth and number of nodes below preferred depth for each source;\n        the number of nodes with each depth; and the average depth of all nodes\n        \"\"\"\n        self.log_message(\"gathering data for statistics\")\n        depth_map = {}\n        source_depth_total = {}\n        source_depth_amount = {}\n        source_depth_below_preferal = {}\n        source_depth_preferal = {}\n        for source in SourceType:\n            source_depth_total[source] = 0\n            source_depth_amount[source] = 0\n            source_depth_below_preferal[source] = 0\n            source_depth_preferal[source] = s_analyse_desired_depth\n            if source in s_source_to_depth_map:\n                source_depth_preferal[source] = s_source_to_depth_map[source]\n        self.log_message(\"number of nodes in tree: \" +\n                         str(len(self.tree.nodes)))\n        for fen in self.tree.nodes:\n            node: Node = self.tree.nodes[fen]\n            if node.is_mate:\n                continue\n            if not node.eval_depth in depth_map:\n                depth_map[node.eval_depth] = 0\n            depth_map[node.eval_depth] += 1\n            source_depth_total[node.source()] += node.eval_depth\n            source_depth_amount[node.source()] += 1\n            if node.eval_depth &lt; source_depth_preferal[node.source()]:\n                source_depth_below_preferal[node.source()] += 1\n        for source in SourceType:\n            if source_depth_amount[source] == 0:\n                self.log_message(\"no nodes of source \" + source.sformat())\n            else:\n                self.log_message(\"source \" + source.sformat() + \" has \" + str(source_depth_amount[source]) + \" nodes with an average depth of \" + str(\n                    source_depth_total[source] / source_depth_amount[source]) + \" and \" + str(source_depth_below_preferal[source]) + \" nodes below preferred depth of \" + str(source_depth_preferal[source]))\n        average_depth: float = 0\n        for depth in depth_map:\n            self.log_message(\n                \"there are \" + str(depth_map[depth]) + \" nodes with depth \" + str(depth))\n            average_depth += depth_map[depth] * depth / len(self.tree.nodes)\n        self.log_message(\"the average depth is \" + str(average_depth))\n\n    def analyse(self):\n        \"\"\"analyses the tree up to the desired depth and time. the engine is given s_analyse_desired_time_seconds seconds to analyse each position.\n        \"\"\"\n        self.log_message(\"analysing...\")\n        self.log_message(\n            \" \".join((\"analysing up to\", str(s_analyse_max_positions), \"positions\")))\n        max_positions = s_analyse_max_positions\n        while max_positions &gt; 0 and not self.about_to_close():\n            analyse_positions = min(\n                max_positions, s_analyse_break_every_position_amount)\n            analyed_positions = self.analyse_at_depth(\n                s_analyse_desired_time_seconds, analyse_positions)\n            # if no positions have been analysed or the engine aborted/closed\n            if analyed_positions == 0 or analyed_positions == None:\n                break\n            max_positions -= analyed_positions\n            self.log_message(\n                \" \".join((str(max_positions), \"remaining\")))\n\n        self.log_message(\"analysing done\")\n\n    def analyse_at_depth(self, time_seconds: int, max_positions: int) -&gt; int:\n        \"\"\" analyses up to max_positions positions at the given depth. only positions with a lower depth than the desired depth are analysed.\n        the depth of the position is updated if the engine finds a higher depth. the engine is given time_seconds seconds to analyse each position.\n        nodes of source ENGINE_SYNTHETIC are ignored.\n\n        Args:\n            time_seconds (int): seconds the engine is given to analyse each position\n            max_positions (int): maximum amount of positions to analyse\n\n        Returns:\n            int: amount of positions analysed\n        \"\"\"\n        position_count = 0\n        # pre filter tree to avoid concurrent modification issues (RuntimeError: dictionary changed size during iteration)\n        viable_fens = []\n        for fen in self.tree.nodes:\n            if not (position_count &lt; max_positions and not self.about_to_close()):\n                break\n            node: Node = self.tree.nodes[fen]\n            source = node.source()\n            if not node.is_mate and node.source() != SourceType.ENGINE_SYNTHETIC and ((source in s_source_to_depth_map and node.eval_depth &lt; s_source_to_depth_map[source]) or (node.eval_depth &lt; s_analyse_desired_depth)):\n                viable_fens.append(fen)\n            if len(viable_fens) &gt;= max_positions - 1:\n                break\n        while position_count &lt; max_positions and not self.about_to_close():\n            found_node: bool = False\n            for source in SourceType:\n                if not (position_count &lt; max_positions and not self.about_to_close()):\n                    break\n                if source == SourceType.ENGINE_SYNTHETIC:\n                    continue\n                target_depth: int = s_analyse_desired_depth\n                if source in s_source_to_depth_map:\n                    target_depth = s_source_to_depth_map[source]\n                for fen in viable_fens:\n                    if not (position_count &lt; max_positions and not self.about_to_close()):\n                        break\n                    node = self.tree.nodes[fen]\n                    if node.source() == source and node.eval_depth &lt; target_depth and not node.is_mate:\n                        self.log_message(\" \".join((\"evaluating position\", str(node.state), \"(\" + node.source(\n                        ).sformat() + \") at depth\", str(target_depth), \"for up to\", str(time_seconds), \"seconds\")))\n                        board = Board(fen=node.state)\n                        if board.turn == WHITE:\n                            self.chess_board_widget.view_white()\n                        else:\n                            self.chess_board_widget.view_black()\n                        self.chess_board_widget.display(board)\n                        try:\n                            score_eval, score_depth, is_mate = self.engine.score(\n                                board, time_seconds, target_depth)\n                        except Exception as e:\n                            print(\"error while analysing position in analyse\")\n                            print(e)\n                            return\n                        if is_mate or score_depth &gt; node.eval_depth:\n                            self.log_message(\" \".join(\n                                (\"updating depth from\", str(node.eval_depth), \"to\", str(score_depth), \"and eval from\", str(node.eval), \"to\", str(score_eval))))\n                            node.update(score_eval, score_depth, is_mate)\n                        else:\n                            self.log_message(\" \".join((\"new depth of\", str(target_depth),\n                                                       \"does not exceed\", str(node.eval_depth))))\n                        found_node = True\n                        position_count += 1\n            if not found_node:\n                self.log_message(\"no node found, aborting\")\n                break\n        return position_count\n\n    def on_close(self):\n        \"\"\"closes the engine\n        \"\"\"\n        super().on_close()\n        self.engine.close()\n</code></pre>"},{"location":"chessapp/controller/engine/","title":"engine","text":""},{"location":"chessapp/controller/engine/#chessapp.controller.engine.MoveDescriptor","title":"<code>chessapp.controller.engine.MoveDescriptor</code>","text":"<p>a descriptor for a move, containing the evaluation, depth, whether it is a mate, the pv (array of chess.Move) and the fen of the board before the move was made</p> Source code in <code>chessapp\\controller\\engine.py</code> <pre><code>class MoveDescriptor:\n    \"\"\"a descriptor for a move, containing the evaluation, depth, whether it is a mate, the pv (array of chess.Move) and the fen of the board before the move was made\n    \"\"\"\n\n    def __init__(self, eval: float, depth: int, is_mate: bool, pv, origin_fen: str):\n        \"\"\"_summary_\n\n        Args:\n            eval (float): evaluation of the move (which is the resulting positon after the move was made) in centipawns/100 or as 100 if mate\n            depth (int): depth of the evaluation\n            is_mate (bool): whether the move is a mate\n            pv ([chess.Move]): array of chess.Move in the principal variation (pv)\n            origin_fen (str): the fen of the board before the move was made\n        \"\"\"\n        self.eval: float = eval\n        self.depth: int = depth\n        self.is_mate: bool = is_mate\n        self.pv = pv\n        self.origin_fen: str = origin_fen\n</code></pre>"},{"location":"chessapp/controller/engine/#chessapp.controller.engine.MoveDescriptor.__init__","title":"<code>__init__(eval, depth, is_mate, pv, origin_fen)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>eval</code> <code>float</code> <p>evaluation of the move (which is the resulting positon after the move was made) in centipawns/100 or as 100 if mate</p> required <code>depth</code> <code>int</code> <p>depth of the evaluation</p> required <code>is_mate</code> <code>bool</code> <p>whether the move is a mate</p> required <code>pv</code> <code>[Move]</code> <p>array of chess.Move in the principal variation (pv)</p> required <code>origin_fen</code> <code>str</code> <p>the fen of the board before the move was made</p> required Source code in <code>chessapp\\controller\\engine.py</code> <pre><code>def __init__(self, eval: float, depth: int, is_mate: bool, pv, origin_fen: str):\n    \"\"\"_summary_\n\n    Args:\n        eval (float): evaluation of the move (which is the resulting positon after the move was made) in centipawns/100 or as 100 if mate\n        depth (int): depth of the evaluation\n        is_mate (bool): whether the move is a mate\n        pv ([chess.Move]): array of chess.Move in the principal variation (pv)\n        origin_fen (str): the fen of the board before the move was made\n    \"\"\"\n    self.eval: float = eval\n    self.depth: int = depth\n    self.is_mate: bool = is_mate\n    self.pv = pv\n    self.origin_fen: str = origin_fen\n</code></pre>"},{"location":"chessapp/controller/engine/#chessapp.controller.engine.Engine","title":"<code>chessapp.controller.engine.Engine</code>","text":"<p>a wrapper for the stockfish engine</p> Source code in <code>chessapp\\controller\\engine.py</code> <pre><code>class Engine:\n    \"\"\"a wrapper for the stockfish engine\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\" initializes the engine (e.g. opens stockfish)\n        \"\"\"\n        self.engine = SimpleEngine.popen_uci(get_stockfish_exe())\n\n    def find_best_moves(self, board: Board, time: int = s_analyse_desired_time_seconds, depth: int = s_analyse_desired_depth, multipv: int = s_multi_pv) -&gt; [MoveDescriptor]:\n        \"\"\"finds the best moves for the given board\n\n        Args:\n            board (Board): the board to find the best moves for\n            time (int, optional): Defaults to s_analyse_desired_time_seconds. the time in seconds the engine is given to analyse the position.\n            depth (int, optional): Defaults to s_analyse_desired_depth. the depth the engine is given to analyse the position.\n            multipv (int, optional): Defaults to s_multi_pv. the number of principal variations to return (e.g. the number of best moves + their specific variations)\n\n        Returns:\n            [MoveDescriptor]: array of MoveDescriptor for the best moves\n        \"\"\"\n        result = self.engine.analyse(board, Limit(\n            time=time, depth=depth), options={\"Threads\": s_engine_number_of_threads}, multipv=multipv)\n        best_moves = []\n        for i in range(0, len(result)):\n            eval = 0\n            pov_score = result[i][\"score\"]\n            if pov_score.is_mate():\n                eval = float(100)\n                if not pov_score.turn:\n                    eval = -eval\n            else:\n                eval = pov_score.white().score() / 100.0\n            best_moves.append(MoveDescriptor(\n                eval, result[i][\"depth\"], pov_score.is_mate(), result[i][\"pv\"], get_reduced_fen_from_board(board)))\n        return best_moves\n\n    def score(self, board: Board, time: int = s_analyse_desired_time_seconds, depth: int = s_analyse_desired_depth):\n        \"\"\"scores the given board. @see https://stackoverflow.com/questions/58556338/python-evaluating-a-board-position-using-stockfish-from-the-python-chess-librar\n\n        Args:\n            board (Board): the board to score\n            time (int, optional): Defaults to s_analyse_desired_time_seconds. the time in seconds the engine is given to analyse the position.\n            depth (int, optional): Defaults to s_analyse_desired_depth. the depth the engine is given to analyse the position.\n\n        Returns:\n            tuple: (eval, depth, is_mate) where eval is the evaluation of the board in centipawns/100 or as 100 if mate, depth is the depth of the evaluation and is_mate is whether the board is a mate\n        \"\"\"\n        result = self.engine.analyse(board, Limit(\n            time=time, depth=depth), options={\"Threads\": s_engine_number_of_threads}, multipv=s_multi_pv)\n        best_eval = 0\n        is_mate = False\n        for i in range(0, len(result)):\n            eval = 0\n            pov_score = result[i][\"score\"]\n            if pov_score.is_mate():\n                is_mate = True\n                eval = float(100)\n                if not pov_score.turn:\n                    eval = -eval\n            else:\n                eval = pov_score.white().score() / 100.0\n            # best move is first entry in result array\n            if i == 0:\n                best_eval = eval\n        return best_eval, result[0][\"depth\"], is_mate\n\n    def close(self):\n        \"\"\"closes the engine (closes stockfish)\n        \"\"\"\n        self.engine.close()\n</code></pre>"},{"location":"chessapp/controller/engine/#chessapp.controller.engine.Engine.__init__","title":"<code>__init__()</code>","text":"<p>initializes the engine (e.g. opens stockfish)</p> Source code in <code>chessapp\\controller\\engine.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\" initializes the engine (e.g. opens stockfish)\n    \"\"\"\n    self.engine = SimpleEngine.popen_uci(get_stockfish_exe())\n</code></pre>"},{"location":"chessapp/controller/engine/#chessapp.controller.engine.Engine.close","title":"<code>close()</code>","text":"<p>closes the engine (closes stockfish)</p> Source code in <code>chessapp\\controller\\engine.py</code> <pre><code>def close(self):\n    \"\"\"closes the engine (closes stockfish)\n    \"\"\"\n    self.engine.close()\n</code></pre>"},{"location":"chessapp/controller/engine/#chessapp.controller.engine.Engine.find_best_moves","title":"<code>find_best_moves(board, time=s_analyse_desired_time_seconds, depth=s_analyse_desired_depth, multipv=s_multi_pv)</code>","text":"<p>finds the best moves for the given board</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>the board to find the best moves for</p> required <code>time</code> <code>int</code> <p>Defaults to s_analyse_desired_time_seconds. the time in seconds the engine is given to analyse the position.</p> <code>s_analyse_desired_time_seconds</code> <code>depth</code> <code>int</code> <p>Defaults to s_analyse_desired_depth. the depth the engine is given to analyse the position.</p> <code>s_analyse_desired_depth</code> <code>multipv</code> <code>int</code> <p>Defaults to s_multi_pv. the number of principal variations to return (e.g. the number of best moves + their specific variations)</p> <code>s_multi_pv</code> <p>Returns:</p> Type Description <code>[MoveDescriptor]</code> <p>[MoveDescriptor]: array of MoveDescriptor for the best moves</p> Source code in <code>chessapp\\controller\\engine.py</code> <pre><code>def find_best_moves(self, board: Board, time: int = s_analyse_desired_time_seconds, depth: int = s_analyse_desired_depth, multipv: int = s_multi_pv) -&gt; [MoveDescriptor]:\n    \"\"\"finds the best moves for the given board\n\n    Args:\n        board (Board): the board to find the best moves for\n        time (int, optional): Defaults to s_analyse_desired_time_seconds. the time in seconds the engine is given to analyse the position.\n        depth (int, optional): Defaults to s_analyse_desired_depth. the depth the engine is given to analyse the position.\n        multipv (int, optional): Defaults to s_multi_pv. the number of principal variations to return (e.g. the number of best moves + their specific variations)\n\n    Returns:\n        [MoveDescriptor]: array of MoveDescriptor for the best moves\n    \"\"\"\n    result = self.engine.analyse(board, Limit(\n        time=time, depth=depth), options={\"Threads\": s_engine_number_of_threads}, multipv=multipv)\n    best_moves = []\n    for i in range(0, len(result)):\n        eval = 0\n        pov_score = result[i][\"score\"]\n        if pov_score.is_mate():\n            eval = float(100)\n            if not pov_score.turn:\n                eval = -eval\n        else:\n            eval = pov_score.white().score() / 100.0\n        best_moves.append(MoveDescriptor(\n            eval, result[i][\"depth\"], pov_score.is_mate(), result[i][\"pv\"], get_reduced_fen_from_board(board)))\n    return best_moves\n</code></pre>"},{"location":"chessapp/controller/engine/#chessapp.controller.engine.Engine.score","title":"<code>score(board, time=s_analyse_desired_time_seconds, depth=s_analyse_desired_depth)</code>","text":"<p>scores the given board. @see https://stackoverflow.com/questions/58556338/python-evaluating-a-board-position-using-stockfish-from-the-python-chess-librar</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>the board to score</p> required <code>time</code> <code>int</code> <p>Defaults to s_analyse_desired_time_seconds. the time in seconds the engine is given to analyse the position.</p> <code>s_analyse_desired_time_seconds</code> <code>depth</code> <code>int</code> <p>Defaults to s_analyse_desired_depth. the depth the engine is given to analyse the position.</p> <code>s_analyse_desired_depth</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(eval, depth, is_mate) where eval is the evaluation of the board in centipawns/100 or as 100 if mate, depth is the depth of the evaluation and is_mate is whether the board is a mate</p> Source code in <code>chessapp\\controller\\engine.py</code> <pre><code>def score(self, board: Board, time: int = s_analyse_desired_time_seconds, depth: int = s_analyse_desired_depth):\n    \"\"\"scores the given board. @see https://stackoverflow.com/questions/58556338/python-evaluating-a-board-position-using-stockfish-from-the-python-chess-librar\n\n    Args:\n        board (Board): the board to score\n        time (int, optional): Defaults to s_analyse_desired_time_seconds. the time in seconds the engine is given to analyse the position.\n        depth (int, optional): Defaults to s_analyse_desired_depth. the depth the engine is given to analyse the position.\n\n    Returns:\n        tuple: (eval, depth, is_mate) where eval is the evaluation of the board in centipawns/100 or as 100 if mate, depth is the depth of the evaluation and is_mate is whether the board is a mate\n    \"\"\"\n    result = self.engine.analyse(board, Limit(\n        time=time, depth=depth), options={\"Threads\": s_engine_number_of_threads}, multipv=s_multi_pv)\n    best_eval = 0\n    is_mate = False\n    for i in range(0, len(result)):\n        eval = 0\n        pov_score = result[i][\"score\"]\n        if pov_score.is_mate():\n            is_mate = True\n            eval = float(100)\n            if not pov_score.turn:\n                eval = -eval\n        else:\n            eval = pov_score.white().score() / 100.0\n        # best move is first entry in result array\n        if i == 0:\n            best_eval = eval\n    return best_eval, result[0][\"depth\"], is_mate\n</code></pre>"},{"location":"chessapp/controller/engine/#source","title":"Source","text":"<pre><code>from chess import Board\nfrom chess.engine import Limit, SimpleEngine\nfrom chessapp.model.chesstree import get_reduced_fen_from_board\nfrom chessapp.util.paths import get_stockfish_exe\n\ns_analyse_desired_time_seconds: int = 30\ns_analyse_desired_depth: int = 30\ns_engine_number_of_threads: int = 14\ns_multi_pv: int = 1\n\n\nclass MoveDescriptor:\n    \"\"\"a descriptor for a move, containing the evaluation, depth, whether it is a mate, the pv (array of chess.Move) and the fen of the board before the move was made\n    \"\"\"\n\n    def __init__(self, eval: float, depth: int, is_mate: bool, pv, origin_fen: str):\n        \"\"\"_summary_\n\n        Args:\n            eval (float): evaluation of the move (which is the resulting positon after the move was made) in centipawns/100 or as 100 if mate\n            depth (int): depth of the evaluation\n            is_mate (bool): whether the move is a mate\n            pv ([chess.Move]): array of chess.Move in the principal variation (pv)\n            origin_fen (str): the fen of the board before the move was made\n        \"\"\"\n        self.eval: float = eval\n        self.depth: int = depth\n        self.is_mate: bool = is_mate\n        self.pv = pv\n        self.origin_fen: str = origin_fen\n\n\nclass Engine:\n    \"\"\"a wrapper for the stockfish engine\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\" initializes the engine (e.g. opens stockfish)\n        \"\"\"\n        self.engine = SimpleEngine.popen_uci(get_stockfish_exe())\n\n    def find_best_moves(self, board: Board, time: int = s_analyse_desired_time_seconds, depth: int = s_analyse_desired_depth, multipv: int = s_multi_pv) -&gt; [MoveDescriptor]:\n        \"\"\"finds the best moves for the given board\n\n        Args:\n            board (Board): the board to find the best moves for\n            time (int, optional): Defaults to s_analyse_desired_time_seconds. the time in seconds the engine is given to analyse the position.\n            depth (int, optional): Defaults to s_analyse_desired_depth. the depth the engine is given to analyse the position.\n            multipv (int, optional): Defaults to s_multi_pv. the number of principal variations to return (e.g. the number of best moves + their specific variations)\n\n        Returns:\n            [MoveDescriptor]: array of MoveDescriptor for the best moves\n        \"\"\"\n        result = self.engine.analyse(board, Limit(\n            time=time, depth=depth), options={\"Threads\": s_engine_number_of_threads}, multipv=multipv)\n        best_moves = []\n        for i in range(0, len(result)):\n            eval = 0\n            pov_score = result[i][\"score\"]\n            if pov_score.is_mate():\n                eval = float(100)\n                if not pov_score.turn:\n                    eval = -eval\n            else:\n                eval = pov_score.white().score() / 100.0\n            best_moves.append(MoveDescriptor(\n                eval, result[i][\"depth\"], pov_score.is_mate(), result[i][\"pv\"], get_reduced_fen_from_board(board)))\n        return best_moves\n\n    def score(self, board: Board, time: int = s_analyse_desired_time_seconds, depth: int = s_analyse_desired_depth):\n        \"\"\"scores the given board. @see https://stackoverflow.com/questions/58556338/python-evaluating-a-board-position-using-stockfish-from-the-python-chess-librar\n\n        Args:\n            board (Board): the board to score\n            time (int, optional): Defaults to s_analyse_desired_time_seconds. the time in seconds the engine is given to analyse the position.\n            depth (int, optional): Defaults to s_analyse_desired_depth. the depth the engine is given to analyse the position.\n\n        Returns:\n            tuple: (eval, depth, is_mate) where eval is the evaluation of the board in centipawns/100 or as 100 if mate, depth is the depth of the evaluation and is_mate is whether the board is a mate\n        \"\"\"\n        result = self.engine.analyse(board, Limit(\n            time=time, depth=depth), options={\"Threads\": s_engine_number_of_threads}, multipv=s_multi_pv)\n        best_eval = 0\n        is_mate = False\n        for i in range(0, len(result)):\n            eval = 0\n            pov_score = result[i][\"score\"]\n            if pov_score.is_mate():\n                is_mate = True\n                eval = float(100)\n                if not pov_score.turn:\n                    eval = -eval\n            else:\n                eval = pov_score.white().score() / 100.0\n            # best move is first entry in result array\n            if i == 0:\n                best_eval = eval\n        return best_eval, result[0][\"depth\"], is_mate\n\n    def close(self):\n        \"\"\"closes the engine (closes stockfish)\n        \"\"\"\n        self.engine.close()\n</code></pre>"},{"location":"chessapp/controller/explorer/","title":"explorer","text":""},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer","title":"<code>chessapp.controller.explorer.Explorer</code>","text":"<p>             Bases: <code>ChessboardAndLogModule</code></p> <p>Explore the ChessTree by playing moves on the board. The quality of the moves will be analysed by the engine and icons indicating the quality will be shown on the board. An evalbar is shown to further indicate the position evaluation. This module has several actions to both analyse a positon and show moves for a position that already have been found and analysed.</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>class Explorer(ChessboardAndLogModule):\n    \"\"\" Explore the ChessTree by playing moves on the board. The quality of the moves will be analysed by the engine and icons\n    indicating the quality will be shown on the board. An evalbar is shown to further indicate the position evaluation. This\n    module has several actions to both analyse a positon and show moves for a position that already have been found and analysed.\n    \"\"\"\n\n    def __init__(self, app, tree: ChessTree):\n        \"\"\" Create a new Explorer module.\n\n        Args:\n            app (_type_): _description_\n            tree (ChessTree): _description_\n        \"\"\"\n        super().__init__(app, \"Explorer\", [\n            create_method_action(app, \"Analyse d=25\", self.analyse_d25),\n            create_method_action(app, \"Analyse d=30\", self.analyse_d30),\n            create_method_action(app, \"Analyse d=35\", self.analyse_d35),\n            create_method_action(app, \"Back\", self.on_back),\n            create_method_action(app, \"Find Best Moves: d=\" + str(s_best_moves_eval_depth) +\n                                 \", multipv=\" + str(s_best_moves_multipv), self.find_best_moves),\n            create_method_action(\n                app, \"Flip Board\", self.flip_board),\n            create_method_action(app, \"Reset\", self.reset_board),\n            create_method_action(app, \"Show FEN\", self.show_fen),\n            create_method_action(app, \"Show Known Moves\",\n                                 self.show_known_moves)\n        ])\n        self.app = app\n        self.tree = tree\n        self.board = Board()\n        self.engine = Engine()\n        self.previous_node = None\n        self.last_move = None\n\n    def on_register(self):\n        \"\"\" @see ChessboardAndLogModule.on_register\n        \"\"\"\n        self.reset_board()\n        self.chess_board_widget.view_white()\n        self.chess_board_widget.eval_bar.is_visible = True\n        self.chess_board_widget.board.show_best_move = True\n\n    def flip_board(self):\n        \"\"\" Flips the board\n        \"\"\"\n        self.chess_board_widget.flip_board()\n\n    def find_best_moves(self):\n        \"\"\" Finds the best moves for the current position and adds them to the tree.\n        \"\"\"\n        base_fen = get_reduced_fen_from_board(self.board)\n        base_board = Board(base_fen)\n        node: Node = self.tree.get(base_fen)\n        self.log_message(\"finding up to \" + str(s_best_moves_multipv) + \" best moves for position \" +\n                         str(node.state) + \" at depth \" + str(s_best_moves_eval_depth))\n        try:\n            best_moves = self.engine.find_best_moves(\n                base_board, s_eval_time_seconds, s_best_moves_eval_depth, multipv=s_best_moves_multipv)\n        except Exception as e:\n            print(\"error while analysing position in explorer\")\n            print(e)\n            return\n        for move_descriptor in best_moves:\n            self.consume_move_descriptor(move_descriptor)\n        self.display()\n\n    def on_back(self):\n        \"\"\" tries to return from the current board state to the previous board state. @see ChessboardAndLogModule.on_back\n        \"\"\"\n        try:\n            self.board.pop()\n            self.reset_last_move()\n            self.display(False)\n        except IndexError:\n            pass\n\n    def analyse_d25(self):\n        \"\"\" analyse the current position at depth 25. @see analyse_position\n        \"\"\"\n        self.analyse_position(25)\n\n    def analyse_d30(self):\n        \"\"\" analyse the current position at depth 30. @see analyse_position\n        \"\"\"\n        self.analyse_position(30)\n\n    def analyse_d35(self):\n        \"\"\" analyse the current position at depth 35. @see analyse_position\n        \"\"\"\n        self.analyse_position(35)\n\n    def consume_move_descriptor(self, move_descriptor: MoveDescriptor):\n        \"\"\" Tries to update the tree based on the given move descriptor.\n\n        Args:\n            move_descriptor (MoveDescriptor): _description_\n        \"\"\"\n        copy_board = Board(move_descriptor.origin_fen)\n        san: str = copy_board.san(move_descriptor.pv[0])\n        copy_board.push_san(san)\n        fen_result = get_reduced_fen_from_board(copy_board)\n        node_result = self.tree.get(fen_result)\n        if node_result.eval_depth &lt; move_descriptor.depth:\n            node_result.update(\n                move_descriptor.eval, move_descriptor.depth - 1, move_descriptor.is_mate)\n        origin_node = self.tree.get(move_descriptor.origin_fen)\n        origin_node.update(move_descriptor.eval,\n                           move_descriptor.depth, move_descriptor.is_mate)\n        move = chessapp.model.move.Move(self.tree, san, fen_result,\n                                        source=SourceType.ENGINE_SYNTHETIC)\n        origin_node.add(move)\n        self.log_message(\"found move \" + san + \" with score \" + str(move_descriptor.eval) +\n                         \" and cp loss \" + str(origin_node.get_cp_loss(move)) + \" at depth \" + str(origin_node.eval_depth) + (\n            \" (which is a forced mate)\" if origin_node.is_mate else \"\")\n            + \" from source \" + node_result.source().sformat())\n\n    def analyse_position(self, depth: int = s_eval_depth):\n        \"\"\" Analyses the current position at the given depth. The result will be added to the tree.\n\n        Args:\n            depth (int, optional): Defaults to s_eval_depth. The depth to analyse the position at.\n        \"\"\"\n        base_fen = get_reduced_fen_from_board(self.board)\n        base_board = Board(base_fen)\n        node: Node = self.tree.get(base_fen)\n        if (node.eval_depth &lt; depth or len(node.moves) == 0) and not node.is_mate:\n            self.log_message(\"analysing position\")\n            try:\n                best_moves = self.engine.find_best_moves(\n                    base_board, s_eval_time_seconds, depth, multipv=1)\n                for best_move in best_moves:\n                    self.consume_move_descriptor(best_move)\n            except Exception as e:\n                print(\"error while analysing position in explorer\")\n                print(e)\n                return\n            self.display(perform_analysis=False)\n            self.log_message(\"position analysed\")\n\n    def set_board(self, board: Board):\n        \"\"\" called by other modules to set the board of this module.\n\n        Args:\n            board (Board): the board to set\n        \"\"\"\n        if not board:\n            return\n        self.reset_board()\n        self.board = board.copy()\n        self.display()\n\n    def display(self, perform_analysis: bool = True, play_sound: bool = False):\n        \"\"\" Displays the current board state. Choose whether to play a sound or not: A sound could represent a move\n        or the start of a game. Sometimes this behaviour is not desired (e.g. when setting the board and displaying\n        it without any prior user interaction).\n\n        Args:\n            perform_analysis (bool, optional): Defaults to True. Whether to perform an analysis of the current position.\n            play_sound (bool, optional): Defaults to False. Whether to play a sound when displaying the board. \n        \"\"\"\n        node = self.tree.get(get_reduced_fen_from_board(self.board))\n        self.chess_board_widget.display(\n            self.board, node, self.previous_node, self.last_move, play_sound=play_sound)\n        if perform_analysis:\n            self.app.threadpool.start(MethodAction(self.analyse_d25))\n\n    def show_fen(self):\n        \"\"\" Shows the fen of the current board state.\n        \"\"\"\n        self.log_message(get_reduced_fen_from_board(self.board))\n\n    def show_known_moves(self):\n        \"\"\" Shows the known moves for the current board state.\n        \"\"\"\n        self.show_fen()\n        node = self.tree.get(get_reduced_fen_from_board(self.board))\n        if node.has_move():\n            for move in node.moves:\n                self.log_message(move.get_info(node))\n        else:\n            self.log_message(\"no moves known for this node\")\n\n    def on_piece_movement(self, piece_movement: PieceMovement):\n        \"\"\" reacts to a user interaction with the board and tries to perform the given move. @see ChessboardAndLogModule.on_piece_movement\n\n        Args:\n            piece_movement (PieceMovement): the move to perform\n        \"\"\"\n        if self.about_to_close():\n            return\n        self.last_move = None\n        self.previous_node = None\n        try:\n            fen = get_reduced_fen_from_board(self.board)\n            node = self.tree.get(fen)\n            san = self.board.san(chess.Move.from_uci(\n                piece_movement.uci_format()))\n            board_copy = Board(fen)\n            board_copy.push_san(san)\n            result = get_reduced_fen_from_board(board_copy)\n            move = chessapp.model.move.Move(\n                self.tree, san, result, source=SourceType.MANUAL_EXPLORATION)\n            if not node.knows_move(move):\n                node.add(move)\n            self.board.push_san(san)\n            self.previous_node = node\n            self.last_move = move\n            self.display(play_sound=True)\n        except Exception as e:\n            print(\"error while exploring\")\n            print(traceback.format_exc())\n\n    def reset_last_move(self):\n        \"\"\" Forgets the last move and previous node and practially makes this module behave as if there was no prior board state.\n        \"\"\"\n        self.last_move = None\n        self.previous_node = None\n\n    def reset_board(self):\n        \"\"\" Resets the board to the initial state.\n        \"\"\"\n        self.board = Board()\n        self.reset_last_move()\n        self.chess_board_widget.reset()\n        self.display()\n\n    def on_close(self):\n        \"\"\" closes the engine. @see ChessboardAndLogModule.on_close\n        \"\"\"\n        self.engine.close()\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.__init__","title":"<code>__init__(app, tree)</code>","text":"<p>Create a new Explorer module.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>_type_</code> <p>description</p> required <code>tree</code> <code>ChessTree</code> <p>description</p> required Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def __init__(self, app, tree: ChessTree):\n    \"\"\" Create a new Explorer module.\n\n    Args:\n        app (_type_): _description_\n        tree (ChessTree): _description_\n    \"\"\"\n    super().__init__(app, \"Explorer\", [\n        create_method_action(app, \"Analyse d=25\", self.analyse_d25),\n        create_method_action(app, \"Analyse d=30\", self.analyse_d30),\n        create_method_action(app, \"Analyse d=35\", self.analyse_d35),\n        create_method_action(app, \"Back\", self.on_back),\n        create_method_action(app, \"Find Best Moves: d=\" + str(s_best_moves_eval_depth) +\n                             \", multipv=\" + str(s_best_moves_multipv), self.find_best_moves),\n        create_method_action(\n            app, \"Flip Board\", self.flip_board),\n        create_method_action(app, \"Reset\", self.reset_board),\n        create_method_action(app, \"Show FEN\", self.show_fen),\n        create_method_action(app, \"Show Known Moves\",\n                             self.show_known_moves)\n    ])\n    self.app = app\n    self.tree = tree\n    self.board = Board()\n    self.engine = Engine()\n    self.previous_node = None\n    self.last_move = None\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.analyse_d25","title":"<code>analyse_d25()</code>","text":"<p>analyse the current position at depth 25. @see analyse_position</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def analyse_d25(self):\n    \"\"\" analyse the current position at depth 25. @see analyse_position\n    \"\"\"\n    self.analyse_position(25)\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.analyse_d30","title":"<code>analyse_d30()</code>","text":"<p>analyse the current position at depth 30. @see analyse_position</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def analyse_d30(self):\n    \"\"\" analyse the current position at depth 30. @see analyse_position\n    \"\"\"\n    self.analyse_position(30)\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.analyse_d35","title":"<code>analyse_d35()</code>","text":"<p>analyse the current position at depth 35. @see analyse_position</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def analyse_d35(self):\n    \"\"\" analyse the current position at depth 35. @see analyse_position\n    \"\"\"\n    self.analyse_position(35)\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.analyse_position","title":"<code>analyse_position(depth=s_eval_depth)</code>","text":"<p>Analyses the current position at the given depth. The result will be added to the tree.</p> <p>Parameters:</p> Name Type Description Default <code>depth</code> <code>int</code> <p>Defaults to s_eval_depth. The depth to analyse the position at.</p> <code>s_eval_depth</code> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def analyse_position(self, depth: int = s_eval_depth):\n    \"\"\" Analyses the current position at the given depth. The result will be added to the tree.\n\n    Args:\n        depth (int, optional): Defaults to s_eval_depth. The depth to analyse the position at.\n    \"\"\"\n    base_fen = get_reduced_fen_from_board(self.board)\n    base_board = Board(base_fen)\n    node: Node = self.tree.get(base_fen)\n    if (node.eval_depth &lt; depth or len(node.moves) == 0) and not node.is_mate:\n        self.log_message(\"analysing position\")\n        try:\n            best_moves = self.engine.find_best_moves(\n                base_board, s_eval_time_seconds, depth, multipv=1)\n            for best_move in best_moves:\n                self.consume_move_descriptor(best_move)\n        except Exception as e:\n            print(\"error while analysing position in explorer\")\n            print(e)\n            return\n        self.display(perform_analysis=False)\n        self.log_message(\"position analysed\")\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.consume_move_descriptor","title":"<code>consume_move_descriptor(move_descriptor)</code>","text":"<p>Tries to update the tree based on the given move descriptor.</p> <p>Parameters:</p> Name Type Description Default <code>move_descriptor</code> <code>MoveDescriptor</code> <p>description</p> required Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def consume_move_descriptor(self, move_descriptor: MoveDescriptor):\n    \"\"\" Tries to update the tree based on the given move descriptor.\n\n    Args:\n        move_descriptor (MoveDescriptor): _description_\n    \"\"\"\n    copy_board = Board(move_descriptor.origin_fen)\n    san: str = copy_board.san(move_descriptor.pv[0])\n    copy_board.push_san(san)\n    fen_result = get_reduced_fen_from_board(copy_board)\n    node_result = self.tree.get(fen_result)\n    if node_result.eval_depth &lt; move_descriptor.depth:\n        node_result.update(\n            move_descriptor.eval, move_descriptor.depth - 1, move_descriptor.is_mate)\n    origin_node = self.tree.get(move_descriptor.origin_fen)\n    origin_node.update(move_descriptor.eval,\n                       move_descriptor.depth, move_descriptor.is_mate)\n    move = chessapp.model.move.Move(self.tree, san, fen_result,\n                                    source=SourceType.ENGINE_SYNTHETIC)\n    origin_node.add(move)\n    self.log_message(\"found move \" + san + \" with score \" + str(move_descriptor.eval) +\n                     \" and cp loss \" + str(origin_node.get_cp_loss(move)) + \" at depth \" + str(origin_node.eval_depth) + (\n        \" (which is a forced mate)\" if origin_node.is_mate else \"\")\n        + \" from source \" + node_result.source().sformat())\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.display","title":"<code>display(perform_analysis=True, play_sound=False)</code>","text":"<p>Displays the current board state. Choose whether to play a sound or not: A sound could represent a move or the start of a game. Sometimes this behaviour is not desired (e.g. when setting the board and displaying it without any prior user interaction).</p> <p>Parameters:</p> Name Type Description Default <code>perform_analysis</code> <code>bool</code> <p>Defaults to True. Whether to perform an analysis of the current position.</p> <code>True</code> <code>play_sound</code> <code>bool</code> <p>Defaults to False. Whether to play a sound when displaying the board.</p> <code>False</code> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def display(self, perform_analysis: bool = True, play_sound: bool = False):\n    \"\"\" Displays the current board state. Choose whether to play a sound or not: A sound could represent a move\n    or the start of a game. Sometimes this behaviour is not desired (e.g. when setting the board and displaying\n    it without any prior user interaction).\n\n    Args:\n        perform_analysis (bool, optional): Defaults to True. Whether to perform an analysis of the current position.\n        play_sound (bool, optional): Defaults to False. Whether to play a sound when displaying the board. \n    \"\"\"\n    node = self.tree.get(get_reduced_fen_from_board(self.board))\n    self.chess_board_widget.display(\n        self.board, node, self.previous_node, self.last_move, play_sound=play_sound)\n    if perform_analysis:\n        self.app.threadpool.start(MethodAction(self.analyse_d25))\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.find_best_moves","title":"<code>find_best_moves()</code>","text":"<p>Finds the best moves for the current position and adds them to the tree.</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def find_best_moves(self):\n    \"\"\" Finds the best moves for the current position and adds them to the tree.\n    \"\"\"\n    base_fen = get_reduced_fen_from_board(self.board)\n    base_board = Board(base_fen)\n    node: Node = self.tree.get(base_fen)\n    self.log_message(\"finding up to \" + str(s_best_moves_multipv) + \" best moves for position \" +\n                     str(node.state) + \" at depth \" + str(s_best_moves_eval_depth))\n    try:\n        best_moves = self.engine.find_best_moves(\n            base_board, s_eval_time_seconds, s_best_moves_eval_depth, multipv=s_best_moves_multipv)\n    except Exception as e:\n        print(\"error while analysing position in explorer\")\n        print(e)\n        return\n    for move_descriptor in best_moves:\n        self.consume_move_descriptor(move_descriptor)\n    self.display()\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.flip_board","title":"<code>flip_board()</code>","text":"<p>Flips the board</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def flip_board(self):\n    \"\"\" Flips the board\n    \"\"\"\n    self.chess_board_widget.flip_board()\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.on_back","title":"<code>on_back()</code>","text":"<p>tries to return from the current board state to the previous board state. @see ChessboardAndLogModule.on_back</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def on_back(self):\n    \"\"\" tries to return from the current board state to the previous board state. @see ChessboardAndLogModule.on_back\n    \"\"\"\n    try:\n        self.board.pop()\n        self.reset_last_move()\n        self.display(False)\n    except IndexError:\n        pass\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.on_close","title":"<code>on_close()</code>","text":"<p>closes the engine. @see ChessboardAndLogModule.on_close</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def on_close(self):\n    \"\"\" closes the engine. @see ChessboardAndLogModule.on_close\n    \"\"\"\n    self.engine.close()\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.on_piece_movement","title":"<code>on_piece_movement(piece_movement)</code>","text":"<p>reacts to a user interaction with the board and tries to perform the given move. @see ChessboardAndLogModule.on_piece_movement</p> <p>Parameters:</p> Name Type Description Default <code>piece_movement</code> <code>PieceMovement</code> <p>the move to perform</p> required Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def on_piece_movement(self, piece_movement: PieceMovement):\n    \"\"\" reacts to a user interaction with the board and tries to perform the given move. @see ChessboardAndLogModule.on_piece_movement\n\n    Args:\n        piece_movement (PieceMovement): the move to perform\n    \"\"\"\n    if self.about_to_close():\n        return\n    self.last_move = None\n    self.previous_node = None\n    try:\n        fen = get_reduced_fen_from_board(self.board)\n        node = self.tree.get(fen)\n        san = self.board.san(chess.Move.from_uci(\n            piece_movement.uci_format()))\n        board_copy = Board(fen)\n        board_copy.push_san(san)\n        result = get_reduced_fen_from_board(board_copy)\n        move = chessapp.model.move.Move(\n            self.tree, san, result, source=SourceType.MANUAL_EXPLORATION)\n        if not node.knows_move(move):\n            node.add(move)\n        self.board.push_san(san)\n        self.previous_node = node\n        self.last_move = move\n        self.display(play_sound=True)\n    except Exception as e:\n        print(\"error while exploring\")\n        print(traceback.format_exc())\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.on_register","title":"<code>on_register()</code>","text":"<p>@see ChessboardAndLogModule.on_register</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def on_register(self):\n    \"\"\" @see ChessboardAndLogModule.on_register\n    \"\"\"\n    self.reset_board()\n    self.chess_board_widget.view_white()\n    self.chess_board_widget.eval_bar.is_visible = True\n    self.chess_board_widget.board.show_best_move = True\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.reset_board","title":"<code>reset_board()</code>","text":"<p>Resets the board to the initial state.</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def reset_board(self):\n    \"\"\" Resets the board to the initial state.\n    \"\"\"\n    self.board = Board()\n    self.reset_last_move()\n    self.chess_board_widget.reset()\n    self.display()\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.reset_last_move","title":"<code>reset_last_move()</code>","text":"<p>Forgets the last move and previous node and practially makes this module behave as if there was no prior board state.</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def reset_last_move(self):\n    \"\"\" Forgets the last move and previous node and practially makes this module behave as if there was no prior board state.\n    \"\"\"\n    self.last_move = None\n    self.previous_node = None\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.set_board","title":"<code>set_board(board)</code>","text":"<p>called by other modules to set the board of this module.</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>the board to set</p> required Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def set_board(self, board: Board):\n    \"\"\" called by other modules to set the board of this module.\n\n    Args:\n        board (Board): the board to set\n    \"\"\"\n    if not board:\n        return\n    self.reset_board()\n    self.board = board.copy()\n    self.display()\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.show_fen","title":"<code>show_fen()</code>","text":"<p>Shows the fen of the current board state.</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def show_fen(self):\n    \"\"\" Shows the fen of the current board state.\n    \"\"\"\n    self.log_message(get_reduced_fen_from_board(self.board))\n</code></pre>"},{"location":"chessapp/controller/explorer/#chessapp.controller.explorer.Explorer.show_known_moves","title":"<code>show_known_moves()</code>","text":"<p>Shows the known moves for the current board state.</p> Source code in <code>chessapp\\controller\\explorer.py</code> <pre><code>def show_known_moves(self):\n    \"\"\" Shows the known moves for the current board state.\n    \"\"\"\n    self.show_fen()\n    node = self.tree.get(get_reduced_fen_from_board(self.board))\n    if node.has_move():\n        for move in node.moves:\n            self.log_message(move.get_info(node))\n    else:\n        self.log_message(\"no moves known for this node\")\n</code></pre>"},{"location":"chessapp/controller/explorer/#source","title":"Source","text":"<pre><code>from chessapp.model.chesstree import ChessTree\nfrom chessapp.view.chessboardwidget import PieceMovement\nfrom chess import Board\nimport chess\nimport chessapp.model.move\nfrom chessapp.view.module import ChessboardAndLogModule, create_method_action, MethodAction\nfrom chessapp.controller.engine import Engine, MoveDescriptor\nimport traceback\nfrom chessapp.model.node import Node\nimport chess\nfrom chessapp.model.sourcetype import SourceType\nfrom chessapp.util.fen import get_reduced_fen_from_board\n\ns_eval_time_seconds = 60\ns_eval_depth = 20\ns_best_moves_eval_depth = 30\ns_best_moves_multipv = 3\n\n\nclass Explorer(ChessboardAndLogModule):\n    \"\"\" Explore the ChessTree by playing moves on the board. The quality of the moves will be analysed by the engine and icons\n    indicating the quality will be shown on the board. An evalbar is shown to further indicate the position evaluation. This\n    module has several actions to both analyse a positon and show moves for a position that already have been found and analysed.\n    \"\"\"\n\n    def __init__(self, app, tree: ChessTree):\n        \"\"\" Create a new Explorer module.\n\n        Args:\n            app (_type_): _description_\n            tree (ChessTree): _description_\n        \"\"\"\n        super().__init__(app, \"Explorer\", [\n            create_method_action(app, \"Analyse d=25\", self.analyse_d25),\n            create_method_action(app, \"Analyse d=30\", self.analyse_d30),\n            create_method_action(app, \"Analyse d=35\", self.analyse_d35),\n            create_method_action(app, \"Back\", self.on_back),\n            create_method_action(app, \"Find Best Moves: d=\" + str(s_best_moves_eval_depth) +\n                                 \", multipv=\" + str(s_best_moves_multipv), self.find_best_moves),\n            create_method_action(\n                app, \"Flip Board\", self.flip_board),\n            create_method_action(app, \"Reset\", self.reset_board),\n            create_method_action(app, \"Show FEN\", self.show_fen),\n            create_method_action(app, \"Show Known Moves\",\n                                 self.show_known_moves)\n        ])\n        self.app = app\n        self.tree = tree\n        self.board = Board()\n        self.engine = Engine()\n        self.previous_node = None\n        self.last_move = None\n\n    def on_register(self):\n        \"\"\" @see ChessboardAndLogModule.on_register\n        \"\"\"\n        self.reset_board()\n        self.chess_board_widget.view_white()\n        self.chess_board_widget.eval_bar.is_visible = True\n        self.chess_board_widget.board.show_best_move = True\n\n    def flip_board(self):\n        \"\"\" Flips the board\n        \"\"\"\n        self.chess_board_widget.flip_board()\n\n    def find_best_moves(self):\n        \"\"\" Finds the best moves for the current position and adds them to the tree.\n        \"\"\"\n        base_fen = get_reduced_fen_from_board(self.board)\n        base_board = Board(base_fen)\n        node: Node = self.tree.get(base_fen)\n        self.log_message(\"finding up to \" + str(s_best_moves_multipv) + \" best moves for position \" +\n                         str(node.state) + \" at depth \" + str(s_best_moves_eval_depth))\n        try:\n            best_moves = self.engine.find_best_moves(\n                base_board, s_eval_time_seconds, s_best_moves_eval_depth, multipv=s_best_moves_multipv)\n        except Exception as e:\n            print(\"error while analysing position in explorer\")\n            print(e)\n            return\n        for move_descriptor in best_moves:\n            self.consume_move_descriptor(move_descriptor)\n        self.display()\n\n    def on_back(self):\n        \"\"\" tries to return from the current board state to the previous board state. @see ChessboardAndLogModule.on_back\n        \"\"\"\n        try:\n            self.board.pop()\n            self.reset_last_move()\n            self.display(False)\n        except IndexError:\n            pass\n\n    def analyse_d25(self):\n        \"\"\" analyse the current position at depth 25. @see analyse_position\n        \"\"\"\n        self.analyse_position(25)\n\n    def analyse_d30(self):\n        \"\"\" analyse the current position at depth 30. @see analyse_position\n        \"\"\"\n        self.analyse_position(30)\n\n    def analyse_d35(self):\n        \"\"\" analyse the current position at depth 35. @see analyse_position\n        \"\"\"\n        self.analyse_position(35)\n\n    def consume_move_descriptor(self, move_descriptor: MoveDescriptor):\n        \"\"\" Tries to update the tree based on the given move descriptor.\n\n        Args:\n            move_descriptor (MoveDescriptor): _description_\n        \"\"\"\n        copy_board = Board(move_descriptor.origin_fen)\n        san: str = copy_board.san(move_descriptor.pv[0])\n        copy_board.push_san(san)\n        fen_result = get_reduced_fen_from_board(copy_board)\n        node_result = self.tree.get(fen_result)\n        if node_result.eval_depth &lt; move_descriptor.depth:\n            node_result.update(\n                move_descriptor.eval, move_descriptor.depth - 1, move_descriptor.is_mate)\n        origin_node = self.tree.get(move_descriptor.origin_fen)\n        origin_node.update(move_descriptor.eval,\n                           move_descriptor.depth, move_descriptor.is_mate)\n        move = chessapp.model.move.Move(self.tree, san, fen_result,\n                                        source=SourceType.ENGINE_SYNTHETIC)\n        origin_node.add(move)\n        self.log_message(\"found move \" + san + \" with score \" + str(move_descriptor.eval) +\n                         \" and cp loss \" + str(origin_node.get_cp_loss(move)) + \" at depth \" + str(origin_node.eval_depth) + (\n            \" (which is a forced mate)\" if origin_node.is_mate else \"\")\n            + \" from source \" + node_result.source().sformat())\n\n    def analyse_position(self, depth: int = s_eval_depth):\n        \"\"\" Analyses the current position at the given depth. The result will be added to the tree.\n\n        Args:\n            depth (int, optional): Defaults to s_eval_depth. The depth to analyse the position at.\n        \"\"\"\n        base_fen = get_reduced_fen_from_board(self.board)\n        base_board = Board(base_fen)\n        node: Node = self.tree.get(base_fen)\n        if (node.eval_depth &lt; depth or len(node.moves) == 0) and not node.is_mate:\n            self.log_message(\"analysing position\")\n            try:\n                best_moves = self.engine.find_best_moves(\n                    base_board, s_eval_time_seconds, depth, multipv=1)\n                for best_move in best_moves:\n                    self.consume_move_descriptor(best_move)\n            except Exception as e:\n                print(\"error while analysing position in explorer\")\n                print(e)\n                return\n            self.display(perform_analysis=False)\n            self.log_message(\"position analysed\")\n\n    def set_board(self, board: Board):\n        \"\"\" called by other modules to set the board of this module.\n\n        Args:\n            board (Board): the board to set\n        \"\"\"\n        if not board:\n            return\n        self.reset_board()\n        self.board = board.copy()\n        self.display()\n\n    def display(self, perform_analysis: bool = True, play_sound: bool = False):\n        \"\"\" Displays the current board state. Choose whether to play a sound or not: A sound could represent a move\n        or the start of a game. Sometimes this behaviour is not desired (e.g. when setting the board and displaying\n        it without any prior user interaction).\n\n        Args:\n            perform_analysis (bool, optional): Defaults to True. Whether to perform an analysis of the current position.\n            play_sound (bool, optional): Defaults to False. Whether to play a sound when displaying the board. \n        \"\"\"\n        node = self.tree.get(get_reduced_fen_from_board(self.board))\n        self.chess_board_widget.display(\n            self.board, node, self.previous_node, self.last_move, play_sound=play_sound)\n        if perform_analysis:\n            self.app.threadpool.start(MethodAction(self.analyse_d25))\n\n    def show_fen(self):\n        \"\"\" Shows the fen of the current board state.\n        \"\"\"\n        self.log_message(get_reduced_fen_from_board(self.board))\n\n    def show_known_moves(self):\n        \"\"\" Shows the known moves for the current board state.\n        \"\"\"\n        self.show_fen()\n        node = self.tree.get(get_reduced_fen_from_board(self.board))\n        if node.has_move():\n            for move in node.moves:\n                self.log_message(move.get_info(node))\n        else:\n            self.log_message(\"no moves known for this node\")\n\n    def on_piece_movement(self, piece_movement: PieceMovement):\n        \"\"\" reacts to a user interaction with the board and tries to perform the given move. @see ChessboardAndLogModule.on_piece_movement\n\n        Args:\n            piece_movement (PieceMovement): the move to perform\n        \"\"\"\n        if self.about_to_close():\n            return\n        self.last_move = None\n        self.previous_node = None\n        try:\n            fen = get_reduced_fen_from_board(self.board)\n            node = self.tree.get(fen)\n            san = self.board.san(chess.Move.from_uci(\n                piece_movement.uci_format()))\n            board_copy = Board(fen)\n            board_copy.push_san(san)\n            result = get_reduced_fen_from_board(board_copy)\n            move = chessapp.model.move.Move(\n                self.tree, san, result, source=SourceType.MANUAL_EXPLORATION)\n            if not node.knows_move(move):\n                node.add(move)\n            self.board.push_san(san)\n            self.previous_node = node\n            self.last_move = move\n            self.display(play_sound=True)\n        except Exception as e:\n            print(\"error while exploring\")\n            print(traceback.format_exc())\n\n    def reset_last_move(self):\n        \"\"\" Forgets the last move and previous node and practially makes this module behave as if there was no prior board state.\n        \"\"\"\n        self.last_move = None\n        self.previous_node = None\n\n    def reset_board(self):\n        \"\"\" Resets the board to the initial state.\n        \"\"\"\n        self.board = Board()\n        self.reset_last_move()\n        self.chess_board_widget.reset()\n        self.display()\n\n    def on_close(self):\n        \"\"\" closes the engine. @see ChessboardAndLogModule.on_close\n        \"\"\"\n        self.engine.close()\n</code></pre>"},{"location":"chessapp/controller/gamedownloader/","title":"gamedownloader","text":""},{"location":"chessapp/controller/gamedownloader/#chessapp.controller.gamedownloader.GameDownloader","title":"<code>chessapp.controller.gamedownloader.GameDownloader</code>","text":"<p>             Bases: <code>ChessboardAndLogModule</code></p> Source code in <code>chessapp\\controller\\gamedownloader.py</code> <pre><code>class GameDownloader(ChessboardAndLogModule):\n\n    def __init__(self):\n        super().__init__()\n</code></pre>"},{"location":"chessapp/controller/gamedownloader/#source","title":"Source","text":"<p>```python</p>"},{"location":"chessapp/controller/gamedownloader/#this-enables-the-user-to-login-to-various-chess-websites-like-lichess-and-chesscom-and-also-connect","title":"This enables the user to login to various chess websites (like lichess and chess.com) and also connect","text":""},{"location":"chessapp/controller/gamedownloader/#to-other-open-apis-each-gamesource-has-its-own-chessgamedatabase-associated-with-it-for-easy-access-to-the","title":"to other open apis. Each GameSource has its own ChessGameDatabase associated with it for easy access to the","text":""},{"location":"chessapp/controller/gamedownloader/#games-by-doing-so-a-variety-of-games-are-available-to-the-program-and-therefor-the-user-such-as-their","title":"games. By doing so a variety of games are available to the program and therefor the user such as their","text":""},{"location":"chessapp/controller/gamedownloader/#own-online-games-but-also-master-games-and-master-game-compilations-this-module-has-an-auto-update","title":"own (online) games but also master games and master game compilations. This module has an auto-update","text":""},{"location":"chessapp/controller/gamedownloader/#function-to-make-sure-the-games-of-the-various-sources-are-as-up-to-date-as-possible-each-source-can","title":"function to make sure the games of the various sources are as up to date as possible. Each source can","text":""},{"location":"chessapp/controller/gamedownloader/#be-configured-to-only-retrieve-games-from-a-certain-time-onwards-or-filter-for-certain-players-eg","title":"be configured to only retrieve games from a certain time onwards or filter for certain players (e.g.","text":""},{"location":"chessapp/controller/gamedownloader/#create-databases-that-feature-a-single-players-games-to-make-sure-the-process-is-as-automatic-as","title":"create databases that feature a single players' games). To make sure the process is as automatic as","text":""},{"location":"chessapp/controller/gamedownloader/#possible-authentication-tokens-of-the-user-have-to-be-saved-locally-the-user-should-always-be-able","title":"possible authentication tokens of the user have to be saved locally. The user should always be able","text":""},{"location":"chessapp/controller/gamedownloader/#to-logout-deleting-the-tokens-and-to-login-afterwards","title":"to logout (deleting the tokens) and to login afterwards.","text":"<p>from view.module import ChessboardAndLogModule</p> <p>class GameDownloader(ChessboardAndLogModule):</p> <pre><code>def __init__(self):\n    super().__init__()```\n</code></pre>"},{"location":"chessapp/controller/openingtree/","title":"openingtree","text":""},{"location":"chessapp/controller/openingtree/#chessapp.controller.openingtree.OpeningTree","title":"<code>chessapp.controller.openingtree.OpeningTree</code>","text":"<p>             Bases: <code>LogModule</code></p> <p>the opening tree module is responsible for importing and managing the opening tree that is used in the quiz module</p> Source code in <code>chessapp\\controller\\openingtree.py</code> <pre><code>class OpeningTree(LogModule):\n    \"\"\"the opening tree module is responsible for importing and managing the opening tree that is used in the quiz module\n    \"\"\"\n\n    def __init__(self, app):\n        \"\"\"initializes the opening tree module and imports the opening tree from the source data folder. the only action is import.\n\n        Args:\n            app (ChessApp): the main application\n        \"\"\"\n        super().__init__(app, \"OpeningTree\", [\n            create_method_action(app, \"Import\", self.import_opening_tree)])\n        self.white_opening_tree: ChessTree = ChessTree(\n            s_white_opening_tree_folder_path)\n        self.black_opening_tree: ChessTree = ChessTree(\n            s_black_opening_tree_folder_path)\n        self.app = app\n        self.dispatch_threadpool(self.load)\n\n    def load(self):\n        \"\"\"loads the opening tree from disk (usually once called on startup of the application)\n        \"\"\"\n        self.log_message(\"loading opening tree...\", 60000)\n        self.white_opening_tree.load()\n        self.black_opening_tree.load()\n        self.log_message(\"loading opening done\")\n\n    def import_opening_tree(self):\n        \"\"\"imports the opening tree from the source data folder (this may take a while and should only dispatched on a threadpool)\n        \"\"\"\n        self.log_message(\"importing white opening tree...\")\n        self.white_opening_tree.clear()\n        import_pgn_from_folder_path(self.app, self.white_opening_tree, SourceType.AMATEUR_GAME,\n                                    s_white_source_folder_path, self.about_to_close, True)\n        self.white_opening_tree.save()\n        self.log_message(\"importing white opening tree done\")\n        self.log_message(\"importing black opening tree...\")\n        self.black_opening_tree.clear()\n        import_pgn_from_folder_path(self.app, self.black_opening_tree, SourceType.AMATEUR_GAME,\n                                    s_black_source_folder_path, self.about_to_close, True)\n        self.black_opening_tree.save()\n        self.log_message(\"importing black opening tree done\")\n</code></pre>"},{"location":"chessapp/controller/openingtree/#chessapp.controller.openingtree.OpeningTree.__init__","title":"<code>__init__(app)</code>","text":"<p>initializes the opening tree module and imports the opening tree from the source data folder. the only action is import.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>ChessApp</code> <p>the main application</p> required Source code in <code>chessapp\\controller\\openingtree.py</code> <pre><code>def __init__(self, app):\n    \"\"\"initializes the opening tree module and imports the opening tree from the source data folder. the only action is import.\n\n    Args:\n        app (ChessApp): the main application\n    \"\"\"\n    super().__init__(app, \"OpeningTree\", [\n        create_method_action(app, \"Import\", self.import_opening_tree)])\n    self.white_opening_tree: ChessTree = ChessTree(\n        s_white_opening_tree_folder_path)\n    self.black_opening_tree: ChessTree = ChessTree(\n        s_black_opening_tree_folder_path)\n    self.app = app\n    self.dispatch_threadpool(self.load)\n</code></pre>"},{"location":"chessapp/controller/openingtree/#chessapp.controller.openingtree.OpeningTree.import_opening_tree","title":"<code>import_opening_tree()</code>","text":"<p>imports the opening tree from the source data folder (this may take a while and should only dispatched on a threadpool)</p> Source code in <code>chessapp\\controller\\openingtree.py</code> <pre><code>def import_opening_tree(self):\n    \"\"\"imports the opening tree from the source data folder (this may take a while and should only dispatched on a threadpool)\n    \"\"\"\n    self.log_message(\"importing white opening tree...\")\n    self.white_opening_tree.clear()\n    import_pgn_from_folder_path(self.app, self.white_opening_tree, SourceType.AMATEUR_GAME,\n                                s_white_source_folder_path, self.about_to_close, True)\n    self.white_opening_tree.save()\n    self.log_message(\"importing white opening tree done\")\n    self.log_message(\"importing black opening tree...\")\n    self.black_opening_tree.clear()\n    import_pgn_from_folder_path(self.app, self.black_opening_tree, SourceType.AMATEUR_GAME,\n                                s_black_source_folder_path, self.about_to_close, True)\n    self.black_opening_tree.save()\n    self.log_message(\"importing black opening tree done\")\n</code></pre>"},{"location":"chessapp/controller/openingtree/#chessapp.controller.openingtree.OpeningTree.load","title":"<code>load()</code>","text":"<p>loads the opening tree from disk (usually once called on startup of the application)</p> Source code in <code>chessapp\\controller\\openingtree.py</code> <pre><code>def load(self):\n    \"\"\"loads the opening tree from disk (usually once called on startup of the application)\n    \"\"\"\n    self.log_message(\"loading opening tree...\", 60000)\n    self.white_opening_tree.load()\n    self.black_opening_tree.load()\n    self.log_message(\"loading opening done\")\n</code></pre>"},{"location":"chessapp/controller/openingtree/#source","title":"Source","text":"<pre><code>from chessapp.model.chesstree import ChessTree\nfrom chessapp.view.module import LogModule, create_method_action\nfrom chessapp.controller.updater import import_pgn_from_folder_path\nfrom chessapp.model.sourcetype import SourceType\nfrom chessapp.util.paths import get_opening_tree_folder\nfrom os.path import join\n\ns_source_data_folder_path: str = join(get_opening_tree_folder(), \"source_data\")\ns_white_source_folder_path: str = s_source_data_folder_path + \"/white\"\ns_black_source_folder_path: str = s_source_data_folder_path + \"/black\"\ns_white_opening_tree_folder_path: str = join(\n    get_opening_tree_folder(), \"white\")\ns_black_opening_tree_folder_path: str = join(\n    get_opening_tree_folder(), \"black\")\n\n\nclass OpeningTree(LogModule):\n    \"\"\"the opening tree module is responsible for importing and managing the opening tree that is used in the quiz module\n    \"\"\"\n\n    def __init__(self, app):\n        \"\"\"initializes the opening tree module and imports the opening tree from the source data folder. the only action is import.\n\n        Args:\n            app (ChessApp): the main application\n        \"\"\"\n        super().__init__(app, \"OpeningTree\", [\n            create_method_action(app, \"Import\", self.import_opening_tree)])\n        self.white_opening_tree: ChessTree = ChessTree(\n            s_white_opening_tree_folder_path)\n        self.black_opening_tree: ChessTree = ChessTree(\n            s_black_opening_tree_folder_path)\n        self.app = app\n        self.dispatch_threadpool(self.load)\n\n    def load(self):\n        \"\"\"loads the opening tree from disk (usually once called on startup of the application)\n        \"\"\"\n        self.log_message(\"loading opening tree...\", 60000)\n        self.white_opening_tree.load()\n        self.black_opening_tree.load()\n        self.log_message(\"loading opening done\")\n\n    def import_opening_tree(self):\n        \"\"\"imports the opening tree from the source data folder (this may take a while and should only dispatched on a threadpool)\n        \"\"\"\n        self.log_message(\"importing white opening tree...\")\n        self.white_opening_tree.clear()\n        import_pgn_from_folder_path(self.app, self.white_opening_tree, SourceType.AMATEUR_GAME,\n                                    s_white_source_folder_path, self.about_to_close, True)\n        self.white_opening_tree.save()\n        self.log_message(\"importing white opening tree done\")\n        self.log_message(\"importing black opening tree...\")\n        self.black_opening_tree.clear()\n        import_pgn_from_folder_path(self.app, self.black_opening_tree, SourceType.AMATEUR_GAME,\n                                    s_black_source_folder_path, self.about_to_close, True)\n        self.black_opening_tree.save()\n        self.log_message(\"importing black opening tree done\")\n</code></pre>"},{"location":"chessapp/controller/puzzles/","title":"puzzles","text":""},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.PuzzleNode","title":"<code>chessapp.controller.puzzles.PuzzleNode</code>","text":"<p>a node in a puzzle is a double linked list node with a fen and a san. the san represents the expected  move on a board with the given fen.</p> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>class PuzzleNode:\n    \"\"\" a node in a puzzle is a double linked list node with a fen and a san. the san represents the expected \n    move on a board with the given fen.\n    \"\"\"\n\n    def __init__(self, fen: str, san: str) -&gt; None:\n        \"\"\"initializes a puzzle node. the previous and next nodes are None by default.\n\n        Args:\n            fen (str): fen of the board\n            san (str): move expected to be played by the turn player\n        \"\"\"\n        self.fen: str = fen\n        self.san: str = san\n        self.previous: PuzzleNode = None\n        self.next: PuzzleNode = None\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.PuzzleNode.__init__","title":"<code>__init__(fen, san)</code>","text":"<p>initializes a puzzle node. the previous and next nodes are None by default.</p> <p>Parameters:</p> Name Type Description Default <code>fen</code> <code>str</code> <p>fen of the board</p> required <code>san</code> <code>str</code> <p>move expected to be played by the turn player</p> required Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def __init__(self, fen: str, san: str) -&gt; None:\n    \"\"\"initializes a puzzle node. the previous and next nodes are None by default.\n\n    Args:\n        fen (str): fen of the board\n        san (str): move expected to be played by the turn player\n    \"\"\"\n    self.fen: str = fen\n    self.san: str = san\n    self.previous: PuzzleNode = None\n    self.next: PuzzleNode = None\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzle","title":"<code>chessapp.controller.puzzles.Puzzle</code>","text":"<p>A puzzle is a sequence of moves. The puzzle is represented by a double linked list of puzzle nodes. The last node has a None san. The puzzle is done when the current node has a None san. Use reset to reset the puzzle to its initial state. Use is_done to check if the puzzle is done. Use apply_move to apply a san-move to the puzzle (which is only accepted when it is the expected move of the current node). Use perform_next_move to perform the next move (without specificying the move).</p> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>class Puzzle:\n    \"\"\" A puzzle is a sequence of moves. The puzzle is represented by a double linked list of puzzle nodes. The last node\n    has a None san. The puzzle is done when the current node has a None san. Use reset to reset the puzzle to its initial state. Use\n    is_done to check if the puzzle is done. Use apply_move to apply a san-move to the puzzle (which is only accepted when it is the expected\n    move of the current node). Use perform_next_move to perform the next move (without specificying the move).\n    \"\"\"\n\n    def __init__(self, pgn: str, fen: str, moves: [], about_to_close) -&gt; None:\n        \"\"\" Initializes a puzzle. The pgn is the pgn of the game the puzzle is extracted from. The fen is the fen of the board at the start of the puzzle.\n        moves is a list of moves in san format. about_to_close is a function that returns True if the application is about to close (this is used for\n        the extraction of the lines from the pgn, @see extract_lines in updater.py)\n\n        Args:\n            pgn (str): pgn of the game the puzzle is extracted from\n            fen (str): fen of the board at the start of the puzzle\n            moves ([str]): expected moves in san format\n            about_to_close (() -&gt; bool): function that returns True if the application is about to close \n        \"\"\"\n        self.about_to_close = about_to_close\n        self.pgn: str = pgn\n        self.fen: str = reduce_fen(fen)\n        self.puzzle_nodes = []\n        self.board = Board()\n        self.moves = moves.split(\" \")\n        self.current_node: PuzzleNode = None\n        self.reset()\n\n    def is_done(self) -&gt; bool:\n        \"\"\" checks if the puzzle is done\n\n        Returns:\n            bool: if the puzzle is done\n        \"\"\"\n        return self.current_node.san == None\n\n    def apply_move(self, san: str) -&gt; bool:\n        \"\"\" Checks if the given san is the expected move of the current node. If so, the move is applied to the board and\n        the current node is set to the next node.\n\n        Args:\n            san (str): a san move\n\n        Returns:\n            bool: True if the move was applied, False otherwise\n        \"\"\"\n        if self.current_node.san != san:\n            return False\n        self.board.push_san(san)\n        self.current_node = self.current_node.next\n        return True\n\n    def perform_next_move(self) -&gt; str:\n        \"\"\" Performs the next move (without specifying the move). The move is applied to the board and the current node is set to the next node.\n\n        Returns:\n            str: san of the move performed\n        \"\"\"\n        san: str = self.current_node.san\n        self.board.push_san(self.current_node.san)\n        self.current_node = self.current_node.next\n        return san\n\n    def reset(self):\n        \"\"\" Resets the puzzle to its initial state. The board is set to the fen of the puzzle. The current node is set to the first node of the puzzle.\n        Beware that the first node of the puzzle is not the first node of the double linked list of PuzzleNodes. Instead the first node of the double\n        linked list represents the move that was played just before the board state of the puzzle was reached. This is done to display the last_move arrows\n        on the ChessBoardWidget, @see display in ChessBoardWidget.\n\n        Raises:\n            Exception: if the pgn of the puzzle does not contain exactly one line\n            Exception: if the fen of the puzzle is never reached from the moves in the pgn\n        \"\"\"\n        lines = extract_lines(self.pgn, self.about_to_close)\n        if len(lines) != 1:\n            raise Exception(\n                \"number of lines found in puzzle file is not 1: \" + self.pgn)\n        self.board = Board()\n        for san in lines[0]:\n            if get_reduced_fen_from_board(self.board) == self.fen:\n                break\n            self.board.push_san(san)\n        if get_reduced_fen_from_board(self.board) != self.fen:\n            raise Exception(\"fen \" + self.fen +\n                            \" never reached from moves in pgn \" + self.pgn)\n        first_move = self.board.pop()\n        first_move_san = self.board.san(first_move)\n        base_node = PuzzleNode(get_reduced_fen_from_board(self.board), first_move_san)\n        self.board.push(first_move)\n        self.current_node = base_node\n        copy_board = Board(self.board.fen())\n        for san in self.moves:\n            next_node = PuzzleNode(get_reduced_fen_from_board(copy_board), san)\n            copy_board.push_san(san)\n            self.current_node.next = next_node\n            next_node.previous = self.current_node\n            self.current_node = next_node\n        self.current_node.next = PuzzleNode(\n            get_reduced_fen_from_board(copy_board), None)\n        self.current_node.next.previous = self.current_node\n        self.current_node = base_node.next\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzle.__init__","title":"<code>__init__(pgn, fen, moves, about_to_close)</code>","text":"<p>Initializes a puzzle. The pgn is the pgn of the game the puzzle is extracted from. The fen is the fen of the board at the start of the puzzle. moves is a list of moves in san format. about_to_close is a function that returns True if the application is about to close (this is used for the extraction of the lines from the pgn, @see extract_lines in updater.py)</p> <p>Parameters:</p> Name Type Description Default <code>pgn</code> <code>str</code> <p>pgn of the game the puzzle is extracted from</p> required <code>fen</code> <code>str</code> <p>fen of the board at the start of the puzzle</p> required <code>moves</code> <code>[str]</code> <p>expected moves in san format</p> required <code>about_to_close</code> <code> -&gt; bool</code> <p>function that returns True if the application is about to close</p> required Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def __init__(self, pgn: str, fen: str, moves: [], about_to_close) -&gt; None:\n    \"\"\" Initializes a puzzle. The pgn is the pgn of the game the puzzle is extracted from. The fen is the fen of the board at the start of the puzzle.\n    moves is a list of moves in san format. about_to_close is a function that returns True if the application is about to close (this is used for\n    the extraction of the lines from the pgn, @see extract_lines in updater.py)\n\n    Args:\n        pgn (str): pgn of the game the puzzle is extracted from\n        fen (str): fen of the board at the start of the puzzle\n        moves ([str]): expected moves in san format\n        about_to_close (() -&gt; bool): function that returns True if the application is about to close \n    \"\"\"\n    self.about_to_close = about_to_close\n    self.pgn: str = pgn\n    self.fen: str = reduce_fen(fen)\n    self.puzzle_nodes = []\n    self.board = Board()\n    self.moves = moves.split(\" \")\n    self.current_node: PuzzleNode = None\n    self.reset()\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzle.apply_move","title":"<code>apply_move(san)</code>","text":"<p>Checks if the given san is the expected move of the current node. If so, the move is applied to the board and the current node is set to the next node.</p> <p>Parameters:</p> Name Type Description Default <code>san</code> <code>str</code> <p>a san move</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the move was applied, False otherwise</p> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def apply_move(self, san: str) -&gt; bool:\n    \"\"\" Checks if the given san is the expected move of the current node. If so, the move is applied to the board and\n    the current node is set to the next node.\n\n    Args:\n        san (str): a san move\n\n    Returns:\n        bool: True if the move was applied, False otherwise\n    \"\"\"\n    if self.current_node.san != san:\n        return False\n    self.board.push_san(san)\n    self.current_node = self.current_node.next\n    return True\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzle.is_done","title":"<code>is_done()</code>","text":"<p>checks if the puzzle is done</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if the puzzle is done</p> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def is_done(self) -&gt; bool:\n    \"\"\" checks if the puzzle is done\n\n    Returns:\n        bool: if the puzzle is done\n    \"\"\"\n    return self.current_node.san == None\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzle.perform_next_move","title":"<code>perform_next_move()</code>","text":"<p>Performs the next move (without specifying the move). The move is applied to the board and the current node is set to the next node.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>san of the move performed</p> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def perform_next_move(self) -&gt; str:\n    \"\"\" Performs the next move (without specifying the move). The move is applied to the board and the current node is set to the next node.\n\n    Returns:\n        str: san of the move performed\n    \"\"\"\n    san: str = self.current_node.san\n    self.board.push_san(self.current_node.san)\n    self.current_node = self.current_node.next\n    return san\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzle.reset","title":"<code>reset()</code>","text":"<p>Resets the puzzle to its initial state. The board is set to the fen of the puzzle. The current node is set to the first node of the puzzle. Beware that the first node of the puzzle is not the first node of the double linked list of PuzzleNodes. Instead the first node of the double linked list represents the move that was played just before the board state of the puzzle was reached. This is done to display the last_move arrows on the ChessBoardWidget, @see display in ChessBoardWidget.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if the pgn of the puzzle does not contain exactly one line</p> <code>Exception</code> <p>if the fen of the puzzle is never reached from the moves in the pgn</p> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def reset(self):\n    \"\"\" Resets the puzzle to its initial state. The board is set to the fen of the puzzle. The current node is set to the first node of the puzzle.\n    Beware that the first node of the puzzle is not the first node of the double linked list of PuzzleNodes. Instead the first node of the double\n    linked list represents the move that was played just before the board state of the puzzle was reached. This is done to display the last_move arrows\n    on the ChessBoardWidget, @see display in ChessBoardWidget.\n\n    Raises:\n        Exception: if the pgn of the puzzle does not contain exactly one line\n        Exception: if the fen of the puzzle is never reached from the moves in the pgn\n    \"\"\"\n    lines = extract_lines(self.pgn, self.about_to_close)\n    if len(lines) != 1:\n        raise Exception(\n            \"number of lines found in puzzle file is not 1: \" + self.pgn)\n    self.board = Board()\n    for san in lines[0]:\n        if get_reduced_fen_from_board(self.board) == self.fen:\n            break\n        self.board.push_san(san)\n    if get_reduced_fen_from_board(self.board) != self.fen:\n        raise Exception(\"fen \" + self.fen +\n                        \" never reached from moves in pgn \" + self.pgn)\n    first_move = self.board.pop()\n    first_move_san = self.board.san(first_move)\n    base_node = PuzzleNode(get_reduced_fen_from_board(self.board), first_move_san)\n    self.board.push(first_move)\n    self.current_node = base_node\n    copy_board = Board(self.board.fen())\n    for san in self.moves:\n        next_node = PuzzleNode(get_reduced_fen_from_board(copy_board), san)\n        copy_board.push_san(san)\n        self.current_node.next = next_node\n        next_node.previous = self.current_node\n        self.current_node = next_node\n    self.current_node.next = PuzzleNode(\n        get_reduced_fen_from_board(copy_board), None)\n    self.current_node.next.previous = self.current_node\n    self.current_node = base_node.next\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzles","title":"<code>chessapp.controller.puzzles.Puzzles</code>","text":"<p>             Bases: <code>ChessboardAndLogModule</code></p> <p>The puzzles module allows the user to solve hand-picked puzzles. The puzzles are loaded from the puzzles folder. Add new puzzles by creating a json file in the puzzles folder. The json file must contain a list of puzzles and a pgn. Each puzzle must contain a fen and a list of moves.  The fen is the state of the board at the start of the puzzle. The moves are the moves that must be played to solve the puzzle (the player always has the first move and the oppenents move are automatically played by the application). The pgn is the pgn of the game the puzzle is extracted from.</p> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>class Puzzles(ChessboardAndLogModule):\n    \"\"\" The puzzles module allows the user to solve hand-picked puzzles. The puzzles are loaded from the puzzles folder. Add new puzzles by creating a json file\n    in the puzzles folder. The json file must contain a list of puzzles and a pgn. Each puzzle must contain a fen and a list of moves. \n    The fen is the state of the board at the start of the puzzle. The moves are the moves that must be played to solve the puzzle (the player always has the\n    first move and the oppenents move are automatically played by the application). The pgn is the pgn of the game the puzzle is extracted from.\n    \"\"\"\n\n    def __init__(self, app, explorer: Explorer, tree):\n        \"\"\" initializes the puzzles module with the given explorer and tree. it has the following actions: explore, retry, and start\n\n        Args:\n            app (chessapp.chessapp.Chessapp): the main application\n            explorer (Explorer): the explorer module\n            tree (chessapp.model.chesstree.Chesstree): the tree containing the moves and positions\n        \"\"\"\n        super().__init__(app, \"Puzzles\", [\n            create_method_action(app, \"Explore\", self.explore),\n            create_method_action(app, \"Retry\", self.retry),\n            create_method_action(app, \"Start\", self.start)\n        ])\n        self.is_started = False\n        self.explorer = explorer\n        self.puzzles = []\n        self.current_puzzle: Puzzle = None\n        self.tree = tree\n\n    def on_register(self):\n        \"\"\" @see ChessboardAndLogModule.on_register\n        this method calls load_puzzles in a threadpool\n        \"\"\"\n        super().on_register()\n        self.dispatch_threadpool(self.load_puzzles)\n\n    def load_puzzle(self, file_path: str):\n        \"\"\"loads a puzzle from the given file path\n\n        Args:\n            file_path (str): path to the puzzle file\n        \"\"\"\n        try:\n            with open(file_path, mode=\"r\") as f:\n                data = json.loads(f.read())\n        except:\n            print(\"error while loading puzzle \" + file_path)\n            print(traceback.format_exc())\n            return\n        for puzzle in data[\"puzzles\"]:\n            try:\n                loaded_puzzle = Puzzle(\n                    data[\"pgn\"], puzzle[\"fen\"], puzzle[\"moves\"], self.about_to_close)\n            except:\n                print(\"error while loading puzzle \" +\n                      file_path + \" with fen \" + puzzle[\"fen\"])\n                print(traceback.format_exc())\n                continue\n            self.puzzles.append(loaded_puzzle)\n\n    def load_puzzles(self, folder=get_puzzles_folder()):\n        \"\"\"loads all puzzles from the given folder (and its subfolders). the default folder is the puzzles folder, @see chessapp.util.paths.get_puzzles_folder()\n\n        Args:\n            folder (Path|str, optional): Defaults to get_puzzles_folder(). path to the folder containing the puzzles\n        \"\"\"\n        for name in listdir(folder):\n            path: str = join(folder, name)\n            if isdir(path):\n                self.load_puzzles(path)\n            elif isfile(path) and path.endswith(\".json\"):\n                self.load_puzzle(path)\n\n    def finish_puzzle(self):\n        \"\"\"called when a puzzle is done. prepares the puzzles module for a new puzzle\n        \"\"\"\n        self.log_message(\"puzzle done\")\n        self.is_started = False\n        ChessboardSound.GAME_END.play()\n\n    def apply_next_move(self, is_opponent_move: bool = False):\n        \"\"\" if the puzzle is done, finish_puzzle is called.\n        if the puzzle is not done, the next move is performed and the display is updated. if the puzzle is done after the move is performed,\n        finish_puzzle is called.\n\n        Args:\n            is_opponent_move (bool, optional): Defaults to False. indicates if the move is performed by the opponent (True) or the player (False)\n        \"\"\"\n        if not self.is_started:\n            return\n        if not self.current_puzzle.is_done():\n            sleep(0.5)\n            san: str = self.current_puzzle.perform_next_move()\n            self.log_message(\"opponent played: \" + san)\n            self.display(play_sound=True,\n                         last_move_is_opponent_move=is_opponent_move)\n            if self.current_puzzle.is_done():\n                self.dispatch_threadpool(self.finish_puzzle)\n        else:\n            self.dispatch_threadpool(self.finish_puzzle)\n\n    def on_piece_movement(self, piece_movement: PieceMovement):\n        \"\"\" @see ChessboardAndLogModule.on_piece_movement()\n        if the puzzle is not done, the piece movement (understood as a uci move) is applied to the puzzle (@see Puzzle.apply_move) and the display is updated.\n        if the puzzle is done after the move is applied, finish_puzzle is called. If the wrong move is applied, the log is updated and a sound is played.\n\n        Args:\n            piece_movement (PieceMovement): _description_\n        \"\"\"\n        if not self.is_started:\n            return\n        san: str = self.current_puzzle.board.san(\n            chess.Move.from_uci(piece_movement.uci_format()))\n        if self.current_puzzle.apply_move(san):\n            self.log_message(\"correct move: \" + san)\n            self.display(play_sound=True, last_move_is_opponent_move=False)\n            self.dispatch_threadpool(self.apply_next_move)\n        else:\n            self.log_message(\"wrong move: \" + san)\n            ChessboardSound.RESULT_BAD.play()\n\n    def retry(self):\n        \"\"\"retries the current puzzle if there is one\n        \"\"\"\n        if self.current_puzzle:\n            self.start(keep_puzzle=True)\n        else:\n            self.log_message(\"no puzzle to retry\")\n\n    def start(self, keep_puzzle: bool = False):\n        \"\"\" starts a new puzzle. if keep_puzzle is True and the current puzzle is not None, the current puzzle is kept.\n        otherwise a new puzzle is chosen from the puzzles list. the board is set to the fen of the puzzle. the display is updated. a sound is played.\n        After calling this method the user can interact with the puzzle (and solve it).\n\n        Args:\n            keep_puzzle (bool, optional): Defaults to False. if True, the current puzzle is kept (if possible). if False, a new puzzle is chosen from the puzzles list.\n        \"\"\"\n        if self.is_started:\n            return\n        self.focus()\n        if not self.current_puzzle or not keep_puzzle:\n            self.current_puzzle = choice(self.puzzles)\n        self.current_puzzle.reset()\n        if 'w' in self.current_puzzle.current_node.fen:\n            self.chess_board_widget.view_white()\n        else:\n            self.chess_board_widget.view_black()\n        self.display(play_sound=False, last_move_is_opponent_move=True)\n        ChessboardSound.GAME_START.play()\n        self.is_started = True\n\n    def display(self, play_sound: bool = True, last_move_is_opponent_move: bool = False):\n        \"\"\" displays the current puzzle's board state.\n\n        Args:\n            play_sound (bool, optional): Defaults to True. if True, a sound is played.\n            last_move_is_opponent_move (bool, optional): Defaults to False. if True, the last move is considered to be played by the opponent.\n\n        Raises:\n            Exception: if the current puzzle is None\n            Exception: if the current node of the current puzzle is None\n        \"\"\"\n        previous_node = None\n        if not self.current_puzzle:\n            raise Exception(\"current_puzzle is None\")\n        if not self.current_puzzle.current_node:\n            raise Exception(\"current node is None\")\n        current_fen = get_reduced_fen_from_board(self.current_puzzle.board)\n        last_move = chessapp.model.move.Move(\n            self.tree, self.current_puzzle.current_node.previous.san, current_fen)\n        if self.current_puzzle.current_node.previous:\n            previous_node = self.tree.get(\n                self.current_puzzle.current_node.previous.fen)\n        self.chess_board_widget.display(\n            self.current_puzzle.board,\n            node=self.tree.get(current_fen),\n            previous_node=previous_node,\n            last_move=last_move,\n            show_last_move_icon=False,\n            last_move_is_opponent_move=last_move_is_opponent_move,\n            play_sound=play_sound\n        )\n\n    def explore(self):\n        \"\"\" opens the explorer module and sets the board of the explorer to the board of the current puzzle\n        \"\"\"\n        if self.current_puzzle:\n            self.explorer.set_board(self.current_puzzle.board)\n            self.explorer.focus()\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzles.__init__","title":"<code>__init__(app, explorer, tree)</code>","text":"<p>initializes the puzzles module with the given explorer and tree. it has the following actions: explore, retry, and start</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Chessapp</code> <p>the main application</p> required <code>explorer</code> <code>Explorer</code> <p>the explorer module</p> required <code>tree</code> <code>Chesstree</code> <p>the tree containing the moves and positions</p> required Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def __init__(self, app, explorer: Explorer, tree):\n    \"\"\" initializes the puzzles module with the given explorer and tree. it has the following actions: explore, retry, and start\n\n    Args:\n        app (chessapp.chessapp.Chessapp): the main application\n        explorer (Explorer): the explorer module\n        tree (chessapp.model.chesstree.Chesstree): the tree containing the moves and positions\n    \"\"\"\n    super().__init__(app, \"Puzzles\", [\n        create_method_action(app, \"Explore\", self.explore),\n        create_method_action(app, \"Retry\", self.retry),\n        create_method_action(app, \"Start\", self.start)\n    ])\n    self.is_started = False\n    self.explorer = explorer\n    self.puzzles = []\n    self.current_puzzle: Puzzle = None\n    self.tree = tree\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzles.apply_next_move","title":"<code>apply_next_move(is_opponent_move=False)</code>","text":"<p>if the puzzle is done, finish_puzzle is called. if the puzzle is not done, the next move is performed and the display is updated. if the puzzle is done after the move is performed, finish_puzzle is called.</p> <p>Parameters:</p> Name Type Description Default <code>is_opponent_move</code> <code>bool</code> <p>Defaults to False. indicates if the move is performed by the opponent (True) or the player (False)</p> <code>False</code> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def apply_next_move(self, is_opponent_move: bool = False):\n    \"\"\" if the puzzle is done, finish_puzzle is called.\n    if the puzzle is not done, the next move is performed and the display is updated. if the puzzle is done after the move is performed,\n    finish_puzzle is called.\n\n    Args:\n        is_opponent_move (bool, optional): Defaults to False. indicates if the move is performed by the opponent (True) or the player (False)\n    \"\"\"\n    if not self.is_started:\n        return\n    if not self.current_puzzle.is_done():\n        sleep(0.5)\n        san: str = self.current_puzzle.perform_next_move()\n        self.log_message(\"opponent played: \" + san)\n        self.display(play_sound=True,\n                     last_move_is_opponent_move=is_opponent_move)\n        if self.current_puzzle.is_done():\n            self.dispatch_threadpool(self.finish_puzzle)\n    else:\n        self.dispatch_threadpool(self.finish_puzzle)\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzles.display","title":"<code>display(play_sound=True, last_move_is_opponent_move=False)</code>","text":"<p>displays the current puzzle's board state.</p> <p>Parameters:</p> Name Type Description Default <code>play_sound</code> <code>bool</code> <p>Defaults to True. if True, a sound is played.</p> <code>True</code> <code>last_move_is_opponent_move</code> <code>bool</code> <p>Defaults to False. if True, the last move is considered to be played by the opponent.</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>if the current puzzle is None</p> <code>Exception</code> <p>if the current node of the current puzzle is None</p> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def display(self, play_sound: bool = True, last_move_is_opponent_move: bool = False):\n    \"\"\" displays the current puzzle's board state.\n\n    Args:\n        play_sound (bool, optional): Defaults to True. if True, a sound is played.\n        last_move_is_opponent_move (bool, optional): Defaults to False. if True, the last move is considered to be played by the opponent.\n\n    Raises:\n        Exception: if the current puzzle is None\n        Exception: if the current node of the current puzzle is None\n    \"\"\"\n    previous_node = None\n    if not self.current_puzzle:\n        raise Exception(\"current_puzzle is None\")\n    if not self.current_puzzle.current_node:\n        raise Exception(\"current node is None\")\n    current_fen = get_reduced_fen_from_board(self.current_puzzle.board)\n    last_move = chessapp.model.move.Move(\n        self.tree, self.current_puzzle.current_node.previous.san, current_fen)\n    if self.current_puzzle.current_node.previous:\n        previous_node = self.tree.get(\n            self.current_puzzle.current_node.previous.fen)\n    self.chess_board_widget.display(\n        self.current_puzzle.board,\n        node=self.tree.get(current_fen),\n        previous_node=previous_node,\n        last_move=last_move,\n        show_last_move_icon=False,\n        last_move_is_opponent_move=last_move_is_opponent_move,\n        play_sound=play_sound\n    )\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzles.explore","title":"<code>explore()</code>","text":"<p>opens the explorer module and sets the board of the explorer to the board of the current puzzle</p> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def explore(self):\n    \"\"\" opens the explorer module and sets the board of the explorer to the board of the current puzzle\n    \"\"\"\n    if self.current_puzzle:\n        self.explorer.set_board(self.current_puzzle.board)\n        self.explorer.focus()\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzles.finish_puzzle","title":"<code>finish_puzzle()</code>","text":"<p>called when a puzzle is done. prepares the puzzles module for a new puzzle</p> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def finish_puzzle(self):\n    \"\"\"called when a puzzle is done. prepares the puzzles module for a new puzzle\n    \"\"\"\n    self.log_message(\"puzzle done\")\n    self.is_started = False\n    ChessboardSound.GAME_END.play()\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzles.load_puzzle","title":"<code>load_puzzle(file_path)</code>","text":"<p>loads a puzzle from the given file path</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>path to the puzzle file</p> required Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def load_puzzle(self, file_path: str):\n    \"\"\"loads a puzzle from the given file path\n\n    Args:\n        file_path (str): path to the puzzle file\n    \"\"\"\n    try:\n        with open(file_path, mode=\"r\") as f:\n            data = json.loads(f.read())\n    except:\n        print(\"error while loading puzzle \" + file_path)\n        print(traceback.format_exc())\n        return\n    for puzzle in data[\"puzzles\"]:\n        try:\n            loaded_puzzle = Puzzle(\n                data[\"pgn\"], puzzle[\"fen\"], puzzle[\"moves\"], self.about_to_close)\n        except:\n            print(\"error while loading puzzle \" +\n                  file_path + \" with fen \" + puzzle[\"fen\"])\n            print(traceback.format_exc())\n            continue\n        self.puzzles.append(loaded_puzzle)\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzles.load_puzzles","title":"<code>load_puzzles(folder=get_puzzles_folder())</code>","text":"<p>loads all puzzles from the given folder (and its subfolders). the default folder is the puzzles folder, @see chessapp.util.paths.get_puzzles_folder()</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>Path | str</code> <p>Defaults to get_puzzles_folder(). path to the folder containing the puzzles</p> <code>get_puzzles_folder()</code> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def load_puzzles(self, folder=get_puzzles_folder()):\n    \"\"\"loads all puzzles from the given folder (and its subfolders). the default folder is the puzzles folder, @see chessapp.util.paths.get_puzzles_folder()\n\n    Args:\n        folder (Path|str, optional): Defaults to get_puzzles_folder(). path to the folder containing the puzzles\n    \"\"\"\n    for name in listdir(folder):\n        path: str = join(folder, name)\n        if isdir(path):\n            self.load_puzzles(path)\n        elif isfile(path) and path.endswith(\".json\"):\n            self.load_puzzle(path)\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzles.on_piece_movement","title":"<code>on_piece_movement(piece_movement)</code>","text":"<p>@see ChessboardAndLogModule.on_piece_movement() if the puzzle is not done, the piece movement (understood as a uci move) is applied to the puzzle (@see Puzzle.apply_move) and the display is updated. if the puzzle is done after the move is applied, finish_puzzle is called. If the wrong move is applied, the log is updated and a sound is played.</p> <p>Parameters:</p> Name Type Description Default <code>piece_movement</code> <code>PieceMovement</code> <p>description</p> required Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def on_piece_movement(self, piece_movement: PieceMovement):\n    \"\"\" @see ChessboardAndLogModule.on_piece_movement()\n    if the puzzle is not done, the piece movement (understood as a uci move) is applied to the puzzle (@see Puzzle.apply_move) and the display is updated.\n    if the puzzle is done after the move is applied, finish_puzzle is called. If the wrong move is applied, the log is updated and a sound is played.\n\n    Args:\n        piece_movement (PieceMovement): _description_\n    \"\"\"\n    if not self.is_started:\n        return\n    san: str = self.current_puzzle.board.san(\n        chess.Move.from_uci(piece_movement.uci_format()))\n    if self.current_puzzle.apply_move(san):\n        self.log_message(\"correct move: \" + san)\n        self.display(play_sound=True, last_move_is_opponent_move=False)\n        self.dispatch_threadpool(self.apply_next_move)\n    else:\n        self.log_message(\"wrong move: \" + san)\n        ChessboardSound.RESULT_BAD.play()\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzles.on_register","title":"<code>on_register()</code>","text":"<p>@see ChessboardAndLogModule.on_register this method calls load_puzzles in a threadpool</p> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def on_register(self):\n    \"\"\" @see ChessboardAndLogModule.on_register\n    this method calls load_puzzles in a threadpool\n    \"\"\"\n    super().on_register()\n    self.dispatch_threadpool(self.load_puzzles)\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzles.retry","title":"<code>retry()</code>","text":"<p>retries the current puzzle if there is one</p> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def retry(self):\n    \"\"\"retries the current puzzle if there is one\n    \"\"\"\n    if self.current_puzzle:\n        self.start(keep_puzzle=True)\n    else:\n        self.log_message(\"no puzzle to retry\")\n</code></pre>"},{"location":"chessapp/controller/puzzles/#chessapp.controller.puzzles.Puzzles.start","title":"<code>start(keep_puzzle=False)</code>","text":"<p>starts a new puzzle. if keep_puzzle is True and the current puzzle is not None, the current puzzle is kept. otherwise a new puzzle is chosen from the puzzles list. the board is set to the fen of the puzzle. the display is updated. a sound is played. After calling this method the user can interact with the puzzle (and solve it).</p> <p>Parameters:</p> Name Type Description Default <code>keep_puzzle</code> <code>bool</code> <p>Defaults to False. if True, the current puzzle is kept (if possible). if False, a new puzzle is chosen from the puzzles list.</p> <code>False</code> Source code in <code>chessapp\\controller\\puzzles.py</code> <pre><code>def start(self, keep_puzzle: bool = False):\n    \"\"\" starts a new puzzle. if keep_puzzle is True and the current puzzle is not None, the current puzzle is kept.\n    otherwise a new puzzle is chosen from the puzzles list. the board is set to the fen of the puzzle. the display is updated. a sound is played.\n    After calling this method the user can interact with the puzzle (and solve it).\n\n    Args:\n        keep_puzzle (bool, optional): Defaults to False. if True, the current puzzle is kept (if possible). if False, a new puzzle is chosen from the puzzles list.\n    \"\"\"\n    if self.is_started:\n        return\n    self.focus()\n    if not self.current_puzzle or not keep_puzzle:\n        self.current_puzzle = choice(self.puzzles)\n    self.current_puzzle.reset()\n    if 'w' in self.current_puzzle.current_node.fen:\n        self.chess_board_widget.view_white()\n    else:\n        self.chess_board_widget.view_black()\n    self.display(play_sound=False, last_move_is_opponent_move=True)\n    ChessboardSound.GAME_START.play()\n    self.is_started = True\n</code></pre>"},{"location":"chessapp/controller/puzzles/#source","title":"Source","text":"<pre><code>from os.path import isdir, isfile, join\nfrom os import listdir\nfrom chessapp.view.module import ChessboardAndLogModule, create_method_action\nfrom chessapp.controller.explorer import Explorer\nfrom chessapp.model.chesstree import get_reduced_fen_from_board\nfrom chess import Board\nfrom chessapp.view.chessboardwidget import PieceMovement\nimport json\nfrom chessapp.controller.updater import extract_lines\nfrom chessapp.util.fen import get_reduced_fen_from_board, reduce_fen\nfrom chessapp.util.paths import get_puzzles_folder\nfrom random import choice\nimport traceback\nimport chessapp.model.move\nimport chess\nfrom time import sleep\nfrom chessapp.sound.chessboardsound import ChessboardSound\n\n\nclass PuzzleNode:\n    \"\"\" a node in a puzzle is a double linked list node with a fen and a san. the san represents the expected \n    move on a board with the given fen.\n    \"\"\"\n\n    def __init__(self, fen: str, san: str) -&gt; None:\n        \"\"\"initializes a puzzle node. the previous and next nodes are None by default.\n\n        Args:\n            fen (str): fen of the board\n            san (str): move expected to be played by the turn player\n        \"\"\"\n        self.fen: str = fen\n        self.san: str = san\n        self.previous: PuzzleNode = None\n        self.next: PuzzleNode = None\n\n\nclass Puzzle:\n    \"\"\" A puzzle is a sequence of moves. The puzzle is represented by a double linked list of puzzle nodes. The last node\n    has a None san. The puzzle is done when the current node has a None san. Use reset to reset the puzzle to its initial state. Use\n    is_done to check if the puzzle is done. Use apply_move to apply a san-move to the puzzle (which is only accepted when it is the expected\n    move of the current node). Use perform_next_move to perform the next move (without specificying the move).\n    \"\"\"\n\n    def __init__(self, pgn: str, fen: str, moves: [], about_to_close) -&gt; None:\n        \"\"\" Initializes a puzzle. The pgn is the pgn of the game the puzzle is extracted from. The fen is the fen of the board at the start of the puzzle.\n        moves is a list of moves in san format. about_to_close is a function that returns True if the application is about to close (this is used for\n        the extraction of the lines from the pgn, @see extract_lines in updater.py)\n\n        Args:\n            pgn (str): pgn of the game the puzzle is extracted from\n            fen (str): fen of the board at the start of the puzzle\n            moves ([str]): expected moves in san format\n            about_to_close (() -&gt; bool): function that returns True if the application is about to close \n        \"\"\"\n        self.about_to_close = about_to_close\n        self.pgn: str = pgn\n        self.fen: str = reduce_fen(fen)\n        self.puzzle_nodes = []\n        self.board = Board()\n        self.moves = moves.split(\" \")\n        self.current_node: PuzzleNode = None\n        self.reset()\n\n    def is_done(self) -&gt; bool:\n        \"\"\" checks if the puzzle is done\n\n        Returns:\n            bool: if the puzzle is done\n        \"\"\"\n        return self.current_node.san == None\n\n    def apply_move(self, san: str) -&gt; bool:\n        \"\"\" Checks if the given san is the expected move of the current node. If so, the move is applied to the board and\n        the current node is set to the next node.\n\n        Args:\n            san (str): a san move\n\n        Returns:\n            bool: True if the move was applied, False otherwise\n        \"\"\"\n        if self.current_node.san != san:\n            return False\n        self.board.push_san(san)\n        self.current_node = self.current_node.next\n        return True\n\n    def perform_next_move(self) -&gt; str:\n        \"\"\" Performs the next move (without specifying the move). The move is applied to the board and the current node is set to the next node.\n\n        Returns:\n            str: san of the move performed\n        \"\"\"\n        san: str = self.current_node.san\n        self.board.push_san(self.current_node.san)\n        self.current_node = self.current_node.next\n        return san\n\n    def reset(self):\n        \"\"\" Resets the puzzle to its initial state. The board is set to the fen of the puzzle. The current node is set to the first node of the puzzle.\n        Beware that the first node of the puzzle is not the first node of the double linked list of PuzzleNodes. Instead the first node of the double\n        linked list represents the move that was played just before the board state of the puzzle was reached. This is done to display the last_move arrows\n        on the ChessBoardWidget, @see display in ChessBoardWidget.\n\n        Raises:\n            Exception: if the pgn of the puzzle does not contain exactly one line\n            Exception: if the fen of the puzzle is never reached from the moves in the pgn\n        \"\"\"\n        lines = extract_lines(self.pgn, self.about_to_close)\n        if len(lines) != 1:\n            raise Exception(\n                \"number of lines found in puzzle file is not 1: \" + self.pgn)\n        self.board = Board()\n        for san in lines[0]:\n            if get_reduced_fen_from_board(self.board) == self.fen:\n                break\n            self.board.push_san(san)\n        if get_reduced_fen_from_board(self.board) != self.fen:\n            raise Exception(\"fen \" + self.fen +\n                            \" never reached from moves in pgn \" + self.pgn)\n        first_move = self.board.pop()\n        first_move_san = self.board.san(first_move)\n        base_node = PuzzleNode(get_reduced_fen_from_board(self.board), first_move_san)\n        self.board.push(first_move)\n        self.current_node = base_node\n        copy_board = Board(self.board.fen())\n        for san in self.moves:\n            next_node = PuzzleNode(get_reduced_fen_from_board(copy_board), san)\n            copy_board.push_san(san)\n            self.current_node.next = next_node\n            next_node.previous = self.current_node\n            self.current_node = next_node\n        self.current_node.next = PuzzleNode(\n            get_reduced_fen_from_board(copy_board), None)\n        self.current_node.next.previous = self.current_node\n        self.current_node = base_node.next\n\n\nclass Puzzles(ChessboardAndLogModule):\n    \"\"\" The puzzles module allows the user to solve hand-picked puzzles. The puzzles are loaded from the puzzles folder. Add new puzzles by creating a json file\n    in the puzzles folder. The json file must contain a list of puzzles and a pgn. Each puzzle must contain a fen and a list of moves. \n    The fen is the state of the board at the start of the puzzle. The moves are the moves that must be played to solve the puzzle (the player always has the\n    first move and the oppenents move are automatically played by the application). The pgn is the pgn of the game the puzzle is extracted from.\n    \"\"\"\n\n    def __init__(self, app, explorer: Explorer, tree):\n        \"\"\" initializes the puzzles module with the given explorer and tree. it has the following actions: explore, retry, and start\n\n        Args:\n            app (chessapp.chessapp.Chessapp): the main application\n            explorer (Explorer): the explorer module\n            tree (chessapp.model.chesstree.Chesstree): the tree containing the moves and positions\n        \"\"\"\n        super().__init__(app, \"Puzzles\", [\n            create_method_action(app, \"Explore\", self.explore),\n            create_method_action(app, \"Retry\", self.retry),\n            create_method_action(app, \"Start\", self.start)\n        ])\n        self.is_started = False\n        self.explorer = explorer\n        self.puzzles = []\n        self.current_puzzle: Puzzle = None\n        self.tree = tree\n\n    def on_register(self):\n        \"\"\" @see ChessboardAndLogModule.on_register\n        this method calls load_puzzles in a threadpool\n        \"\"\"\n        super().on_register()\n        self.dispatch_threadpool(self.load_puzzles)\n\n    def load_puzzle(self, file_path: str):\n        \"\"\"loads a puzzle from the given file path\n\n        Args:\n            file_path (str): path to the puzzle file\n        \"\"\"\n        try:\n            with open(file_path, mode=\"r\") as f:\n                data = json.loads(f.read())\n        except:\n            print(\"error while loading puzzle \" + file_path)\n            print(traceback.format_exc())\n            return\n        for puzzle in data[\"puzzles\"]:\n            try:\n                loaded_puzzle = Puzzle(\n                    data[\"pgn\"], puzzle[\"fen\"], puzzle[\"moves\"], self.about_to_close)\n            except:\n                print(\"error while loading puzzle \" +\n                      file_path + \" with fen \" + puzzle[\"fen\"])\n                print(traceback.format_exc())\n                continue\n            self.puzzles.append(loaded_puzzle)\n\n    def load_puzzles(self, folder=get_puzzles_folder()):\n        \"\"\"loads all puzzles from the given folder (and its subfolders). the default folder is the puzzles folder, @see chessapp.util.paths.get_puzzles_folder()\n\n        Args:\n            folder (Path|str, optional): Defaults to get_puzzles_folder(). path to the folder containing the puzzles\n        \"\"\"\n        for name in listdir(folder):\n            path: str = join(folder, name)\n            if isdir(path):\n                self.load_puzzles(path)\n            elif isfile(path) and path.endswith(\".json\"):\n                self.load_puzzle(path)\n\n    def finish_puzzle(self):\n        \"\"\"called when a puzzle is done. prepares the puzzles module for a new puzzle\n        \"\"\"\n        self.log_message(\"puzzle done\")\n        self.is_started = False\n        ChessboardSound.GAME_END.play()\n\n    def apply_next_move(self, is_opponent_move: bool = False):\n        \"\"\" if the puzzle is done, finish_puzzle is called.\n        if the puzzle is not done, the next move is performed and the display is updated. if the puzzle is done after the move is performed,\n        finish_puzzle is called.\n\n        Args:\n            is_opponent_move (bool, optional): Defaults to False. indicates if the move is performed by the opponent (True) or the player (False)\n        \"\"\"\n        if not self.is_started:\n            return\n        if not self.current_puzzle.is_done():\n            sleep(0.5)\n            san: str = self.current_puzzle.perform_next_move()\n            self.log_message(\"opponent played: \" + san)\n            self.display(play_sound=True,\n                         last_move_is_opponent_move=is_opponent_move)\n            if self.current_puzzle.is_done():\n                self.dispatch_threadpool(self.finish_puzzle)\n        else:\n            self.dispatch_threadpool(self.finish_puzzle)\n\n    def on_piece_movement(self, piece_movement: PieceMovement):\n        \"\"\" @see ChessboardAndLogModule.on_piece_movement()\n        if the puzzle is not done, the piece movement (understood as a uci move) is applied to the puzzle (@see Puzzle.apply_move) and the display is updated.\n        if the puzzle is done after the move is applied, finish_puzzle is called. If the wrong move is applied, the log is updated and a sound is played.\n\n        Args:\n            piece_movement (PieceMovement): _description_\n        \"\"\"\n        if not self.is_started:\n            return\n        san: str = self.current_puzzle.board.san(\n            chess.Move.from_uci(piece_movement.uci_format()))\n        if self.current_puzzle.apply_move(san):\n            self.log_message(\"correct move: \" + san)\n            self.display(play_sound=True, last_move_is_opponent_move=False)\n            self.dispatch_threadpool(self.apply_next_move)\n        else:\n            self.log_message(\"wrong move: \" + san)\n            ChessboardSound.RESULT_BAD.play()\n\n    def retry(self):\n        \"\"\"retries the current puzzle if there is one\n        \"\"\"\n        if self.current_puzzle:\n            self.start(keep_puzzle=True)\n        else:\n            self.log_message(\"no puzzle to retry\")\n\n    def start(self, keep_puzzle: bool = False):\n        \"\"\" starts a new puzzle. if keep_puzzle is True and the current puzzle is not None, the current puzzle is kept.\n        otherwise a new puzzle is chosen from the puzzles list. the board is set to the fen of the puzzle. the display is updated. a sound is played.\n        After calling this method the user can interact with the puzzle (and solve it).\n\n        Args:\n            keep_puzzle (bool, optional): Defaults to False. if True, the current puzzle is kept (if possible). if False, a new puzzle is chosen from the puzzles list.\n        \"\"\"\n        if self.is_started:\n            return\n        self.focus()\n        if not self.current_puzzle or not keep_puzzle:\n            self.current_puzzle = choice(self.puzzles)\n        self.current_puzzle.reset()\n        if 'w' in self.current_puzzle.current_node.fen:\n            self.chess_board_widget.view_white()\n        else:\n            self.chess_board_widget.view_black()\n        self.display(play_sound=False, last_move_is_opponent_move=True)\n        ChessboardSound.GAME_START.play()\n        self.is_started = True\n\n    def display(self, play_sound: bool = True, last_move_is_opponent_move: bool = False):\n        \"\"\" displays the current puzzle's board state.\n\n        Args:\n            play_sound (bool, optional): Defaults to True. if True, a sound is played.\n            last_move_is_opponent_move (bool, optional): Defaults to False. if True, the last move is considered to be played by the opponent.\n\n        Raises:\n            Exception: if the current puzzle is None\n            Exception: if the current node of the current puzzle is None\n        \"\"\"\n        previous_node = None\n        if not self.current_puzzle:\n            raise Exception(\"current_puzzle is None\")\n        if not self.current_puzzle.current_node:\n            raise Exception(\"current node is None\")\n        current_fen = get_reduced_fen_from_board(self.current_puzzle.board)\n        last_move = chessapp.model.move.Move(\n            self.tree, self.current_puzzle.current_node.previous.san, current_fen)\n        if self.current_puzzle.current_node.previous:\n            previous_node = self.tree.get(\n                self.current_puzzle.current_node.previous.fen)\n        self.chess_board_widget.display(\n            self.current_puzzle.board,\n            node=self.tree.get(current_fen),\n            previous_node=previous_node,\n            last_move=last_move,\n            show_last_move_icon=False,\n            last_move_is_opponent_move=last_move_is_opponent_move,\n            play_sound=play_sound\n        )\n\n    def explore(self):\n        \"\"\" opens the explorer module and sets the board of the explorer to the board of the current puzzle\n        \"\"\"\n        if self.current_puzzle:\n            self.explorer.set_board(self.current_puzzle.board)\n            self.explorer.focus()\n</code></pre>"},{"location":"chessapp/controller/quiz/","title":"quiz","text":""},{"location":"chessapp/controller/quiz/#chessapp.controller.quiz.Quiz","title":"<code>chessapp.controller.quiz.Quiz</code>","text":"<p>             Bases: <code>ChessboardAndLogModule</code></p> <p>this module is an interactive quiz in which the player has to find acceptable moves (given by the position evaluations) for given positions. usually the opening tree of the opening tree module (@see chessapp.controller.OpeningTree) is used to find opponent moves played with a probability that is in proportion to the statistical occurence of that move given the specific players the opening tree is based on. if no move is known for the given position in the opening tree then a random move is chosen from the tree that is given during module initialization. the quiz ends when a no more moves are known for a certain positon.</p> Source code in <code>chessapp\\controller\\quiz.py</code> <pre><code>class Quiz(ChessboardAndLogModule):\n    \"\"\" this module is an interactive quiz in which the player has to find acceptable moves (given by the position evaluations) for given positions.\n    usually the opening tree of the opening tree module (@see chessapp.controller.OpeningTree) is used to find opponent moves played with a\n    probability that is in proportion to the statistical occurence of that move given the specific players the opening tree is based on. if no move\n    is known for the given position in the opening tree then a random move is chosen from the tree that is given during module initialization.\n    the quiz ends when a no more moves are known for a certain positon.\n    \"\"\"\n\n    def __init__(self, app, tree: ChessTree, opening_tree: OpeningTree, explorer: Explorer):\n        \"\"\"initializes the quiz module. the actions are start, reset and explore. explore opens the explorer module (@see chessapp.controller.Explorer)\n        and sets the board to the current position. start starts the quiz. reset resets the board to the starting position.\n\n        Args:\n            app (ChessApp): the main application\n            tree (ChessTree): the tree to use for the quiz\n            opening_tree (OpeningTree): the opening tree to use for the quiz\n            explorer (Explorer): the explorer module\n        \"\"\"\n        super().__init__(app, \"Quiz\", [create_method_action(app, \"Start\", self.start), create_method_action(\n            app, \"Reset\", self.reset), create_method_action(app, \"Explore\", self.explore)])\n        self.tree: ChessTree = tree\n        self.explorer = explorer\n        self.player_turn: bool = False\n        self.quiz_started: bool = False\n        self.opponent_color: str = \"\"\n        self.board: Board = None\n        self.moves_played = []\n        self.opening_tree = opening_tree\n        random.seed()\n\n    def apply_movement(self, piece_movement: PieceMovement):\n        \"\"\" this method is called when the user makes a move on the chessboard. it checks if the move is acceptable and if so applies it to the board. \n        if the move is acceptable it will call apply_opponent_move to apply the opponents move. if the move is not acceptable it will log a message.\n        also if the move is unknown it will be added to the opening tree (and can be explored later).\n\n        Args:\n            piece_movement (PieceMovement): the movement to apply\n\n        Raises:\n            Exception: if this method is called during an opponents move\n        \"\"\"\n        if not self.quiz_started:\n            return\n        if not self.player_turn:\n            raise Exception(\n                \"this method can only be called during the players turn\")\n        fen = get_reduced_fen_from_board(self.board)\n        node = self.tree.get(fen)\n        san = self.board.san(chess.Move.from_uci(piece_movement.uci_format()))\n        move = node.get_move_by_san(san)\n        if not move:\n            self.log_message(\"unable to find move \" + san +\n                             \". adding it to the opening chess tree.\")\n            ChessboardSound.RESULT_BAD.play()\n            copy_board = Board(fen=fen)\n            copy_board.push_san(san)\n            self.moves_played.append(san)\n            node.add(Move(self.tree, san, get_reduced_fen_from_board(\n                copy_board), source=SourceType.QUIZ_EXPLORATION))\n            return\n        cp_loss = node.get_cp_loss(move)\n        if not node.is_acceptable_move(move):\n            self.log_message(\n                \"this move is not acceptable. CP loss = \" + str(cp_loss))\n            ChessboardSound.RESULT_BAD.play()\n            return\n        else:\n            self.log_message(\n                \"good move. CP loss = \" + str(cp_loss))\n        self.board.push_san(san)\n        previous_node = node\n        node = self.tree.get(get_reduced_fen_from_board(self.board))\n        self.chess_board_widget.display(\n            self.board, last_move=move, previous_node=previous_node, node=node, play_sound=True)\n        self.player_turn = False\n        self.apply_opponent_move()\n\n    def apply_opponent_move(self):\n        \"\"\" this method is called when the opponent makes a move. it will choose a move from the opening tree (if known) by proportion of known moves\n        or a random move otherwise (known by the given tree). if there is no more move known then the quiz stops.\n\n        Raises:\n            Exception: if this method is called during the players turn\n        \"\"\"\n        if not self.quiz_started:\n            return\n        if self.player_turn:\n            raise Exception(\n                \"this method can only be called during the opponents turn\")\n        time.sleep(0.7)\n        fen = get_reduced_fen_from_board(self.board)\n        node = self.tree.get(fen)\n        if not node.has_move():\n            black_node = self.opening_tree.black_opening_tree.get(fen)\n            white_node = self.opening_tree.white_opening_tree.get(fen)\n            if black_node.has_move():\n                node = black_node\n            elif white_node.has_move():\n                node = white_node\n            else:\n                self.finish_quiz(node, \"no moves for opponent known\")\n                return\n        op_tree = self.opening_tree.black_opening_tree\n        if self.opponent_color == \"black\":\n            op_tree = self.opening_tree.white_opening_tree\n        op_node = op_tree.get(node.state)\n        move = None\n        if op_node.has_frequency():\n            move = op_node.random_move(random, True)\n        else:\n            move = node.random_move(random)\n        self.moves_played.append(move.san)\n        self.board.push_san(move.san)\n        self.player_turn = True\n        previous_node = node\n        node = self.tree.get(get_reduced_fen_from_board(self.board))\n        self.chess_board_widget.display(\n            self.board, last_move=move, previous_node=previous_node, node=node, show_last_move_icon=False, last_move_is_opponent_move=True, play_sound=True)\n        if not node.has_acceptable_move():\n            self.finish_quiz(\n                node, \"opponent moved, no more acceptable moves for player known\")\n\n    def finish_quiz(self, node: Node, reason: str):\n        \"\"\" this method is called when the quiz is finished. it will log the reason of termination, the moves played and the moves left in the node (if any).\n\n        Args:\n            node (Node): the node that that was reached when the quiz was finished\n            reason (str): the reason why the quiz was finished\n\n        Raises:\n            Exception: if the quiz has not been started yet\n        \"\"\"\n        if not self.quiz_started:\n            raise Exception(\"cannot finish quiz that has not been started yet\")\n        self.log_message(\"quiz finished with reason: \" + reason)\n        self.log_message(\"line played: \" +\n                         moves_to_pgn(self.moves_played, True))\n        if node.has_move():\n            moves = []\n            for move in node.moves:\n                moves.append(str(move.san) +\n                             \" (\" + str(node.get_cp_loss(move)) + \")\")\n            self.log_message(\"moves left in node \" +\n                             node.state + \": \" + \", \".join(moves))\n        self.quiz_started = False\n        ChessboardSound.GAME_END.play()\n\n    def on_piece_movement(self, piece_movement: PieceMovement):\n        \"\"\" this method is called when the user makes a move on the chessboard. it will dispatch apply_movement for this piece movement on the\n        threadpool of the main application (because this method is called from the gui thread and apply_movement may take some time to complete).\n\n        Args:\n            piece_movement (PieceMovement): the movement to apply\n        \"\"\"\n        if not self.about_to_close():\n            self.app.threadpool.start(QuizMovementAction(self, piece_movement))\n\n    def reset(self):\n        \"\"\" this method resets the board to the starting position and resets the quiz state.\n        \"\"\"\n        self.quiz_started = False\n        self.board = Board()\n        self.chess_board_widget.display(self.board)\n\n    def explore(self):\n        \"\"\" opens the explorer module and sets the board of the explorer to the board of the quiz.\n        \"\"\"\n        self.explorer.focus()\n        self.explorer.set_board(self.board)\n\n    def start(self):\n        \"\"\" this method starts the quiz. it will randomly choose a color for the player and displays the board from the perspective of the player.\n        \"\"\"\n        if self.quiz_started:\n            return\n        self.focus()\n        self.player_turn = random.randint(0, 1) % 2 == 0\n        self.opponent_color = \"white\"\n        self.chess_board_widget.view_black()\n        if self.player_turn:\n            self.opponent_color = \"black\"\n            self.chess_board_widget.view_white()\n        self.board = Board()\n        self.chess_board_widget.display(self.board)\n        self.moves_played = []\n        self.quiz_started = True\n        ChessboardSound.GAME_START.play()\n        if not self.player_turn:\n            self.apply_opponent_move()\n</code></pre>"},{"location":"chessapp/controller/quiz/#chessapp.controller.quiz.Quiz.__init__","title":"<code>__init__(app, tree, opening_tree, explorer)</code>","text":"<p>initializes the quiz module. the actions are start, reset and explore. explore opens the explorer module (@see chessapp.controller.Explorer) and sets the board to the current position. start starts the quiz. reset resets the board to the starting position.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>ChessApp</code> <p>the main application</p> required <code>tree</code> <code>ChessTree</code> <p>the tree to use for the quiz</p> required <code>opening_tree</code> <code>OpeningTree</code> <p>the opening tree to use for the quiz</p> required <code>explorer</code> <code>Explorer</code> <p>the explorer module</p> required Source code in <code>chessapp\\controller\\quiz.py</code> <pre><code>def __init__(self, app, tree: ChessTree, opening_tree: OpeningTree, explorer: Explorer):\n    \"\"\"initializes the quiz module. the actions are start, reset and explore. explore opens the explorer module (@see chessapp.controller.Explorer)\n    and sets the board to the current position. start starts the quiz. reset resets the board to the starting position.\n\n    Args:\n        app (ChessApp): the main application\n        tree (ChessTree): the tree to use for the quiz\n        opening_tree (OpeningTree): the opening tree to use for the quiz\n        explorer (Explorer): the explorer module\n    \"\"\"\n    super().__init__(app, \"Quiz\", [create_method_action(app, \"Start\", self.start), create_method_action(\n        app, \"Reset\", self.reset), create_method_action(app, \"Explore\", self.explore)])\n    self.tree: ChessTree = tree\n    self.explorer = explorer\n    self.player_turn: bool = False\n    self.quiz_started: bool = False\n    self.opponent_color: str = \"\"\n    self.board: Board = None\n    self.moves_played = []\n    self.opening_tree = opening_tree\n    random.seed()\n</code></pre>"},{"location":"chessapp/controller/quiz/#chessapp.controller.quiz.Quiz.apply_movement","title":"<code>apply_movement(piece_movement)</code>","text":"<p>this method is called when the user makes a move on the chessboard. it checks if the move is acceptable and if so applies it to the board.  if the move is acceptable it will call apply_opponent_move to apply the opponents move. if the move is not acceptable it will log a message. also if the move is unknown it will be added to the opening tree (and can be explored later).</p> <p>Parameters:</p> Name Type Description Default <code>piece_movement</code> <code>PieceMovement</code> <p>the movement to apply</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if this method is called during an opponents move</p> Source code in <code>chessapp\\controller\\quiz.py</code> <pre><code>def apply_movement(self, piece_movement: PieceMovement):\n    \"\"\" this method is called when the user makes a move on the chessboard. it checks if the move is acceptable and if so applies it to the board. \n    if the move is acceptable it will call apply_opponent_move to apply the opponents move. if the move is not acceptable it will log a message.\n    also if the move is unknown it will be added to the opening tree (and can be explored later).\n\n    Args:\n        piece_movement (PieceMovement): the movement to apply\n\n    Raises:\n        Exception: if this method is called during an opponents move\n    \"\"\"\n    if not self.quiz_started:\n        return\n    if not self.player_turn:\n        raise Exception(\n            \"this method can only be called during the players turn\")\n    fen = get_reduced_fen_from_board(self.board)\n    node = self.tree.get(fen)\n    san = self.board.san(chess.Move.from_uci(piece_movement.uci_format()))\n    move = node.get_move_by_san(san)\n    if not move:\n        self.log_message(\"unable to find move \" + san +\n                         \". adding it to the opening chess tree.\")\n        ChessboardSound.RESULT_BAD.play()\n        copy_board = Board(fen=fen)\n        copy_board.push_san(san)\n        self.moves_played.append(san)\n        node.add(Move(self.tree, san, get_reduced_fen_from_board(\n            copy_board), source=SourceType.QUIZ_EXPLORATION))\n        return\n    cp_loss = node.get_cp_loss(move)\n    if not node.is_acceptable_move(move):\n        self.log_message(\n            \"this move is not acceptable. CP loss = \" + str(cp_loss))\n        ChessboardSound.RESULT_BAD.play()\n        return\n    else:\n        self.log_message(\n            \"good move. CP loss = \" + str(cp_loss))\n    self.board.push_san(san)\n    previous_node = node\n    node = self.tree.get(get_reduced_fen_from_board(self.board))\n    self.chess_board_widget.display(\n        self.board, last_move=move, previous_node=previous_node, node=node, play_sound=True)\n    self.player_turn = False\n    self.apply_opponent_move()\n</code></pre>"},{"location":"chessapp/controller/quiz/#chessapp.controller.quiz.Quiz.apply_opponent_move","title":"<code>apply_opponent_move()</code>","text":"<p>this method is called when the opponent makes a move. it will choose a move from the opening tree (if known) by proportion of known moves or a random move otherwise (known by the given tree). if there is no more move known then the quiz stops.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if this method is called during the players turn</p> Source code in <code>chessapp\\controller\\quiz.py</code> <pre><code>def apply_opponent_move(self):\n    \"\"\" this method is called when the opponent makes a move. it will choose a move from the opening tree (if known) by proportion of known moves\n    or a random move otherwise (known by the given tree). if there is no more move known then the quiz stops.\n\n    Raises:\n        Exception: if this method is called during the players turn\n    \"\"\"\n    if not self.quiz_started:\n        return\n    if self.player_turn:\n        raise Exception(\n            \"this method can only be called during the opponents turn\")\n    time.sleep(0.7)\n    fen = get_reduced_fen_from_board(self.board)\n    node = self.tree.get(fen)\n    if not node.has_move():\n        black_node = self.opening_tree.black_opening_tree.get(fen)\n        white_node = self.opening_tree.white_opening_tree.get(fen)\n        if black_node.has_move():\n            node = black_node\n        elif white_node.has_move():\n            node = white_node\n        else:\n            self.finish_quiz(node, \"no moves for opponent known\")\n            return\n    op_tree = self.opening_tree.black_opening_tree\n    if self.opponent_color == \"black\":\n        op_tree = self.opening_tree.white_opening_tree\n    op_node = op_tree.get(node.state)\n    move = None\n    if op_node.has_frequency():\n        move = op_node.random_move(random, True)\n    else:\n        move = node.random_move(random)\n    self.moves_played.append(move.san)\n    self.board.push_san(move.san)\n    self.player_turn = True\n    previous_node = node\n    node = self.tree.get(get_reduced_fen_from_board(self.board))\n    self.chess_board_widget.display(\n        self.board, last_move=move, previous_node=previous_node, node=node, show_last_move_icon=False, last_move_is_opponent_move=True, play_sound=True)\n    if not node.has_acceptable_move():\n        self.finish_quiz(\n            node, \"opponent moved, no more acceptable moves for player known\")\n</code></pre>"},{"location":"chessapp/controller/quiz/#chessapp.controller.quiz.Quiz.explore","title":"<code>explore()</code>","text":"<p>opens the explorer module and sets the board of the explorer to the board of the quiz.</p> Source code in <code>chessapp\\controller\\quiz.py</code> <pre><code>def explore(self):\n    \"\"\" opens the explorer module and sets the board of the explorer to the board of the quiz.\n    \"\"\"\n    self.explorer.focus()\n    self.explorer.set_board(self.board)\n</code></pre>"},{"location":"chessapp/controller/quiz/#chessapp.controller.quiz.Quiz.finish_quiz","title":"<code>finish_quiz(node, reason)</code>","text":"<p>this method is called when the quiz is finished. it will log the reason of termination, the moves played and the moves left in the node (if any).</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>the node that that was reached when the quiz was finished</p> required <code>reason</code> <code>str</code> <p>the reason why the quiz was finished</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if the quiz has not been started yet</p> Source code in <code>chessapp\\controller\\quiz.py</code> <pre><code>def finish_quiz(self, node: Node, reason: str):\n    \"\"\" this method is called when the quiz is finished. it will log the reason of termination, the moves played and the moves left in the node (if any).\n\n    Args:\n        node (Node): the node that that was reached when the quiz was finished\n        reason (str): the reason why the quiz was finished\n\n    Raises:\n        Exception: if the quiz has not been started yet\n    \"\"\"\n    if not self.quiz_started:\n        raise Exception(\"cannot finish quiz that has not been started yet\")\n    self.log_message(\"quiz finished with reason: \" + reason)\n    self.log_message(\"line played: \" +\n                     moves_to_pgn(self.moves_played, True))\n    if node.has_move():\n        moves = []\n        for move in node.moves:\n            moves.append(str(move.san) +\n                         \" (\" + str(node.get_cp_loss(move)) + \")\")\n        self.log_message(\"moves left in node \" +\n                         node.state + \": \" + \", \".join(moves))\n    self.quiz_started = False\n    ChessboardSound.GAME_END.play()\n</code></pre>"},{"location":"chessapp/controller/quiz/#chessapp.controller.quiz.Quiz.on_piece_movement","title":"<code>on_piece_movement(piece_movement)</code>","text":"<p>this method is called when the user makes a move on the chessboard. it will dispatch apply_movement for this piece movement on the threadpool of the main application (because this method is called from the gui thread and apply_movement may take some time to complete).</p> <p>Parameters:</p> Name Type Description Default <code>piece_movement</code> <code>PieceMovement</code> <p>the movement to apply</p> required Source code in <code>chessapp\\controller\\quiz.py</code> <pre><code>def on_piece_movement(self, piece_movement: PieceMovement):\n    \"\"\" this method is called when the user makes a move on the chessboard. it will dispatch apply_movement for this piece movement on the\n    threadpool of the main application (because this method is called from the gui thread and apply_movement may take some time to complete).\n\n    Args:\n        piece_movement (PieceMovement): the movement to apply\n    \"\"\"\n    if not self.about_to_close():\n        self.app.threadpool.start(QuizMovementAction(self, piece_movement))\n</code></pre>"},{"location":"chessapp/controller/quiz/#chessapp.controller.quiz.Quiz.reset","title":"<code>reset()</code>","text":"<p>this method resets the board to the starting position and resets the quiz state.</p> Source code in <code>chessapp\\controller\\quiz.py</code> <pre><code>def reset(self):\n    \"\"\" this method resets the board to the starting position and resets the quiz state.\n    \"\"\"\n    self.quiz_started = False\n    self.board = Board()\n    self.chess_board_widget.display(self.board)\n</code></pre>"},{"location":"chessapp/controller/quiz/#chessapp.controller.quiz.Quiz.start","title":"<code>start()</code>","text":"<p>this method starts the quiz. it will randomly choose a color for the player and displays the board from the perspective of the player.</p> Source code in <code>chessapp\\controller\\quiz.py</code> <pre><code>def start(self):\n    \"\"\" this method starts the quiz. it will randomly choose a color for the player and displays the board from the perspective of the player.\n    \"\"\"\n    if self.quiz_started:\n        return\n    self.focus()\n    self.player_turn = random.randint(0, 1) % 2 == 0\n    self.opponent_color = \"white\"\n    self.chess_board_widget.view_black()\n    if self.player_turn:\n        self.opponent_color = \"black\"\n        self.chess_board_widget.view_white()\n    self.board = Board()\n    self.chess_board_widget.display(self.board)\n    self.moves_played = []\n    self.quiz_started = True\n    ChessboardSound.GAME_START.play()\n    if not self.player_turn:\n        self.apply_opponent_move()\n</code></pre>"},{"location":"chessapp/controller/quiz/#chessapp.controller.quiz.QuizMovementAction","title":"<code>chessapp.controller.quiz.QuizMovementAction</code>","text":"<p>             Bases: <code>QRunnable</code></p> <p>this class is a runnable that is used to apply a piece movement to the quiz (@see on_piece_movement). it is used to run apply_movement on the threadpool of the main application.</p> Source code in <code>chessapp\\controller\\quiz.py</code> <pre><code>class QuizMovementAction(QRunnable):\n    \"\"\" this class is a runnable that is used to apply a piece movement to the quiz (@see on_piece_movement). it is used to run apply_movement\n    on the threadpool of the main application.\n    \"\"\"\n\n    def __init__(self, quiz: Quiz, piece_movement: PieceMovement):\n        \"\"\"initializes the runnable\n\n        Args:\n            quiz (Quiz): the quiz to apply the movement to\n            piece_movement (PieceMovement): the movement to apply\n        \"\"\"\n        super().__init__()\n        self.quiz = quiz\n        self.piece_movement = piece_movement\n\n    def run(self):\n        \"\"\" applies the movement to the quiz\n        \"\"\"\n        self.quiz.apply_movement(self.piece_movement)\n</code></pre>"},{"location":"chessapp/controller/quiz/#chessapp.controller.quiz.QuizMovementAction.__init__","title":"<code>__init__(quiz, piece_movement)</code>","text":"<p>initializes the runnable</p> <p>Parameters:</p> Name Type Description Default <code>quiz</code> <code>Quiz</code> <p>the quiz to apply the movement to</p> required <code>piece_movement</code> <code>PieceMovement</code> <p>the movement to apply</p> required Source code in <code>chessapp\\controller\\quiz.py</code> <pre><code>def __init__(self, quiz: Quiz, piece_movement: PieceMovement):\n    \"\"\"initializes the runnable\n\n    Args:\n        quiz (Quiz): the quiz to apply the movement to\n        piece_movement (PieceMovement): the movement to apply\n    \"\"\"\n    super().__init__()\n    self.quiz = quiz\n    self.piece_movement = piece_movement\n</code></pre>"},{"location":"chessapp/controller/quiz/#chessapp.controller.quiz.QuizMovementAction.run","title":"<code>run()</code>","text":"<p>applies the movement to the quiz</p> Source code in <code>chessapp\\controller\\quiz.py</code> <pre><code>def run(self):\n    \"\"\" applies the movement to the quiz\n    \"\"\"\n    self.quiz.apply_movement(self.piece_movement)\n</code></pre>"},{"location":"chessapp/controller/quiz/#source","title":"Source","text":"<pre><code>import random\nfrom PyQt5.QtCore import QRunnable\nfrom chess import Board\nfrom chessapp.model.chesstree import ChessTree\nfrom chessapp.view.chessboardwidget import PieceMovement\nimport time\nimport chess\nfrom chessapp.model.move import Move\nfrom chessapp.model.sourcetype import SourceType\nfrom chessapp.view.module import ChessboardAndLogModule, create_method_action\nfrom chessapp.controller.openingtree import OpeningTree\nfrom chessapp.controller.explorer import Explorer\nfrom chessapp.model.node import Node\nfrom chessapp.sound.chessboardsound import ChessboardSound\nfrom chessapp.util.pgn import moves_to_pgn\nfrom chessapp.util.fen import get_reduced_fen_from_board\n\ns_starting_position = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -\"\n\n\nclass Quiz(ChessboardAndLogModule):\n    \"\"\" this module is an interactive quiz in which the player has to find acceptable moves (given by the position evaluations) for given positions.\n    usually the opening tree of the opening tree module (@see chessapp.controller.OpeningTree) is used to find opponent moves played with a\n    probability that is in proportion to the statistical occurence of that move given the specific players the opening tree is based on. if no move\n    is known for the given position in the opening tree then a random move is chosen from the tree that is given during module initialization.\n    the quiz ends when a no more moves are known for a certain positon.\n    \"\"\"\n\n    def __init__(self, app, tree: ChessTree, opening_tree: OpeningTree, explorer: Explorer):\n        \"\"\"initializes the quiz module. the actions are start, reset and explore. explore opens the explorer module (@see chessapp.controller.Explorer)\n        and sets the board to the current position. start starts the quiz. reset resets the board to the starting position.\n\n        Args:\n            app (ChessApp): the main application\n            tree (ChessTree): the tree to use for the quiz\n            opening_tree (OpeningTree): the opening tree to use for the quiz\n            explorer (Explorer): the explorer module\n        \"\"\"\n        super().__init__(app, \"Quiz\", [create_method_action(app, \"Start\", self.start), create_method_action(\n            app, \"Reset\", self.reset), create_method_action(app, \"Explore\", self.explore)])\n        self.tree: ChessTree = tree\n        self.explorer = explorer\n        self.player_turn: bool = False\n        self.quiz_started: bool = False\n        self.opponent_color: str = \"\"\n        self.board: Board = None\n        self.moves_played = []\n        self.opening_tree = opening_tree\n        random.seed()\n\n    def apply_movement(self, piece_movement: PieceMovement):\n        \"\"\" this method is called when the user makes a move on the chessboard. it checks if the move is acceptable and if so applies it to the board. \n        if the move is acceptable it will call apply_opponent_move to apply the opponents move. if the move is not acceptable it will log a message.\n        also if the move is unknown it will be added to the opening tree (and can be explored later).\n\n        Args:\n            piece_movement (PieceMovement): the movement to apply\n\n        Raises:\n            Exception: if this method is called during an opponents move\n        \"\"\"\n        if not self.quiz_started:\n            return\n        if not self.player_turn:\n            raise Exception(\n                \"this method can only be called during the players turn\")\n        fen = get_reduced_fen_from_board(self.board)\n        node = self.tree.get(fen)\n        san = self.board.san(chess.Move.from_uci(piece_movement.uci_format()))\n        move = node.get_move_by_san(san)\n        if not move:\n            self.log_message(\"unable to find move \" + san +\n                             \". adding it to the opening chess tree.\")\n            ChessboardSound.RESULT_BAD.play()\n            copy_board = Board(fen=fen)\n            copy_board.push_san(san)\n            self.moves_played.append(san)\n            node.add(Move(self.tree, san, get_reduced_fen_from_board(\n                copy_board), source=SourceType.QUIZ_EXPLORATION))\n            return\n        cp_loss = node.get_cp_loss(move)\n        if not node.is_acceptable_move(move):\n            self.log_message(\n                \"this move is not acceptable. CP loss = \" + str(cp_loss))\n            ChessboardSound.RESULT_BAD.play()\n            return\n        else:\n            self.log_message(\n                \"good move. CP loss = \" + str(cp_loss))\n        self.board.push_san(san)\n        previous_node = node\n        node = self.tree.get(get_reduced_fen_from_board(self.board))\n        self.chess_board_widget.display(\n            self.board, last_move=move, previous_node=previous_node, node=node, play_sound=True)\n        self.player_turn = False\n        self.apply_opponent_move()\n\n    def apply_opponent_move(self):\n        \"\"\" this method is called when the opponent makes a move. it will choose a move from the opening tree (if known) by proportion of known moves\n        or a random move otherwise (known by the given tree). if there is no more move known then the quiz stops.\n\n        Raises:\n            Exception: if this method is called during the players turn\n        \"\"\"\n        if not self.quiz_started:\n            return\n        if self.player_turn:\n            raise Exception(\n                \"this method can only be called during the opponents turn\")\n        time.sleep(0.7)\n        fen = get_reduced_fen_from_board(self.board)\n        node = self.tree.get(fen)\n        if not node.has_move():\n            black_node = self.opening_tree.black_opening_tree.get(fen)\n            white_node = self.opening_tree.white_opening_tree.get(fen)\n            if black_node.has_move():\n                node = black_node\n            elif white_node.has_move():\n                node = white_node\n            else:\n                self.finish_quiz(node, \"no moves for opponent known\")\n                return\n        op_tree = self.opening_tree.black_opening_tree\n        if self.opponent_color == \"black\":\n            op_tree = self.opening_tree.white_opening_tree\n        op_node = op_tree.get(node.state)\n        move = None\n        if op_node.has_frequency():\n            move = op_node.random_move(random, True)\n        else:\n            move = node.random_move(random)\n        self.moves_played.append(move.san)\n        self.board.push_san(move.san)\n        self.player_turn = True\n        previous_node = node\n        node = self.tree.get(get_reduced_fen_from_board(self.board))\n        self.chess_board_widget.display(\n            self.board, last_move=move, previous_node=previous_node, node=node, show_last_move_icon=False, last_move_is_opponent_move=True, play_sound=True)\n        if not node.has_acceptable_move():\n            self.finish_quiz(\n                node, \"opponent moved, no more acceptable moves for player known\")\n\n    def finish_quiz(self, node: Node, reason: str):\n        \"\"\" this method is called when the quiz is finished. it will log the reason of termination, the moves played and the moves left in the node (if any).\n\n        Args:\n            node (Node): the node that that was reached when the quiz was finished\n            reason (str): the reason why the quiz was finished\n\n        Raises:\n            Exception: if the quiz has not been started yet\n        \"\"\"\n        if not self.quiz_started:\n            raise Exception(\"cannot finish quiz that has not been started yet\")\n        self.log_message(\"quiz finished with reason: \" + reason)\n        self.log_message(\"line played: \" +\n                         moves_to_pgn(self.moves_played, True))\n        if node.has_move():\n            moves = []\n            for move in node.moves:\n                moves.append(str(move.san) +\n                             \" (\" + str(node.get_cp_loss(move)) + \")\")\n            self.log_message(\"moves left in node \" +\n                             node.state + \": \" + \", \".join(moves))\n        self.quiz_started = False\n        ChessboardSound.GAME_END.play()\n\n    def on_piece_movement(self, piece_movement: PieceMovement):\n        \"\"\" this method is called when the user makes a move on the chessboard. it will dispatch apply_movement for this piece movement on the\n        threadpool of the main application (because this method is called from the gui thread and apply_movement may take some time to complete).\n\n        Args:\n            piece_movement (PieceMovement): the movement to apply\n        \"\"\"\n        if not self.about_to_close():\n            self.app.threadpool.start(QuizMovementAction(self, piece_movement))\n\n    def reset(self):\n        \"\"\" this method resets the board to the starting position and resets the quiz state.\n        \"\"\"\n        self.quiz_started = False\n        self.board = Board()\n        self.chess_board_widget.display(self.board)\n\n    def explore(self):\n        \"\"\" opens the explorer module and sets the board of the explorer to the board of the quiz.\n        \"\"\"\n        self.explorer.focus()\n        self.explorer.set_board(self.board)\n\n    def start(self):\n        \"\"\" this method starts the quiz. it will randomly choose a color for the player and displays the board from the perspective of the player.\n        \"\"\"\n        if self.quiz_started:\n            return\n        self.focus()\n        self.player_turn = random.randint(0, 1) % 2 == 0\n        self.opponent_color = \"white\"\n        self.chess_board_widget.view_black()\n        if self.player_turn:\n            self.opponent_color = \"black\"\n            self.chess_board_widget.view_white()\n        self.board = Board()\n        self.chess_board_widget.display(self.board)\n        self.moves_played = []\n        self.quiz_started = True\n        ChessboardSound.GAME_START.play()\n        if not self.player_turn:\n            self.apply_opponent_move()\n\n\nclass QuizMovementAction(QRunnable):\n    \"\"\" this class is a runnable that is used to apply a piece movement to the quiz (@see on_piece_movement). it is used to run apply_movement\n    on the threadpool of the main application.\n    \"\"\"\n\n    def __init__(self, quiz: Quiz, piece_movement: PieceMovement):\n        \"\"\"initializes the runnable\n\n        Args:\n            quiz (Quiz): the quiz to apply the movement to\n            piece_movement (PieceMovement): the movement to apply\n        \"\"\"\n        super().__init__()\n        self.quiz = quiz\n        self.piece_movement = piece_movement\n\n    def run(self):\n        \"\"\" applies the movement to the quiz\n        \"\"\"\n        self.quiz.apply_movement(self.piece_movement)\n</code></pre>"},{"location":"chessapp/controller/saver/","title":"saver","text":""},{"location":"chessapp/controller/saver/#chessapp.controller.saver.Saver","title":"<code>chessapp.controller.saver.Saver</code>","text":"<p>             Bases: <code>LogModule</code></p> <p>the saver module is responsible for saving the tree to disk</p> Source code in <code>chessapp\\controller\\saver.py</code> <pre><code>class Saver(LogModule):\n    \"\"\"the saver module is responsible for saving the tree to disk\n    \"\"\"\n\n    def __init__(self, app, tree: ChessTree):\n        \"\"\" initialises the saver with the given app and tree. the saver has one action: save.\n\n        Args:\n            app (Chessapp): the main application\n            tree (ChessTree): the tree to save\n        \"\"\"\n        super().__init__(app, \"Saver\", [\n            create_method_action(app, \"Save\", self.save)])\n        self.tree: ChessTree = tree\n        self.app = app\n\n    def save(self):\n        \"\"\"saves the tree to disk\n        \"\"\"\n        self.log_message(\"saving...\")\n        self.tree.save()\n        self.log_message(\"saving done\")\n</code></pre>"},{"location":"chessapp/controller/saver/#chessapp.controller.saver.Saver.__init__","title":"<code>__init__(app, tree)</code>","text":"<p>initialises the saver with the given app and tree. the saver has one action: save.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Chessapp</code> <p>the main application</p> required <code>tree</code> <code>ChessTree</code> <p>the tree to save</p> required Source code in <code>chessapp\\controller\\saver.py</code> <pre><code>def __init__(self, app, tree: ChessTree):\n    \"\"\" initialises the saver with the given app and tree. the saver has one action: save.\n\n    Args:\n        app (Chessapp): the main application\n        tree (ChessTree): the tree to save\n    \"\"\"\n    super().__init__(app, \"Saver\", [\n        create_method_action(app, \"Save\", self.save)])\n    self.tree: ChessTree = tree\n    self.app = app\n</code></pre>"},{"location":"chessapp/controller/saver/#chessapp.controller.saver.Saver.save","title":"<code>save()</code>","text":"<p>saves the tree to disk</p> Source code in <code>chessapp\\controller\\saver.py</code> <pre><code>def save(self):\n    \"\"\"saves the tree to disk\n    \"\"\"\n    self.log_message(\"saving...\")\n    self.tree.save()\n    self.log_message(\"saving done\")\n</code></pre>"},{"location":"chessapp/controller/saver/#source","title":"Source","text":"<pre><code>from chessapp.model.chesstree import ChessTree\nfrom chessapp.view.module import LogModule, create_method_action\n\n\nclass Saver(LogModule):\n    \"\"\"the saver module is responsible for saving the tree to disk\n    \"\"\"\n\n    def __init__(self, app, tree: ChessTree):\n        \"\"\" initialises the saver with the given app and tree. the saver has one action: save.\n\n        Args:\n            app (Chessapp): the main application\n            tree (ChessTree): the tree to save\n        \"\"\"\n        super().__init__(app, \"Saver\", [\n            create_method_action(app, \"Save\", self.save)])\n        self.tree: ChessTree = tree\n        self.app = app\n\n    def save(self):\n        \"\"\"saves the tree to disk\n        \"\"\"\n        self.log_message(\"saving...\")\n        self.tree.save()\n        self.log_message(\"saving done\")\n</code></pre>"},{"location":"chessapp/controller/updater/","title":"updater","text":""},{"location":"chessapp/controller/updater/#chessapp.controller.updater.Updater","title":"<code>chessapp.controller.updater.Updater</code>","text":"<p>             Bases: <code>LogModule</code></p> <p>Update the ChessTree from the sources folder.</p> Source code in <code>chessapp\\controller\\updater.py</code> <pre><code>class Updater(LogModule):\n    \"\"\" Update the ChessTree from the sources folder.\n    \"\"\"\n\n    def __init__(self, app, tree: ChessTree):\n        \"\"\" initialize the Updater with the action \"Update Openings\" which updates the ChessTree from the sources folder.\n\n        Args:\n            app (ChessApp): the main application\n            tree (ChessTree): the ChessTree to update\n        \"\"\"\n        super().__init__(app, \"Update\", [create_method_action(\n            app, \"Update Openings\", self.update_openings)])\n        self.tree = tree\n        self.app = app\n\n    def update_openings(self):\n        \"\"\" update the ChessTree from the sources folder.\n        \"\"\"\n        self.log_message(\"updating...\")\n        for key in SourceType._member_map_:\n            path = join(get_openings_folder(), \"sources\", key)\n            Path(path).mkdir(parents=True, exist_ok=True)\n            import_pgn_from_folder_path(self.app, self.tree, SourceType.from_str(\n                key), path, self.about_to_close, False)\n        self.log_message(\"updating done\")\n</code></pre>"},{"location":"chessapp/controller/updater/#chessapp.controller.updater.Updater.__init__","title":"<code>__init__(app, tree)</code>","text":"<p>initialize the Updater with the action \"Update Openings\" which updates the ChessTree from the sources folder.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>ChessApp</code> <p>the main application</p> required <code>tree</code> <code>ChessTree</code> <p>the ChessTree to update</p> required Source code in <code>chessapp\\controller\\updater.py</code> <pre><code>def __init__(self, app, tree: ChessTree):\n    \"\"\" initialize the Updater with the action \"Update Openings\" which updates the ChessTree from the sources folder.\n\n    Args:\n        app (ChessApp): the main application\n        tree (ChessTree): the ChessTree to update\n    \"\"\"\n    super().__init__(app, \"Update\", [create_method_action(\n        app, \"Update Openings\", self.update_openings)])\n    self.tree = tree\n    self.app = app\n</code></pre>"},{"location":"chessapp/controller/updater/#chessapp.controller.updater.Updater.update_openings","title":"<code>update_openings()</code>","text":"<p>update the ChessTree from the sources folder.</p> Source code in <code>chessapp\\controller\\updater.py</code> <pre><code>def update_openings(self):\n    \"\"\" update the ChessTree from the sources folder.\n    \"\"\"\n    self.log_message(\"updating...\")\n    for key in SourceType._member_map_:\n        path = join(get_openings_folder(), \"sources\", key)\n        Path(path).mkdir(parents=True, exist_ok=True)\n        import_pgn_from_folder_path(self.app, self.tree, SourceType.from_str(\n            key), path, self.about_to_close, False)\n    self.log_message(\"updating done\")\n</code></pre>"},{"location":"chessapp/controller/updater/#source","title":"Source","text":"<pre><code>from chessapp.model.chesstree import ChessTree\nfrom chessapp.model.sourcetype import SourceType\nfrom pathlib import Path\nfrom chess import Board, IllegalMoveError\nfrom chess.pgn import read_game\nimport io\nfrom chessapp.model.move import Move\nfrom chessapp.view.module import LogModule, create_method_action\nfrom os.path import join, isfile, isdir\nfrom chessapp.util.paths import get_openings_folder\nfrom chessapp.model.node import Node\nfrom os import listdir\nfrom chessapp.util.fen import get_reduced_fen_from_board\n\n\nclass Updater(LogModule):\n    \"\"\" Update the ChessTree from the sources folder.\n    \"\"\"\n\n    def __init__(self, app, tree: ChessTree):\n        \"\"\" initialize the Updater with the action \"Update Openings\" which updates the ChessTree from the sources folder.\n\n        Args:\n            app (ChessApp): the main application\n            tree (ChessTree): the ChessTree to update\n        \"\"\"\n        super().__init__(app, \"Update\", [create_method_action(\n            app, \"Update Openings\", self.update_openings)])\n        self.tree = tree\n        self.app = app\n\n    def update_openings(self):\n        \"\"\" update the ChessTree from the sources folder.\n        \"\"\"\n        self.log_message(\"updating...\")\n        for key in SourceType._member_map_:\n            path = join(get_openings_folder(), \"sources\", key)\n            Path(path).mkdir(parents=True, exist_ok=True)\n            import_pgn_from_folder_path(self.app, self.tree, SourceType.from_str(\n                key), path, self.about_to_close, False)\n        self.log_message(\"updating done\")\n\n\ndef import_from_file(app, tree: ChessTree, file_path: str | Path, source: SourceType, about_to_close, count_frequency: bool = False):\n    \"\"\"import lines from a pgn file into the ChessTree\n\n\n    Args:\n        app (ChessApp): the main apllication\n        tree (ChessTree): the ChessTree to import into\n        file_path (str | Path): the path to the pgn file\n        source (SourceType): the source of the moves\n        about_to_close (callable): callable that returns True if the module closes\n        count_frequency (bool, optional): Defaults to False. if True, the frequency of the moves will be counted\n    \"\"\"\n    app.show_status_message(\n        \"importing pgn from file \\\"\" + file_path + \"\\\"\")\n    pgn = \"\"\n    with open(file_path, \"r\", encoding=\"utf-8\") as file:\n        pgn = file.read()\n    import_pgn(app, tree, pgn, source, about_to_close, count_frequency)\n\n\ndef import_pgn_from_folder_path(app, tree, source: SourceType, folder_path: str, about_to_close, count_frequency: bool = False):\n    \"\"\"import all .pgn files from a folder into the ChessTree\n\n    Args:\n        app (ChessApp): the main application\n        tree (ChessTree): the ChessTree to import into\n        source (SourceType): the source of the moves\n        folder_path (str): the path to the folder\n        about_to_close (_type_): callable that returns True if the module closes\n        count_frequency (bool, optional): Defaults to False. if True, the frequency of the moves will be counted\n    \"\"\"\n    for name in listdir(folder_path):\n        path: str = join(folder_path, name)\n        if isdir(path):\n            import_pgn_from_folder_path(\n                app, tree, source, path, about_to_close, count_frequency)\n        elif isfile(path) and path.endswith(\".pgn\"):\n            import_from_file(app, tree, path, source,\n                             about_to_close, count_frequency)\n\n\ndef import_pgn(app, tree: ChessTree, pgn: str, source: SourceType, about_to_close, count_frequency: bool = False):\n    \"\"\" import a pgn string into the ChessTree\n\n    Args:\n        app (ChessApp): the main application\n        tree (ChessTree): the ChessTree to import into\n        pgn (str): the pgn string\n        source (SourceType): the source of the moves\n        about_to_close (_type_): callable that returns True if the module closes\n        count_frequency (bool, optional): Defaults to False. if True, the frequency of the moves will be counted\n    \"\"\"\n    lines = extract_lines(pgn, about_to_close)\n    for line in lines:\n        app.show_status_message(\"found line: \" + str(line))\n        board = Board()\n        for san in line:\n            fen = get_reduced_fen_from_board(board)\n            tree.assure(fen)\n            try:\n                board.push_san(san)\n            except IllegalMoveError:\n                print(\n                    \"cannot perform board.push_san(san) because an illegal move was performed\")\n                return\n            move = Move(tree, san, get_reduced_fen_from_board(\n                board), source=source)\n            equivalent_move = tree.get(fen).get_equivalent_move(move)\n            if equivalent_move == None:\n                tree.get(fen).add(move)\n                equivalent_move = move\n            elif equivalent_move.source.value &lt; source.value:\n                equivalent_move.source = source\n            if count_frequency:\n                equivalent_move.frequency += 1\n        fen = get_reduced_fen_from_board(board)\n        tree.assure(fen)\n\n\ndef extract_lines_from_node(base_line: list[str], board: Board, node: Node, about_to_close):\n    \"\"\" extract all lines from a node\n\n    Args:\n        base_line (list[str]): the base line is a list of moves that was played before to reach this specific board state\n        board (Board): the board having the specific board state and all the desired variations\n        node (Node): the node that represents the board state\n        about_to_close (callable): callable that returns True if the module closes\n\n    Returns:\n        list[list[str]]: list of lines (variations) of chess moves extracted from the board\n    \"\"\"\n    move_line: list[str] = base_line.copy()\n    move_line.append(board.san(node.move))\n    if len(node.variations) == 0:\n        return [move_line]\n    board.push(node.move)\n    lines = []\n    for n in node.variations:\n        if about_to_close():\n            break\n        for line in extract_lines_from_node(move_line, board, n, about_to_close):\n            if about_to_close():\n                break\n            lines.append(line)\n    board.pop()\n    return lines\n\n\ndef extract_lines(pgn: str, about_to_close):\n    \"\"\" extract all lines from a pgn string\n\n    Args:\n        pgn (str): the pgn string\n        about_to_close (callable): callable that returns True if the module closes\n\n    Returns:\n        list[list[str]]: list of lines (variations) of chess moves extracted from the pgn string\n    \"\"\"\n    input_str = io.StringIO(pgn)\n    game = read_game(input_str)\n    lines = []\n    while game != None and not about_to_close():\n        for node in game.variations:\n            for line in extract_lines_from_node([], Board(), node, about_to_close):\n                lines.append(line)\n        game = read_game(input_str)\n    return lines\n</code></pre>"},{"location":"chessapp/model/","title":"Model","text":"<p>The model saves, loads, encapsulates the data of the app and provides meaningful interfaces to the data.</p>"},{"location":"chessapp/model/chesstree/","title":"chesstree","text":""},{"location":"chessapp/model/chesstree/#chessapp.model.chesstree.ChessTree","title":"<code>chessapp.model.chesstree.ChessTree</code>","text":"<p>ChessTree is a graph (not actually a tree but commonly referred to as a tree). It is the main data structure of the application. Each node represents a position and each move of a node represents an arc in the graph.</p> <p>This datastructure is saved to and loaded from two csv files: position_eval.csv and moves.csv. The position_eval.csv contains the evaluation of each position and the moves.csv contains the known moves of each position. Both files are located in the save_folder_path folder. The position_eval.csv contains the following columns:</p> <ul> <li>fen: the fen of the position</li> <li>eval: the evaluation of the position</li> <li>eval_depth: the depth of the evaluation</li> <li>is_mate: whether the position is a mate position or not</li> </ul> <p>The moves.csv contains the following columns:</p> <ul> <li>fen: the fen of the position</li> <li>move: the move in san notation</li> <li>comment: the comment of the move (optional)</li> <li>SourceType: the source of the move (@see chessapp.model.sourcetype.SourceType)</li> <li>frequency: the frequency of the move (how often it was played in the database)</li> <li>result fen: the fen of the resulting position after the move is played</li> </ul> Source code in <code>chessapp\\model\\chesstree.py</code> <pre><code>class ChessTree:\n    \"\"\" ChessTree is a graph (not actually a tree but commonly referred to as a tree). It is the main data structure of the application.\n    Each node represents a position and each move of a node represents an arc in the graph.\n\n    This datastructure is saved to and loaded from two csv files: position_eval.csv and moves.csv. The position_eval.csv contains the\n    evaluation of each position and the moves.csv contains the known moves of each position. Both files are located in the save_folder_path\n    folder. The position_eval.csv contains the following columns:\\n\n    - fen: the fen of the position\n    - eval: the evaluation of the position\n    - eval_depth: the depth of the evaluation\n    - is_mate: whether the position is a mate position or not\\n\n    The moves.csv contains the following columns:\\n\n    - fen: the fen of the position\n    - move: the move in san notation\n    - comment: the comment of the move (optional)\n    - SourceType: the source of the move (@see chessapp.model.sourcetype.SourceType)\n    - frequency: the frequency of the move (how often it was played in the database)\n    - result fen: the fen of the resulting position after the move is played\n    \"\"\"\n\n    def __init__(self, save_folder_path: str):\n        \"\"\" Creates a new ChessTree. The save_folder_path is the path where the tree will be saved to/loaded from if the corresponding\n        files exist.\n\n        Args:\n            save_folder_path (str): _description_\n        \"\"\"\n        self.nodes = {}\n        self.save_folder_path = save_folder_path\n        self.position_eval_file_name = \"position_eval.csv\"\n        self.moves_file_name = \"moves.csv\"\n\n    def clear(self) -&gt; None:\n        \"\"\" \"forgets\" all nodes\n        \"\"\"\n        self.nodes = {}\n\n    def get(self, fen: str) -&gt; Node:\n        \"\"\" Returns the node with the given fen. If the node does not exist, it is created.\n\n        Args:\n            fen (str): the fen\n\n        Returns:\n            Node: node with the given fen\n        \"\"\"\n        self.assure(fen)\n        return self.nodes[fen]\n\n    def assure(self, fen: str) -&gt; None:\n        \"\"\" Creates a node with the given fen if it does not exist.\n\n        Args:\n            fen (str): the fen\n        \"\"\"\n        if not fen in self.nodes:\n            self.nodes[fen] = Node(self, fen)\n\n    def position_evaluation_file_path(self) -&gt; str:\n        \"\"\"\n        Returns:\n            str: the path of the position_eval.csv file\n        \"\"\"\n        return self.save_folder_path + \"/\" + self.position_eval_file_name\n\n    def moves_file_path(self) -&gt; str:\n        \"\"\"\n        Returns:\n            str: the path of the moves.csv file\n        \"\"\"\n        return self.save_folder_path + \"/\" + self.moves_file_name\n\n    def load_position_evaluation(self, encoding: str):\n        \"\"\" Loads the position_eval.csv file and creates the corresponding nodes.\n\n        Args:\n            encoding (str): the encoding of the file\n        \"\"\"\n        assure_file(self.position_evaluation_file_path())\n        with open(self.position_evaluation_file_path(), \"r\", encoding=encoding) as f:\n            # fen; eval; eval_depth; is_mate\n            reader = csv.reader(f, delimiter=';')\n            for row in reader:\n                self.nodes[row[0]] = Node(self, row[0], float(\n                    row[1]), int(row[2]), row[3] == \"True\")\n\n    def load_moves(self, encoding: str):\n        \"\"\" Loads the moves.csv file and creates the corresponding moves (and nodes if needed).\n\n        Args:\n            encoding (str): the encoding of the file\n        \"\"\"\n        assure_file(self.moves_file_path())\n        with open(self.moves_file_path(), \"r\", encoding=encoding) as f:\n            # fen; move; comment; SourceType; frequency;result fen\n            reader = csv.reader(f, delimiter=';')\n            for row in reader:\n                if len(row) &gt;= 6:\n                    result_fen = row[5]\n                else:\n                    # recover result_fen from san\n                    board = Board(fen=row[0])\n                    board.push_san(row[1])\n                    result_fen = get_reduced_fen_from_board(board)\n                move = Move(self, row[1], result_fen, row[2],\n                            SourceType.from_str(row[3]), int(row[4]))\n                self.get(row[0]).add(move)\n                self.assure(result_fen)\n\n    def load(self, encoding: str = STR_DEFAULT_ENCODING):\n        \"\"\" loads the tree from the position_eval.csv and moves.csv files\n\n        Args:\n            encoding (str, optional): Defaults to STR_DEFAULT_ENCODING. the encoding of the files\n        \"\"\"\n        self.load_position_evaluation(encoding)\n        self.load_moves(encoding)\n\n    def save(self):\n        \"\"\" saves the tree to the position_eval.csv and moves.csv files\n        \"\"\"\n        with open(self.moves_file_path(), \"w\", encoding=STR_DEFAULT_ENCODING) as file:\n            for fen in self.nodes:\n                for move in self.nodes[fen].moves:\n                    file.write(\"\\\"\" + fen + \"\\\";\\\"\" + move.san +\n                               \"\\\";\\\"\" + move.comment + \"\\\";\\\"\" + move.source.sformat() + \"\\\";\\\"\" +\n                               str(move.frequency) + \"\\\";\\\"\" + str(move.result) + \"\\\"\\n\")\n            file.flush()\n            file.close()\n        with open(self.position_evaluation_file_path(), \"w\", encoding=STR_DEFAULT_ENCODING) as file:\n            for fen in self.nodes:\n                node = self.nodes[fen]\n                file.write(\"\\\"\" + fen + \"\\\";\\\"\" + str(node.eval) +\n                           \"\\\";\\\"\" + str(node.eval_depth) + \"\\\";\\\"\" + str(node.is_mate) + \"\\\"\\n\")\n            file.flush()\n            file.close()\n</code></pre>"},{"location":"chessapp/model/chesstree/#chessapp.model.chesstree.ChessTree.__init__","title":"<code>__init__(save_folder_path)</code>","text":"<p>Creates a new ChessTree. The save_folder_path is the path where the tree will be saved to/loaded from if the corresponding files exist.</p> <p>Parameters:</p> Name Type Description Default <code>save_folder_path</code> <code>str</code> <p>description</p> required Source code in <code>chessapp\\model\\chesstree.py</code> <pre><code>def __init__(self, save_folder_path: str):\n    \"\"\" Creates a new ChessTree. The save_folder_path is the path where the tree will be saved to/loaded from if the corresponding\n    files exist.\n\n    Args:\n        save_folder_path (str): _description_\n    \"\"\"\n    self.nodes = {}\n    self.save_folder_path = save_folder_path\n    self.position_eval_file_name = \"position_eval.csv\"\n    self.moves_file_name = \"moves.csv\"\n</code></pre>"},{"location":"chessapp/model/chesstree/#chessapp.model.chesstree.ChessTree.assure","title":"<code>assure(fen)</code>","text":"<p>Creates a node with the given fen if it does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>fen</code> <code>str</code> <p>the fen</p> required Source code in <code>chessapp\\model\\chesstree.py</code> <pre><code>def assure(self, fen: str) -&gt; None:\n    \"\"\" Creates a node with the given fen if it does not exist.\n\n    Args:\n        fen (str): the fen\n    \"\"\"\n    if not fen in self.nodes:\n        self.nodes[fen] = Node(self, fen)\n</code></pre>"},{"location":"chessapp/model/chesstree/#chessapp.model.chesstree.ChessTree.clear","title":"<code>clear()</code>","text":"<p>\"forgets\" all nodes</p> Source code in <code>chessapp\\model\\chesstree.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\" \"forgets\" all nodes\n    \"\"\"\n    self.nodes = {}\n</code></pre>"},{"location":"chessapp/model/chesstree/#chessapp.model.chesstree.ChessTree.get","title":"<code>get(fen)</code>","text":"<p>Returns the node with the given fen. If the node does not exist, it is created.</p> <p>Parameters:</p> Name Type Description Default <code>fen</code> <code>str</code> <p>the fen</p> required <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>node with the given fen</p> Source code in <code>chessapp\\model\\chesstree.py</code> <pre><code>def get(self, fen: str) -&gt; Node:\n    \"\"\" Returns the node with the given fen. If the node does not exist, it is created.\n\n    Args:\n        fen (str): the fen\n\n    Returns:\n        Node: node with the given fen\n    \"\"\"\n    self.assure(fen)\n    return self.nodes[fen]\n</code></pre>"},{"location":"chessapp/model/chesstree/#chessapp.model.chesstree.ChessTree.load","title":"<code>load(encoding=STR_DEFAULT_ENCODING)</code>","text":"<p>loads the tree from the position_eval.csv and moves.csv files</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>Defaults to STR_DEFAULT_ENCODING. the encoding of the files</p> <code>STR_DEFAULT_ENCODING</code> Source code in <code>chessapp\\model\\chesstree.py</code> <pre><code>def load(self, encoding: str = STR_DEFAULT_ENCODING):\n    \"\"\" loads the tree from the position_eval.csv and moves.csv files\n\n    Args:\n        encoding (str, optional): Defaults to STR_DEFAULT_ENCODING. the encoding of the files\n    \"\"\"\n    self.load_position_evaluation(encoding)\n    self.load_moves(encoding)\n</code></pre>"},{"location":"chessapp/model/chesstree/#chessapp.model.chesstree.ChessTree.load_moves","title":"<code>load_moves(encoding)</code>","text":"<p>Loads the moves.csv file and creates the corresponding moves (and nodes if needed).</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>the encoding of the file</p> required Source code in <code>chessapp\\model\\chesstree.py</code> <pre><code>def load_moves(self, encoding: str):\n    \"\"\" Loads the moves.csv file and creates the corresponding moves (and nodes if needed).\n\n    Args:\n        encoding (str): the encoding of the file\n    \"\"\"\n    assure_file(self.moves_file_path())\n    with open(self.moves_file_path(), \"r\", encoding=encoding) as f:\n        # fen; move; comment; SourceType; frequency;result fen\n        reader = csv.reader(f, delimiter=';')\n        for row in reader:\n            if len(row) &gt;= 6:\n                result_fen = row[5]\n            else:\n                # recover result_fen from san\n                board = Board(fen=row[0])\n                board.push_san(row[1])\n                result_fen = get_reduced_fen_from_board(board)\n            move = Move(self, row[1], result_fen, row[2],\n                        SourceType.from_str(row[3]), int(row[4]))\n            self.get(row[0]).add(move)\n            self.assure(result_fen)\n</code></pre>"},{"location":"chessapp/model/chesstree/#chessapp.model.chesstree.ChessTree.load_position_evaluation","title":"<code>load_position_evaluation(encoding)</code>","text":"<p>Loads the position_eval.csv file and creates the corresponding nodes.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>the encoding of the file</p> required Source code in <code>chessapp\\model\\chesstree.py</code> <pre><code>def load_position_evaluation(self, encoding: str):\n    \"\"\" Loads the position_eval.csv file and creates the corresponding nodes.\n\n    Args:\n        encoding (str): the encoding of the file\n    \"\"\"\n    assure_file(self.position_evaluation_file_path())\n    with open(self.position_evaluation_file_path(), \"r\", encoding=encoding) as f:\n        # fen; eval; eval_depth; is_mate\n        reader = csv.reader(f, delimiter=';')\n        for row in reader:\n            self.nodes[row[0]] = Node(self, row[0], float(\n                row[1]), int(row[2]), row[3] == \"True\")\n</code></pre>"},{"location":"chessapp/model/chesstree/#chessapp.model.chesstree.ChessTree.moves_file_path","title":"<code>moves_file_path()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the path of the moves.csv file</p> Source code in <code>chessapp\\model\\chesstree.py</code> <pre><code>def moves_file_path(self) -&gt; str:\n    \"\"\"\n    Returns:\n        str: the path of the moves.csv file\n    \"\"\"\n    return self.save_folder_path + \"/\" + self.moves_file_name\n</code></pre>"},{"location":"chessapp/model/chesstree/#chessapp.model.chesstree.ChessTree.position_evaluation_file_path","title":"<code>position_evaluation_file_path()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the path of the position_eval.csv file</p> Source code in <code>chessapp\\model\\chesstree.py</code> <pre><code>def position_evaluation_file_path(self) -&gt; str:\n    \"\"\"\n    Returns:\n        str: the path of the position_eval.csv file\n    \"\"\"\n    return self.save_folder_path + \"/\" + self.position_eval_file_name\n</code></pre>"},{"location":"chessapp/model/chesstree/#chessapp.model.chesstree.ChessTree.save","title":"<code>save()</code>","text":"<p>saves the tree to the position_eval.csv and moves.csv files</p> Source code in <code>chessapp\\model\\chesstree.py</code> <pre><code>def save(self):\n    \"\"\" saves the tree to the position_eval.csv and moves.csv files\n    \"\"\"\n    with open(self.moves_file_path(), \"w\", encoding=STR_DEFAULT_ENCODING) as file:\n        for fen in self.nodes:\n            for move in self.nodes[fen].moves:\n                file.write(\"\\\"\" + fen + \"\\\";\\\"\" + move.san +\n                           \"\\\";\\\"\" + move.comment + \"\\\";\\\"\" + move.source.sformat() + \"\\\";\\\"\" +\n                           str(move.frequency) + \"\\\";\\\"\" + str(move.result) + \"\\\"\\n\")\n        file.flush()\n        file.close()\n    with open(self.position_evaluation_file_path(), \"w\", encoding=STR_DEFAULT_ENCODING) as file:\n        for fen in self.nodes:\n            node = self.nodes[fen]\n            file.write(\"\\\"\" + fen + \"\\\";\\\"\" + str(node.eval) +\n                       \"\\\";\\\"\" + str(node.eval_depth) + \"\\\";\\\"\" + str(node.is_mate) + \"\\\"\\n\")\n        file.flush()\n        file.close()\n</code></pre>"},{"location":"chessapp/model/chesstree/#source","title":"Source","text":"<pre><code>import csv\nfrom chessapp.model.node import Node\nfrom chessapp.model.sourcetype import SourceType\nfrom chessapp.model.move import Move\nfrom chess import Board\nfrom chessapp.util.paths import assure_file\nfrom chessapp.configuration import STR_DEFAULT_ENCODING\nfrom chessapp.util.fen import get_reduced_fen_from_board\n\n\nclass ChessTree:\n    \"\"\" ChessTree is a graph (not actually a tree but commonly referred to as a tree). It is the main data structure of the application.\n    Each node represents a position and each move of a node represents an arc in the graph.\n\n    This datastructure is saved to and loaded from two csv files: position_eval.csv and moves.csv. The position_eval.csv contains the\n    evaluation of each position and the moves.csv contains the known moves of each position. Both files are located in the save_folder_path\n    folder. The position_eval.csv contains the following columns:\\n\n    - fen: the fen of the position\n    - eval: the evaluation of the position\n    - eval_depth: the depth of the evaluation\n    - is_mate: whether the position is a mate position or not\\n\n    The moves.csv contains the following columns:\\n\n    - fen: the fen of the position\n    - move: the move in san notation\n    - comment: the comment of the move (optional)\n    - SourceType: the source of the move (@see chessapp.model.sourcetype.SourceType)\n    - frequency: the frequency of the move (how often it was played in the database)\n    - result fen: the fen of the resulting position after the move is played\n    \"\"\"\n\n    def __init__(self, save_folder_path: str):\n        \"\"\" Creates a new ChessTree. The save_folder_path is the path where the tree will be saved to/loaded from if the corresponding\n        files exist.\n\n        Args:\n            save_folder_path (str): _description_\n        \"\"\"\n        self.nodes = {}\n        self.save_folder_path = save_folder_path\n        self.position_eval_file_name = \"position_eval.csv\"\n        self.moves_file_name = \"moves.csv\"\n\n    def clear(self) -&gt; None:\n        \"\"\" \"forgets\" all nodes\n        \"\"\"\n        self.nodes = {}\n\n    def get(self, fen: str) -&gt; Node:\n        \"\"\" Returns the node with the given fen. If the node does not exist, it is created.\n\n        Args:\n            fen (str): the fen\n\n        Returns:\n            Node: node with the given fen\n        \"\"\"\n        self.assure(fen)\n        return self.nodes[fen]\n\n    def assure(self, fen: str) -&gt; None:\n        \"\"\" Creates a node with the given fen if it does not exist.\n\n        Args:\n            fen (str): the fen\n        \"\"\"\n        if not fen in self.nodes:\n            self.nodes[fen] = Node(self, fen)\n\n    def position_evaluation_file_path(self) -&gt; str:\n        \"\"\"\n        Returns:\n            str: the path of the position_eval.csv file\n        \"\"\"\n        return self.save_folder_path + \"/\" + self.position_eval_file_name\n\n    def moves_file_path(self) -&gt; str:\n        \"\"\"\n        Returns:\n            str: the path of the moves.csv file\n        \"\"\"\n        return self.save_folder_path + \"/\" + self.moves_file_name\n\n    def load_position_evaluation(self, encoding: str):\n        \"\"\" Loads the position_eval.csv file and creates the corresponding nodes.\n\n        Args:\n            encoding (str): the encoding of the file\n        \"\"\"\n        assure_file(self.position_evaluation_file_path())\n        with open(self.position_evaluation_file_path(), \"r\", encoding=encoding) as f:\n            # fen; eval; eval_depth; is_mate\n            reader = csv.reader(f, delimiter=';')\n            for row in reader:\n                self.nodes[row[0]] = Node(self, row[0], float(\n                    row[1]), int(row[2]), row[3] == \"True\")\n\n    def load_moves(self, encoding: str):\n        \"\"\" Loads the moves.csv file and creates the corresponding moves (and nodes if needed).\n\n        Args:\n            encoding (str): the encoding of the file\n        \"\"\"\n        assure_file(self.moves_file_path())\n        with open(self.moves_file_path(), \"r\", encoding=encoding) as f:\n            # fen; move; comment; SourceType; frequency;result fen\n            reader = csv.reader(f, delimiter=';')\n            for row in reader:\n                if len(row) &gt;= 6:\n                    result_fen = row[5]\n                else:\n                    # recover result_fen from san\n                    board = Board(fen=row[0])\n                    board.push_san(row[1])\n                    result_fen = get_reduced_fen_from_board(board)\n                move = Move(self, row[1], result_fen, row[2],\n                            SourceType.from_str(row[3]), int(row[4]))\n                self.get(row[0]).add(move)\n                self.assure(result_fen)\n\n    def load(self, encoding: str = STR_DEFAULT_ENCODING):\n        \"\"\" loads the tree from the position_eval.csv and moves.csv files\n\n        Args:\n            encoding (str, optional): Defaults to STR_DEFAULT_ENCODING. the encoding of the files\n        \"\"\"\n        self.load_position_evaluation(encoding)\n        self.load_moves(encoding)\n\n    def save(self):\n        \"\"\" saves the tree to the position_eval.csv and moves.csv files\n        \"\"\"\n        with open(self.moves_file_path(), \"w\", encoding=STR_DEFAULT_ENCODING) as file:\n            for fen in self.nodes:\n                for move in self.nodes[fen].moves:\n                    file.write(\"\\\"\" + fen + \"\\\";\\\"\" + move.san +\n                               \"\\\";\\\"\" + move.comment + \"\\\";\\\"\" + move.source.sformat() + \"\\\";\\\"\" +\n                               str(move.frequency) + \"\\\";\\\"\" + str(move.result) + \"\\\"\\n\")\n            file.flush()\n            file.close()\n        with open(self.position_evaluation_file_path(), \"w\", encoding=STR_DEFAULT_ENCODING) as file:\n            for fen in self.nodes:\n                node = self.nodes[fen]\n                file.write(\"\\\"\" + fen + \"\\\";\\\"\" + str(node.eval) +\n                           \"\\\";\\\"\" + str(node.eval_depth) + \"\\\";\\\"\" + str(node.is_mate) + \"\\\"\\n\")\n            file.flush()\n            file.close()\n</code></pre>"},{"location":"chessapp/model/move/","title":"move","text":""},{"location":"chessapp/model/move/#chessapp.model.move.Move","title":"<code>chessapp.model.move.Move</code>","text":"Source code in <code>chessapp\\model\\move.py</code> <pre><code>class Move:\n    def __init__(self, tree, san: str, result: str, comment: str = \"\", source: SourceType = SourceType.default_value(), frequency: int = 0):\n        \"\"\" creates a new move in the tree with the given SAN and resulting fen\n\n        Args:\n            tree (ChessTree): the tree in which this move is contained\n            san (str): SAN of the move\n            result (str): resulting fen after this move is played\n            comment (str, optional): Defaults to \"\". comment for this move. this can be anything that might be useful to users that explore this move.\n            source (SourceType, optional): Defaults to SourceType.default_value(). source of this move.\n            frequency (int, optional): Defaults to 0. frequency of this move (how many times it has been played)\n        \"\"\"\n        self.tree = tree\n        self.san: str = san\n        self.result: str = result\n        self.comment: str = comment\n        self.source: SourceType = source\n        self.frequency: int = frequency\n\n    def is_equivalent_to(self, other) -&gt; bool:\n        \"\"\" two moves are equivalent if they have the same SAN and resulting fen.\n\n        Args:\n            other (Move): the other move to compare to\n\n        Returns:\n            bool: True if the two moves are equivalent, False otherwise\n        \"\"\"\n        return other != None and self.san == other.san and self.result == other.result\n\n    def get_info(self, node) -&gt; str:\n        \"\"\" returns a string formatting information about this move in human readable form\n\n        Args:\n            node (Node): the node from which this move originates\n\n        Returns:\n            str: the information string in human readable form\n        \"\"\"\n        info: str = self.san + \" with eval \" + str(self.eval()) + \" at depth \" + str(self.eval_depth(\n        )) + \" (cp loss = \" + str(node.get_cp_loss(self)) + \") from source \" + self.source.sformat()\n        return info\n\n    def eval(self) -&gt; float:\n        \"\"\" returns the evaluation of this move\n\n        Returns:\n            float: the evaluation of this move\n        \"\"\"\n        return self.tree.get(self.result).eval\n\n    def eval_depth(self) -&gt; int:\n        \"\"\" returns the evaluation depth of this move\n\n        Returns:\n            int: the evaluation depth of this move\n        \"\"\"\n        return self.tree.get(self.result).eval_depth\n</code></pre>"},{"location":"chessapp/model/move/#chessapp.model.move.Move.__init__","title":"<code>__init__(tree, san, result, comment='', source=SourceType.default_value(), frequency=0)</code>","text":"<p>creates a new move in the tree with the given SAN and resulting fen</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>ChessTree</code> <p>the tree in which this move is contained</p> required <code>san</code> <code>str</code> <p>SAN of the move</p> required <code>result</code> <code>str</code> <p>resulting fen after this move is played</p> required <code>comment</code> <code>str</code> <p>Defaults to \"\". comment for this move. this can be anything that might be useful to users that explore this move.</p> <code>''</code> <code>source</code> <code>SourceType</code> <p>Defaults to SourceType.default_value(). source of this move.</p> <code>default_value()</code> <code>frequency</code> <code>int</code> <p>Defaults to 0. frequency of this move (how many times it has been played)</p> <code>0</code> Source code in <code>chessapp\\model\\move.py</code> <pre><code>def __init__(self, tree, san: str, result: str, comment: str = \"\", source: SourceType = SourceType.default_value(), frequency: int = 0):\n    \"\"\" creates a new move in the tree with the given SAN and resulting fen\n\n    Args:\n        tree (ChessTree): the tree in which this move is contained\n        san (str): SAN of the move\n        result (str): resulting fen after this move is played\n        comment (str, optional): Defaults to \"\". comment for this move. this can be anything that might be useful to users that explore this move.\n        source (SourceType, optional): Defaults to SourceType.default_value(). source of this move.\n        frequency (int, optional): Defaults to 0. frequency of this move (how many times it has been played)\n    \"\"\"\n    self.tree = tree\n    self.san: str = san\n    self.result: str = result\n    self.comment: str = comment\n    self.source: SourceType = source\n    self.frequency: int = frequency\n</code></pre>"},{"location":"chessapp/model/move/#chessapp.model.move.Move.eval","title":"<code>eval()</code>","text":"<p>returns the evaluation of this move</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the evaluation of this move</p> Source code in <code>chessapp\\model\\move.py</code> <pre><code>def eval(self) -&gt; float:\n    \"\"\" returns the evaluation of this move\n\n    Returns:\n        float: the evaluation of this move\n    \"\"\"\n    return self.tree.get(self.result).eval\n</code></pre>"},{"location":"chessapp/model/move/#chessapp.model.move.Move.eval_depth","title":"<code>eval_depth()</code>","text":"<p>returns the evaluation depth of this move</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the evaluation depth of this move</p> Source code in <code>chessapp\\model\\move.py</code> <pre><code>def eval_depth(self) -&gt; int:\n    \"\"\" returns the evaluation depth of this move\n\n    Returns:\n        int: the evaluation depth of this move\n    \"\"\"\n    return self.tree.get(self.result).eval_depth\n</code></pre>"},{"location":"chessapp/model/move/#chessapp.model.move.Move.get_info","title":"<code>get_info(node)</code>","text":"<p>returns a string formatting information about this move in human readable form</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>the node from which this move originates</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the information string in human readable form</p> Source code in <code>chessapp\\model\\move.py</code> <pre><code>def get_info(self, node) -&gt; str:\n    \"\"\" returns a string formatting information about this move in human readable form\n\n    Args:\n        node (Node): the node from which this move originates\n\n    Returns:\n        str: the information string in human readable form\n    \"\"\"\n    info: str = self.san + \" with eval \" + str(self.eval()) + \" at depth \" + str(self.eval_depth(\n    )) + \" (cp loss = \" + str(node.get_cp_loss(self)) + \") from source \" + self.source.sformat()\n    return info\n</code></pre>"},{"location":"chessapp/model/move/#chessapp.model.move.Move.is_equivalent_to","title":"<code>is_equivalent_to(other)</code>","text":"<p>two moves are equivalent if they have the same SAN and resulting fen.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Move</code> <p>the other move to compare to</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the two moves are equivalent, False otherwise</p> Source code in <code>chessapp\\model\\move.py</code> <pre><code>def is_equivalent_to(self, other) -&gt; bool:\n    \"\"\" two moves are equivalent if they have the same SAN and resulting fen.\n\n    Args:\n        other (Move): the other move to compare to\n\n    Returns:\n        bool: True if the two moves are equivalent, False otherwise\n    \"\"\"\n    return other != None and self.san == other.san and self.result == other.result\n</code></pre>"},{"location":"chessapp/model/move/#source","title":"Source","text":"<pre><code>from chessapp.model.sourcetype import SourceType\n\n\nclass Move:\n    def __init__(self, tree, san: str, result: str, comment: str = \"\", source: SourceType = SourceType.default_value(), frequency: int = 0):\n        \"\"\" creates a new move in the tree with the given SAN and resulting fen\n\n        Args:\n            tree (ChessTree): the tree in which this move is contained\n            san (str): SAN of the move\n            result (str): resulting fen after this move is played\n            comment (str, optional): Defaults to \"\". comment for this move. this can be anything that might be useful to users that explore this move.\n            source (SourceType, optional): Defaults to SourceType.default_value(). source of this move.\n            frequency (int, optional): Defaults to 0. frequency of this move (how many times it has been played)\n        \"\"\"\n        self.tree = tree\n        self.san: str = san\n        self.result: str = result\n        self.comment: str = comment\n        self.source: SourceType = source\n        self.frequency: int = frequency\n\n    def is_equivalent_to(self, other) -&gt; bool:\n        \"\"\" two moves are equivalent if they have the same SAN and resulting fen.\n\n        Args:\n            other (Move): the other move to compare to\n\n        Returns:\n            bool: True if the two moves are equivalent, False otherwise\n        \"\"\"\n        return other != None and self.san == other.san and self.result == other.result\n\n    def get_info(self, node) -&gt; str:\n        \"\"\" returns a string formatting information about this move in human readable form\n\n        Args:\n            node (Node): the node from which this move originates\n\n        Returns:\n            str: the information string in human readable form\n        \"\"\"\n        info: str = self.san + \" with eval \" + str(self.eval()) + \" at depth \" + str(self.eval_depth(\n        )) + \" (cp loss = \" + str(node.get_cp_loss(self)) + \") from source \" + self.source.sformat()\n        return info\n\n    def eval(self) -&gt; float:\n        \"\"\" returns the evaluation of this move\n\n        Returns:\n            float: the evaluation of this move\n        \"\"\"\n        return self.tree.get(self.result).eval\n\n    def eval_depth(self) -&gt; int:\n        \"\"\" returns the evaluation depth of this move\n\n        Returns:\n            int: the evaluation depth of this move\n        \"\"\"\n        return self.tree.get(self.result).eval_depth\n</code></pre>"},{"location":"chessapp/model/node/","title":"node","text":""},{"location":"chessapp/model/node/#chessapp.model.node.Backlink","title":"<code>chessapp.model.node.Backlink</code>  <code>dataclass</code>","text":"<p>A backlink links a node A to a previous node B such that playing the move in B leads to A.</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>@dataclass\nclass Backlink:\n    \"\"\" A backlink links a node A to a previous node B such that playing the move in B leads to A.\n    \"\"\"\n    node: object\n    move: Move\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node","title":"<code>chessapp.model.node.Node</code>","text":"<p>A node represents a position in the chess tree. It contains the following information: - state: the fen of the position - eval: the evaluation of the position - eval_depth: the depth of the evaluation - is_mate: whether the position is a mate position or not - moves: the known moves of the position - backlinks: the links pointing to the known nodes leading to this node</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>class Node:\n    \"\"\" A node represents a position in the chess tree. It contains the following information:\n    - state: the fen of the position\n    - eval: the evaluation of the position\n    - eval_depth: the depth of the evaluation\n    - is_mate: whether the position is a mate position or not\n    - moves: the known moves of the position\n    - backlinks: the links pointing to the known nodes leading to this node\n    \"\"\"\n\n    def __init__(self, tree, fen: str, eval: float = 0, eval_depth: int = -1, is_mate: bool = False):\n        \"\"\" creates a new node with the given fen\n\n        Args:\n            tree (ChessTree): the tree in which this node is contained\n            fen (str): fen of the position\n            eval (float, optional): evaluation of the position\n            eval_depth (int, optional): depth of the evaluation\n            is_mate (bool, optional): whether the position is a mate position or not\n        \"\"\"\n        self.tree = tree\n        self.state: str = fen\n        self.moves = []\n        self.backlinks = []\n        self.eval: float = eval\n        self.eval_depth: float = eval_depth\n        self.is_mate: bool = is_mate\n\n    def update(self, eval: float, eval_depth: int, is_mate: bool):\n        \"\"\" updates the evaluation of this node if the given evaluation depth is deeper than the current one or\n        if the new evaluation is a mate and the current evaluation is not a mate\n\n        Args:\n            eval (float): evaluation of the position\n            eval_depth (int): depth of the evaluation\n            is_mate (bool): whether the position is a mate position or not\n        \"\"\"\n        if eval_depth &gt; self.eval_depth or (not self.is_mate and is_mate):\n            self.eval_depth = eval_depth\n            self.eval = eval\n            self.is_mate = is_mate\n\n    def add(self, move: Move):\n        \"\"\" adds a move to the node. if the move is already known, the source and the comment are updated if applicable\n\n        Args:\n            move (Move): _description_\n        \"\"\"\n        for m in self.moves:\n            if m.is_equivalent_to(move):\n                if m.source.value &lt; move.source.value:\n                    m.source = move.source\n                if move.comment and not m.comment:\n                    m.comment = move.comment\n                return\n        self.moves.append(move)\n        self.tree.get(move.result).backlink(self, move)\n\n    def backlink(self, node, move: Move):\n        \"\"\" adds a backlink to the node.\n        TODO: this is kinda ugly. the backlink should be added to the node when the move is added to the node. Should Move know the fen of the positon it is played in?&gt;\n\n        Args:\n            node (Node): previous node\n            move (Move): move that leads from the previous node to this node\n        \"\"\"\n        self.backlinks.append(Backlink(node, move))\n\n    def knows_move(self, move: Move) -&gt; bool:\n        \"\"\" checks whether the node knows the given move\n\n        Args:\n            move (Move): move to check\n\n        Returns:\n            bool: True if the node knows the move, False otherwise\n        \"\"\"\n        return self.get_equivalent_move(move) != None\n\n    def get_equivalent_move(self, move: Move) -&gt; Move | None:\n        \"\"\" returns the equivalent move if the node knows the given move, None otherwise\n\n        Args:\n            move (Move): move to check\n\n        Returns:\n            Move | None: the equivalent move if the node knows the given move, None otherwise\n        \"\"\"\n        for m in self.moves:\n            if m.is_equivalent_to(move):\n                return m\n        return None\n\n    def has_move(self) -&gt; bool:\n        \"\"\" checks whether the node knows at least one move\n\n        Returns:\n            bool: True if the node knows at least one move, False otherwise\n        \"\"\"\n        return len(self.moves) != 0\n\n    def total_frequency(self) -&gt; int:\n        \"\"\" returns the total frequency of all moves of the node (the sum of the frequencies of all moves)\n\n        Returns:\n            int: the total frequency of all moves of the node\n        \"\"\"\n        sum: int = 0\n        for move in self.moves:\n            sum += move.frequency\n        return sum\n\n    def has_frequency(self) -&gt; bool:\n        \"\"\" checks whether the node has at least one move with a frequency &gt; 0\n\n        Returns:\n            bool: True if the node has at least one move with a frequency &gt; 0, False otherwise\n        \"\"\"\n        return self.total_frequency() &gt; 0\n\n    def random_move(self, random: Random, use_frequency: bool = False) -&gt; Move:\n        \"\"\" returns a random move of the node. if use_frequency is True, the probability of a move to be chosen is\n        proportional to the frequency of the move. if use_frequency is False, all moves have the same probability.\n        TODO: move this method in a different module.\n\n        Args:\n            random (Random): _description_\n            use_frequency (bool, optional): _description_. Defaults to False.\n\n        Raises:\n            Exception: _description_\n\n        Returns:\n            Move: _description_\n        \"\"\"\n        if not use_frequency:\n            return self.moves[random.randint(0, len(self.moves) - 1)]\n        chosen_move = None\n        total = self.total_frequency()\n        sum = 0\n        target = random.randint(0, total - 1)\n        for move in self.moves:\n            if sum + move.frequency &gt; target:\n                chosen_move = move\n                break\n            sum += move.frequency\n        if chosen_move == None:\n            raise Exception(\n                \"cannot chose a move. check frequencies of the moves of node \" + self.state)\n        return chosen_move\n\n    def is_white_turn(self) -&gt; bool:\n        \"\"\" checks whether it is white's turn in the node. \n        TODO: decide if this method should be more efficient. Every time this method is called the fen of the node is split. Instead this could be a simple bool that is set on __init__.\n\n        Returns:\n            bool: True if it is white's turn in the node, False otherwise\n        \"\"\"\n        return self.state.split(\" \")[1] == \"w\"\n\n    def get_cp_loss(self, move: Move) -&gt; int:\n        \"\"\" returns the centipawn loss of the given move. the centipawn loss is the difference between the evaluation\n        of the node and the evaluation of the node that results from playing the specified move.\n        TODO: figure out if this method has to be moved to a different module.\n\n        Args:\n            move (Move): move to check\n\n        Returns:\n            int: the centipawn loss of the given move\n        \"\"\"\n        return round(abs(self.eval - move.eval()) * 100)\n\n    def get_move_by_san(self, move_san: str) -&gt; Move | None:\n        \"\"\" returns the move with the given san if the node knows the move, None otherwise\n\n        Args:\n            move_san (str): san of the move to get\n\n        Returns:\n            Move | None: the move with the given san if the node knows the move, None otherwise\n        \"\"\"\n        for move in self.moves:\n            if move.san == move_san:\n                return move\n        return None\n\n    def is_acceptable_move(self, move: Move) -&gt; bool:\n        \"\"\" checks whether the given move is acceptable. a move is acceptable if the difference between the evaluation\n        of the node and the evaluation of the move is not too high. the maximum difference is defined in the configuration\n        as QUIZ_ACCEPT_EVAL_DIFF. if the move is a move from a relaxed source, the maximum difference is defined in the\n        configuration as QUIZ_ACCEPT_EVAL_DIFF_RELAXED. a source is relaxed if it is contained in the list\n        QUIZ_ACCEPT_RELAXED_SOURCES in configuration.\n        TODO: move this method in a different module.\n\n        Args:\n            move (Move): move to check\n\n        Returns:\n            bool: True if the move is acceptable, False otherwise\n        \"\"\"\n        if move.eval_depth() &lt; 0:\n            return False\n        eval_diff_accept = QUIZ_ACCEPT_EVAL_DIFF\n        if move.source in QUIZ_ACCEPT_RELAXED_SOURCES:\n            eval_diff_accept = QUIZ_ACCEPT_EVAL_DIFF_RELAXED\n        # check turn player\n        eval_best = self.eval\n        if self.eval_depth &lt; 0:\n            best_move = self.get_best_move()\n            if best_move != None:\n                if best_move.eval_depth() &gt; 0:\n                    eval_best = best_move.eval()\n            else:\n                return True\n        if self.is_white_turn():\n            return eval_best - move.eval() &lt;= eval_diff_accept\n        else:\n            return move.eval() - eval_best &lt;= eval_diff_accept\n\n    def has_acceptable_move(self) -&gt; bool:\n        \"\"\" checks whether the node has at least one acceptable move. @see is_acceptable_move.\n        TODO: move this method in a different module.\n\n        Returns:\n            bool: True if the node has at least one acceptable move, False otherwise\n        \"\"\"\n        for move in self.moves:\n            if self.is_acceptable_move(move):\n                return True\n        return False\n\n    def get_best_move(self, min_depth: int = 0) -&gt; Move | None:\n        \"\"\" returns the best move of the node. the best move is the move with the highest evaluation value amongst\n        the moves with highest depth. if there is no move with at least a depth of min_depth, None is returned.\n\n\n        Args:\n            min_depth (int, optional): the minimum depth of the move to be returned.\n\n        Returns:\n            Move | None: the best move of the node\n        \"\"\"\n        if len(self.moves) == 0:\n            return None\n        best_move = None\n        # first search for a node as a baseline that has at least a depth of min_depth\n        for move in self.moves:\n            if not best_move or move.eval_depth() &gt; best_move.eval_depth():\n                best_move = move\n        if not best_move:\n            return None\n        is_white_turn = self.is_white_turn()\n        # now find a move that not only satisfies with depth min_depth but also has a better eval value\n        for move in self.moves:\n            if move.eval_depth() &gt;= min_depth:\n                if is_white_turn:\n                    if move.eval() &gt; best_move.eval():\n                        best_move = move\n                else:\n                    if move.eval() &lt; best_move.eval():\n                        best_move = move\n        return best_move\n\n    def source(self) -&gt; SourceType:\n        \"\"\" returns the source of the node. the source is the highest source of all moves of the node.\n\n        Returns:\n            SourceType: the source of the node\n        \"\"\"\n        source = SourceType.ENGINE_SYNTHETIC\n        for backlink in self.backlinks:\n            if backlink.move.source.value &gt; source.value:\n                source = backlink.move.source\n        return source\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.__init__","title":"<code>__init__(tree, fen, eval=0, eval_depth=-1, is_mate=False)</code>","text":"<p>creates a new node with the given fen</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>ChessTree</code> <p>the tree in which this node is contained</p> required <code>fen</code> <code>str</code> <p>fen of the position</p> required <code>eval</code> <code>float</code> <p>evaluation of the position</p> <code>0</code> <code>eval_depth</code> <code>int</code> <p>depth of the evaluation</p> <code>-1</code> <code>is_mate</code> <code>bool</code> <p>whether the position is a mate position or not</p> <code>False</code> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def __init__(self, tree, fen: str, eval: float = 0, eval_depth: int = -1, is_mate: bool = False):\n    \"\"\" creates a new node with the given fen\n\n    Args:\n        tree (ChessTree): the tree in which this node is contained\n        fen (str): fen of the position\n        eval (float, optional): evaluation of the position\n        eval_depth (int, optional): depth of the evaluation\n        is_mate (bool, optional): whether the position is a mate position or not\n    \"\"\"\n    self.tree = tree\n    self.state: str = fen\n    self.moves = []\n    self.backlinks = []\n    self.eval: float = eval\n    self.eval_depth: float = eval_depth\n    self.is_mate: bool = is_mate\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.add","title":"<code>add(move)</code>","text":"<p>adds a move to the node. if the move is already known, the source and the comment are updated if applicable</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>Move</code> <p>description</p> required Source code in <code>chessapp\\model\\node.py</code> <pre><code>def add(self, move: Move):\n    \"\"\" adds a move to the node. if the move is already known, the source and the comment are updated if applicable\n\n    Args:\n        move (Move): _description_\n    \"\"\"\n    for m in self.moves:\n        if m.is_equivalent_to(move):\n            if m.source.value &lt; move.source.value:\n                m.source = move.source\n            if move.comment and not m.comment:\n                m.comment = move.comment\n            return\n    self.moves.append(move)\n    self.tree.get(move.result).backlink(self, move)\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.backlink","title":"<code>backlink(node, move)</code>","text":"<p>adds a backlink to the node. TODO: this is kinda ugly. the backlink should be added to the node when the move is added to the node. Should Move know the fen of the positon it is played in?&gt;</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>previous node</p> required <code>move</code> <code>Move</code> <p>move that leads from the previous node to this node</p> required Source code in <code>chessapp\\model\\node.py</code> <pre><code>def backlink(self, node, move: Move):\n    \"\"\" adds a backlink to the node.\n    TODO: this is kinda ugly. the backlink should be added to the node when the move is added to the node. Should Move know the fen of the positon it is played in?&gt;\n\n    Args:\n        node (Node): previous node\n        move (Move): move that leads from the previous node to this node\n    \"\"\"\n    self.backlinks.append(Backlink(node, move))\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.get_best_move","title":"<code>get_best_move(min_depth=0)</code>","text":"<p>returns the best move of the node. the best move is the move with the highest evaluation value amongst the moves with highest depth. if there is no move with at least a depth of min_depth, None is returned.</p> <p>Parameters:</p> Name Type Description Default <code>min_depth</code> <code>int</code> <p>the minimum depth of the move to be returned.</p> <code>0</code> <p>Returns:</p> Type Description <code>Move | None</code> <p>Move | None: the best move of the node</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def get_best_move(self, min_depth: int = 0) -&gt; Move | None:\n    \"\"\" returns the best move of the node. the best move is the move with the highest evaluation value amongst\n    the moves with highest depth. if there is no move with at least a depth of min_depth, None is returned.\n\n\n    Args:\n        min_depth (int, optional): the minimum depth of the move to be returned.\n\n    Returns:\n        Move | None: the best move of the node\n    \"\"\"\n    if len(self.moves) == 0:\n        return None\n    best_move = None\n    # first search for a node as a baseline that has at least a depth of min_depth\n    for move in self.moves:\n        if not best_move or move.eval_depth() &gt; best_move.eval_depth():\n            best_move = move\n    if not best_move:\n        return None\n    is_white_turn = self.is_white_turn()\n    # now find a move that not only satisfies with depth min_depth but also has a better eval value\n    for move in self.moves:\n        if move.eval_depth() &gt;= min_depth:\n            if is_white_turn:\n                if move.eval() &gt; best_move.eval():\n                    best_move = move\n            else:\n                if move.eval() &lt; best_move.eval():\n                    best_move = move\n    return best_move\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.get_cp_loss","title":"<code>get_cp_loss(move)</code>","text":"<p>returns the centipawn loss of the given move. the centipawn loss is the difference between the evaluation of the node and the evaluation of the node that results from playing the specified move. TODO: figure out if this method has to be moved to a different module.</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>Move</code> <p>move to check</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the centipawn loss of the given move</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def get_cp_loss(self, move: Move) -&gt; int:\n    \"\"\" returns the centipawn loss of the given move. the centipawn loss is the difference between the evaluation\n    of the node and the evaluation of the node that results from playing the specified move.\n    TODO: figure out if this method has to be moved to a different module.\n\n    Args:\n        move (Move): move to check\n\n    Returns:\n        int: the centipawn loss of the given move\n    \"\"\"\n    return round(abs(self.eval - move.eval()) * 100)\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.get_equivalent_move","title":"<code>get_equivalent_move(move)</code>","text":"<p>returns the equivalent move if the node knows the given move, None otherwise</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>Move</code> <p>move to check</p> required <p>Returns:</p> Type Description <code>Move | None</code> <p>Move | None: the equivalent move if the node knows the given move, None otherwise</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def get_equivalent_move(self, move: Move) -&gt; Move | None:\n    \"\"\" returns the equivalent move if the node knows the given move, None otherwise\n\n    Args:\n        move (Move): move to check\n\n    Returns:\n        Move | None: the equivalent move if the node knows the given move, None otherwise\n    \"\"\"\n    for m in self.moves:\n        if m.is_equivalent_to(move):\n            return m\n    return None\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.get_move_by_san","title":"<code>get_move_by_san(move_san)</code>","text":"<p>returns the move with the given san if the node knows the move, None otherwise</p> <p>Parameters:</p> Name Type Description Default <code>move_san</code> <code>str</code> <p>san of the move to get</p> required <p>Returns:</p> Type Description <code>Move | None</code> <p>Move | None: the move with the given san if the node knows the move, None otherwise</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def get_move_by_san(self, move_san: str) -&gt; Move | None:\n    \"\"\" returns the move with the given san if the node knows the move, None otherwise\n\n    Args:\n        move_san (str): san of the move to get\n\n    Returns:\n        Move | None: the move with the given san if the node knows the move, None otherwise\n    \"\"\"\n    for move in self.moves:\n        if move.san == move_san:\n            return move\n    return None\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.has_acceptable_move","title":"<code>has_acceptable_move()</code>","text":"<p>checks whether the node has at least one acceptable move. @see is_acceptable_move. TODO: move this method in a different module.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the node has at least one acceptable move, False otherwise</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def has_acceptable_move(self) -&gt; bool:\n    \"\"\" checks whether the node has at least one acceptable move. @see is_acceptable_move.\n    TODO: move this method in a different module.\n\n    Returns:\n        bool: True if the node has at least one acceptable move, False otherwise\n    \"\"\"\n    for move in self.moves:\n        if self.is_acceptable_move(move):\n            return True\n    return False\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.has_frequency","title":"<code>has_frequency()</code>","text":"<p>checks whether the node has at least one move with a frequency &gt; 0</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the node has at least one move with a frequency &gt; 0, False otherwise</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def has_frequency(self) -&gt; bool:\n    \"\"\" checks whether the node has at least one move with a frequency &gt; 0\n\n    Returns:\n        bool: True if the node has at least one move with a frequency &gt; 0, False otherwise\n    \"\"\"\n    return self.total_frequency() &gt; 0\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.has_move","title":"<code>has_move()</code>","text":"<p>checks whether the node knows at least one move</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the node knows at least one move, False otherwise</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def has_move(self) -&gt; bool:\n    \"\"\" checks whether the node knows at least one move\n\n    Returns:\n        bool: True if the node knows at least one move, False otherwise\n    \"\"\"\n    return len(self.moves) != 0\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.is_acceptable_move","title":"<code>is_acceptable_move(move)</code>","text":"<p>checks whether the given move is acceptable. a move is acceptable if the difference between the evaluation of the node and the evaluation of the move is not too high. the maximum difference is defined in the configuration as QUIZ_ACCEPT_EVAL_DIFF. if the move is a move from a relaxed source, the maximum difference is defined in the configuration as QUIZ_ACCEPT_EVAL_DIFF_RELAXED. a source is relaxed if it is contained in the list QUIZ_ACCEPT_RELAXED_SOURCES in configuration. TODO: move this method in a different module.</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>Move</code> <p>move to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the move is acceptable, False otherwise</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def is_acceptable_move(self, move: Move) -&gt; bool:\n    \"\"\" checks whether the given move is acceptable. a move is acceptable if the difference between the evaluation\n    of the node and the evaluation of the move is not too high. the maximum difference is defined in the configuration\n    as QUIZ_ACCEPT_EVAL_DIFF. if the move is a move from a relaxed source, the maximum difference is defined in the\n    configuration as QUIZ_ACCEPT_EVAL_DIFF_RELAXED. a source is relaxed if it is contained in the list\n    QUIZ_ACCEPT_RELAXED_SOURCES in configuration.\n    TODO: move this method in a different module.\n\n    Args:\n        move (Move): move to check\n\n    Returns:\n        bool: True if the move is acceptable, False otherwise\n    \"\"\"\n    if move.eval_depth() &lt; 0:\n        return False\n    eval_diff_accept = QUIZ_ACCEPT_EVAL_DIFF\n    if move.source in QUIZ_ACCEPT_RELAXED_SOURCES:\n        eval_diff_accept = QUIZ_ACCEPT_EVAL_DIFF_RELAXED\n    # check turn player\n    eval_best = self.eval\n    if self.eval_depth &lt; 0:\n        best_move = self.get_best_move()\n        if best_move != None:\n            if best_move.eval_depth() &gt; 0:\n                eval_best = best_move.eval()\n        else:\n            return True\n    if self.is_white_turn():\n        return eval_best - move.eval() &lt;= eval_diff_accept\n    else:\n        return move.eval() - eval_best &lt;= eval_diff_accept\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.is_white_turn","title":"<code>is_white_turn()</code>","text":"<p>checks whether it is white's turn in the node.  TODO: decide if this method should be more efficient. Every time this method is called the fen of the node is split. Instead this could be a simple bool that is set on init.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if it is white's turn in the node, False otherwise</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def is_white_turn(self) -&gt; bool:\n    \"\"\" checks whether it is white's turn in the node. \n    TODO: decide if this method should be more efficient. Every time this method is called the fen of the node is split. Instead this could be a simple bool that is set on __init__.\n\n    Returns:\n        bool: True if it is white's turn in the node, False otherwise\n    \"\"\"\n    return self.state.split(\" \")[1] == \"w\"\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.knows_move","title":"<code>knows_move(move)</code>","text":"<p>checks whether the node knows the given move</p> <p>Parameters:</p> Name Type Description Default <code>move</code> <code>Move</code> <p>move to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the node knows the move, False otherwise</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def knows_move(self, move: Move) -&gt; bool:\n    \"\"\" checks whether the node knows the given move\n\n    Args:\n        move (Move): move to check\n\n    Returns:\n        bool: True if the node knows the move, False otherwise\n    \"\"\"\n    return self.get_equivalent_move(move) != None\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.random_move","title":"<code>random_move(random, use_frequency=False)</code>","text":"<p>returns a random move of the node. if use_frequency is True, the probability of a move to be chosen is proportional to the frequency of the move. if use_frequency is False, all moves have the same probability. TODO: move this method in a different module.</p> <p>Parameters:</p> Name Type Description Default <code>random</code> <code>Random</code> <p>description</p> required <code>use_frequency</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>description</p> <p>Returns:</p> Name Type Description <code>Move</code> <code>Move</code> <p>description</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def random_move(self, random: Random, use_frequency: bool = False) -&gt; Move:\n    \"\"\" returns a random move of the node. if use_frequency is True, the probability of a move to be chosen is\n    proportional to the frequency of the move. if use_frequency is False, all moves have the same probability.\n    TODO: move this method in a different module.\n\n    Args:\n        random (Random): _description_\n        use_frequency (bool, optional): _description_. Defaults to False.\n\n    Raises:\n        Exception: _description_\n\n    Returns:\n        Move: _description_\n    \"\"\"\n    if not use_frequency:\n        return self.moves[random.randint(0, len(self.moves) - 1)]\n    chosen_move = None\n    total = self.total_frequency()\n    sum = 0\n    target = random.randint(0, total - 1)\n    for move in self.moves:\n        if sum + move.frequency &gt; target:\n            chosen_move = move\n            break\n        sum += move.frequency\n    if chosen_move == None:\n        raise Exception(\n            \"cannot chose a move. check frequencies of the moves of node \" + self.state)\n    return chosen_move\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.source","title":"<code>source()</code>","text":"<p>returns the source of the node. the source is the highest source of all moves of the node.</p> <p>Returns:</p> Name Type Description <code>SourceType</code> <code>SourceType</code> <p>the source of the node</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def source(self) -&gt; SourceType:\n    \"\"\" returns the source of the node. the source is the highest source of all moves of the node.\n\n    Returns:\n        SourceType: the source of the node\n    \"\"\"\n    source = SourceType.ENGINE_SYNTHETIC\n    for backlink in self.backlinks:\n        if backlink.move.source.value &gt; source.value:\n            source = backlink.move.source\n    return source\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.total_frequency","title":"<code>total_frequency()</code>","text":"<p>returns the total frequency of all moves of the node (the sum of the frequencies of all moves)</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the total frequency of all moves of the node</p> Source code in <code>chessapp\\model\\node.py</code> <pre><code>def total_frequency(self) -&gt; int:\n    \"\"\" returns the total frequency of all moves of the node (the sum of the frequencies of all moves)\n\n    Returns:\n        int: the total frequency of all moves of the node\n    \"\"\"\n    sum: int = 0\n    for move in self.moves:\n        sum += move.frequency\n    return sum\n</code></pre>"},{"location":"chessapp/model/node/#chessapp.model.node.Node.update","title":"<code>update(eval, eval_depth, is_mate)</code>","text":"<p>updates the evaluation of this node if the given evaluation depth is deeper than the current one or if the new evaluation is a mate and the current evaluation is not a mate</p> <p>Parameters:</p> Name Type Description Default <code>eval</code> <code>float</code> <p>evaluation of the position</p> required <code>eval_depth</code> <code>int</code> <p>depth of the evaluation</p> required <code>is_mate</code> <code>bool</code> <p>whether the position is a mate position or not</p> required Source code in <code>chessapp\\model\\node.py</code> <pre><code>def update(self, eval: float, eval_depth: int, is_mate: bool):\n    \"\"\" updates the evaluation of this node if the given evaluation depth is deeper than the current one or\n    if the new evaluation is a mate and the current evaluation is not a mate\n\n    Args:\n        eval (float): evaluation of the position\n        eval_depth (int): depth of the evaluation\n        is_mate (bool): whether the position is a mate position or not\n    \"\"\"\n    if eval_depth &gt; self.eval_depth or (not self.is_mate and is_mate):\n        self.eval_depth = eval_depth\n        self.eval = eval\n        self.is_mate = is_mate\n</code></pre>"},{"location":"chessapp/model/node/#source","title":"Source","text":"<pre><code>from chessapp.model.move import Move\nfrom chessapp.model.sourcetype import SourceType\nfrom random import Random\nfrom chessapp.configuration import QUIZ_ACCEPT_EVAL_DIFF, QUIZ_ACCEPT_EVAL_DIFF_RELAXED, QUIZ_ACCEPT_RELAXED_SOURCES\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Backlink:\n    \"\"\" A backlink links a node A to a previous node B such that playing the move in B leads to A.\n    \"\"\"\n    node: object\n    move: Move\n\n\nclass Node:\n    \"\"\" A node represents a position in the chess tree. It contains the following information:\n    - state: the fen of the position\n    - eval: the evaluation of the position\n    - eval_depth: the depth of the evaluation\n    - is_mate: whether the position is a mate position or not\n    - moves: the known moves of the position\n    - backlinks: the links pointing to the known nodes leading to this node\n    \"\"\"\n\n    def __init__(self, tree, fen: str, eval: float = 0, eval_depth: int = -1, is_mate: bool = False):\n        \"\"\" creates a new node with the given fen\n\n        Args:\n            tree (ChessTree): the tree in which this node is contained\n            fen (str): fen of the position\n            eval (float, optional): evaluation of the position\n            eval_depth (int, optional): depth of the evaluation\n            is_mate (bool, optional): whether the position is a mate position or not\n        \"\"\"\n        self.tree = tree\n        self.state: str = fen\n        self.moves = []\n        self.backlinks = []\n        self.eval: float = eval\n        self.eval_depth: float = eval_depth\n        self.is_mate: bool = is_mate\n\n    def update(self, eval: float, eval_depth: int, is_mate: bool):\n        \"\"\" updates the evaluation of this node if the given evaluation depth is deeper than the current one or\n        if the new evaluation is a mate and the current evaluation is not a mate\n\n        Args:\n            eval (float): evaluation of the position\n            eval_depth (int): depth of the evaluation\n            is_mate (bool): whether the position is a mate position or not\n        \"\"\"\n        if eval_depth &gt; self.eval_depth or (not self.is_mate and is_mate):\n            self.eval_depth = eval_depth\n            self.eval = eval\n            self.is_mate = is_mate\n\n    def add(self, move: Move):\n        \"\"\" adds a move to the node. if the move is already known, the source and the comment are updated if applicable\n\n        Args:\n            move (Move): _description_\n        \"\"\"\n        for m in self.moves:\n            if m.is_equivalent_to(move):\n                if m.source.value &lt; move.source.value:\n                    m.source = move.source\n                if move.comment and not m.comment:\n                    m.comment = move.comment\n                return\n        self.moves.append(move)\n        self.tree.get(move.result).backlink(self, move)\n\n    def backlink(self, node, move: Move):\n        \"\"\" adds a backlink to the node.\n        TODO: this is kinda ugly. the backlink should be added to the node when the move is added to the node. Should Move know the fen of the positon it is played in?&gt;\n\n        Args:\n            node (Node): previous node\n            move (Move): move that leads from the previous node to this node\n        \"\"\"\n        self.backlinks.append(Backlink(node, move))\n\n    def knows_move(self, move: Move) -&gt; bool:\n        \"\"\" checks whether the node knows the given move\n\n        Args:\n            move (Move): move to check\n\n        Returns:\n            bool: True if the node knows the move, False otherwise\n        \"\"\"\n        return self.get_equivalent_move(move) != None\n\n    def get_equivalent_move(self, move: Move) -&gt; Move | None:\n        \"\"\" returns the equivalent move if the node knows the given move, None otherwise\n\n        Args:\n            move (Move): move to check\n\n        Returns:\n            Move | None: the equivalent move if the node knows the given move, None otherwise\n        \"\"\"\n        for m in self.moves:\n            if m.is_equivalent_to(move):\n                return m\n        return None\n\n    def has_move(self) -&gt; bool:\n        \"\"\" checks whether the node knows at least one move\n\n        Returns:\n            bool: True if the node knows at least one move, False otherwise\n        \"\"\"\n        return len(self.moves) != 0\n\n    def total_frequency(self) -&gt; int:\n        \"\"\" returns the total frequency of all moves of the node (the sum of the frequencies of all moves)\n\n        Returns:\n            int: the total frequency of all moves of the node\n        \"\"\"\n        sum: int = 0\n        for move in self.moves:\n            sum += move.frequency\n        return sum\n\n    def has_frequency(self) -&gt; bool:\n        \"\"\" checks whether the node has at least one move with a frequency &gt; 0\n\n        Returns:\n            bool: True if the node has at least one move with a frequency &gt; 0, False otherwise\n        \"\"\"\n        return self.total_frequency() &gt; 0\n\n    def random_move(self, random: Random, use_frequency: bool = False) -&gt; Move:\n        \"\"\" returns a random move of the node. if use_frequency is True, the probability of a move to be chosen is\n        proportional to the frequency of the move. if use_frequency is False, all moves have the same probability.\n        TODO: move this method in a different module.\n\n        Args:\n            random (Random): _description_\n            use_frequency (bool, optional): _description_. Defaults to False.\n\n        Raises:\n            Exception: _description_\n\n        Returns:\n            Move: _description_\n        \"\"\"\n        if not use_frequency:\n            return self.moves[random.randint(0, len(self.moves) - 1)]\n        chosen_move = None\n        total = self.total_frequency()\n        sum = 0\n        target = random.randint(0, total - 1)\n        for move in self.moves:\n            if sum + move.frequency &gt; target:\n                chosen_move = move\n                break\n            sum += move.frequency\n        if chosen_move == None:\n            raise Exception(\n                \"cannot chose a move. check frequencies of the moves of node \" + self.state)\n        return chosen_move\n\n    def is_white_turn(self) -&gt; bool:\n        \"\"\" checks whether it is white's turn in the node. \n        TODO: decide if this method should be more efficient. Every time this method is called the fen of the node is split. Instead this could be a simple bool that is set on __init__.\n\n        Returns:\n            bool: True if it is white's turn in the node, False otherwise\n        \"\"\"\n        return self.state.split(\" \")[1] == \"w\"\n\n    def get_cp_loss(self, move: Move) -&gt; int:\n        \"\"\" returns the centipawn loss of the given move. the centipawn loss is the difference between the evaluation\n        of the node and the evaluation of the node that results from playing the specified move.\n        TODO: figure out if this method has to be moved to a different module.\n\n        Args:\n            move (Move): move to check\n\n        Returns:\n            int: the centipawn loss of the given move\n        \"\"\"\n        return round(abs(self.eval - move.eval()) * 100)\n\n    def get_move_by_san(self, move_san: str) -&gt; Move | None:\n        \"\"\" returns the move with the given san if the node knows the move, None otherwise\n\n        Args:\n            move_san (str): san of the move to get\n\n        Returns:\n            Move | None: the move with the given san if the node knows the move, None otherwise\n        \"\"\"\n        for move in self.moves:\n            if move.san == move_san:\n                return move\n        return None\n\n    def is_acceptable_move(self, move: Move) -&gt; bool:\n        \"\"\" checks whether the given move is acceptable. a move is acceptable if the difference between the evaluation\n        of the node and the evaluation of the move is not too high. the maximum difference is defined in the configuration\n        as QUIZ_ACCEPT_EVAL_DIFF. if the move is a move from a relaxed source, the maximum difference is defined in the\n        configuration as QUIZ_ACCEPT_EVAL_DIFF_RELAXED. a source is relaxed if it is contained in the list\n        QUIZ_ACCEPT_RELAXED_SOURCES in configuration.\n        TODO: move this method in a different module.\n\n        Args:\n            move (Move): move to check\n\n        Returns:\n            bool: True if the move is acceptable, False otherwise\n        \"\"\"\n        if move.eval_depth() &lt; 0:\n            return False\n        eval_diff_accept = QUIZ_ACCEPT_EVAL_DIFF\n        if move.source in QUIZ_ACCEPT_RELAXED_SOURCES:\n            eval_diff_accept = QUIZ_ACCEPT_EVAL_DIFF_RELAXED\n        # check turn player\n        eval_best = self.eval\n        if self.eval_depth &lt; 0:\n            best_move = self.get_best_move()\n            if best_move != None:\n                if best_move.eval_depth() &gt; 0:\n                    eval_best = best_move.eval()\n            else:\n                return True\n        if self.is_white_turn():\n            return eval_best - move.eval() &lt;= eval_diff_accept\n        else:\n            return move.eval() - eval_best &lt;= eval_diff_accept\n\n    def has_acceptable_move(self) -&gt; bool:\n        \"\"\" checks whether the node has at least one acceptable move. @see is_acceptable_move.\n        TODO: move this method in a different module.\n\n        Returns:\n            bool: True if the node has at least one acceptable move, False otherwise\n        \"\"\"\n        for move in self.moves:\n            if self.is_acceptable_move(move):\n                return True\n        return False\n\n    def get_best_move(self, min_depth: int = 0) -&gt; Move | None:\n        \"\"\" returns the best move of the node. the best move is the move with the highest evaluation value amongst\n        the moves with highest depth. if there is no move with at least a depth of min_depth, None is returned.\n\n\n        Args:\n            min_depth (int, optional): the minimum depth of the move to be returned.\n\n        Returns:\n            Move | None: the best move of the node\n        \"\"\"\n        if len(self.moves) == 0:\n            return None\n        best_move = None\n        # first search for a node as a baseline that has at least a depth of min_depth\n        for move in self.moves:\n            if not best_move or move.eval_depth() &gt; best_move.eval_depth():\n                best_move = move\n        if not best_move:\n            return None\n        is_white_turn = self.is_white_turn()\n        # now find a move that not only satisfies with depth min_depth but also has a better eval value\n        for move in self.moves:\n            if move.eval_depth() &gt;= min_depth:\n                if is_white_turn:\n                    if move.eval() &gt; best_move.eval():\n                        best_move = move\n                else:\n                    if move.eval() &lt; best_move.eval():\n                        best_move = move\n        return best_move\n\n    def source(self) -&gt; SourceType:\n        \"\"\" returns the source of the node. the source is the highest source of all moves of the node.\n\n        Returns:\n            SourceType: the source of the node\n        \"\"\"\n        source = SourceType.ENGINE_SYNTHETIC\n        for backlink in self.backlinks:\n            if backlink.move.source.value &gt; source.value:\n                source = backlink.move.source\n        return source\n</code></pre>"},{"location":"chessapp/model/sourcetype/","title":"sourcetype","text":""},{"location":"chessapp/model/sourcetype/#chessapp.model.sourcetype.SourceType","title":"<code>chessapp.model.sourcetype.SourceType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>represents the type of sources a move or node can have. This is meant as an annotation to hint at the quality of the move or node. For example a move that was played in a GM game is more likely to be a good move than a move that was played in an amateur game. This can be used to prioritize moves in the quiz or to filter moves in the explorer. Also analsying moves of a high quality in high depth might be more useful than analysing low quality moves in low depth (for example blundering a queen usually is not worth while except very rare cases that are sometimes seen by GMs). The source types are ordered by quality ascending.</p> Source code in <code>chessapp\\model\\sourcetype.py</code> <pre><code>class SourceType(Enum):\n    \"\"\" represents the type of sources a move or node can have. This is meant as an annotation to hint at the quality of the move or node.\n    For example a move that was played in a GM game is more likely to be a good move than a move that was played in an amateur game. This\n    can be used to prioritize moves in the quiz or to filter moves in the explorer. Also analsying moves of a high quality in high depth\n    might be more useful than analysing low quality moves in low depth (for example blundering a queen usually is not worth while except\n    very rare cases that are sometimes seen by GMs). The source types are ordered by quality ascending.\n    \"\"\"\n\n    UNKNOWN = -3  # default value\n    ENGINE_SYNTHETIC = -2  # created by an engine\n    QUIZ_EXPLORATION = -1  # explored move during quiz\n    MANUAL_EXPLORATION = 0  # explored move in explorer\n    MANUAL = 1  # manually curated moves\n    AMATEUR_GAME = 2  # online or otb\n    INTERMEDIATE_GAME = 3  # online or otb\n    PROFESSIONAL_GAME = 4  # otb\n    MASTER_GAME = 5  # online or otb\n    GM_GAME = 6  # otb\n    THEORY_VIDEO = 7  # videos about opening theory\n    COURSE = 8  # opening course\n    BOOK = 9  # opening book\n\n    @staticmethod\n    def default_value():\n        \"\"\" returns the default value for a source type\n\n        Returns:\n            SourceType: the default value\n        \"\"\"\n        return SourceType.UNKNOWN\n\n    def sformat(self) -&gt; str:\n        \"\"\" saveable format of the source type\n\n        Returns:\n            _str_: the saveable format\n        \"\"\"\n        return str(self)[len(\"SourceType.\"):]\n\n    @staticmethod\n    def from_str(s: str):\n        \"\"\" creates a source type from a string in saveable format (@see sformat)\n\n        Args:\n            s (str): the string\n\n        Raises:\n            Exception: if the string is not a valid source type\n\n        Returns:\n            SourceType: the source type\n        \"\"\"\n        match s:\n            case \"ENGINE_SYNTHETIC\":\n                return SourceType.ENGINE_SYNTHETIC\n            case \"MANUAL\":\n                return SourceType.MANUAL\n            case \"AMATEUR_GAME\":\n                return SourceType.AMATEUR_GAME\n            case \"INTERMEDIATE_GAME\":\n                return SourceType.INTERMEDIATE_GAME\n            case \"PROFESSIONAL_GAME\":\n                return SourceType.PROFESSIONAL_GAME\n            case \"GM_GAME\":\n                return SourceType.GM_GAME\n            case \"THEORY_VIDEO\":\n                return SourceType.THEORY_VIDEO\n            case \"COURSE\":\n                return SourceType.COURSE\n            case \"BOOK\":\n                return SourceType.BOOK\n            case \"MASTER_GAME\":\n                return SourceType.MASTER_GAME\n            case \"QUIZ_EXPLORATION\":\n                return SourceType.QUIZ_EXPLORATION\n            case \"MANUAL_EXPLORATION\":\n                return SourceType.MANUAL_EXPLORATION\n            case \"UNKNOWN\":\n                return SourceType.UNKNOWN\n            case _:\n                raise Exception(\"source \\\"\" + s + \"\\\" not found\")\n</code></pre>"},{"location":"chessapp/model/sourcetype/#chessapp.model.sourcetype.SourceType.default_value","title":"<code>default_value()</code>  <code>staticmethod</code>","text":"<p>returns the default value for a source type</p> <p>Returns:</p> Name Type Description <code>SourceType</code> <p>the default value</p> Source code in <code>chessapp\\model\\sourcetype.py</code> <pre><code>@staticmethod\ndef default_value():\n    \"\"\" returns the default value for a source type\n\n    Returns:\n        SourceType: the default value\n    \"\"\"\n    return SourceType.UNKNOWN\n</code></pre>"},{"location":"chessapp/model/sourcetype/#chessapp.model.sourcetype.SourceType.from_str","title":"<code>from_str(s)</code>  <code>staticmethod</code>","text":"<p>creates a source type from a string in saveable format (@see sformat)</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the string</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if the string is not a valid source type</p> <p>Returns:</p> Name Type Description <code>SourceType</code> <p>the source type</p> Source code in <code>chessapp\\model\\sourcetype.py</code> <pre><code>@staticmethod\ndef from_str(s: str):\n    \"\"\" creates a source type from a string in saveable format (@see sformat)\n\n    Args:\n        s (str): the string\n\n    Raises:\n        Exception: if the string is not a valid source type\n\n    Returns:\n        SourceType: the source type\n    \"\"\"\n    match s:\n        case \"ENGINE_SYNTHETIC\":\n            return SourceType.ENGINE_SYNTHETIC\n        case \"MANUAL\":\n            return SourceType.MANUAL\n        case \"AMATEUR_GAME\":\n            return SourceType.AMATEUR_GAME\n        case \"INTERMEDIATE_GAME\":\n            return SourceType.INTERMEDIATE_GAME\n        case \"PROFESSIONAL_GAME\":\n            return SourceType.PROFESSIONAL_GAME\n        case \"GM_GAME\":\n            return SourceType.GM_GAME\n        case \"THEORY_VIDEO\":\n            return SourceType.THEORY_VIDEO\n        case \"COURSE\":\n            return SourceType.COURSE\n        case \"BOOK\":\n            return SourceType.BOOK\n        case \"MASTER_GAME\":\n            return SourceType.MASTER_GAME\n        case \"QUIZ_EXPLORATION\":\n            return SourceType.QUIZ_EXPLORATION\n        case \"MANUAL_EXPLORATION\":\n            return SourceType.MANUAL_EXPLORATION\n        case \"UNKNOWN\":\n            return SourceType.UNKNOWN\n        case _:\n            raise Exception(\"source \\\"\" + s + \"\\\" not found\")\n</code></pre>"},{"location":"chessapp/model/sourcetype/#chessapp.model.sourcetype.SourceType.sformat","title":"<code>sformat()</code>","text":"<p>saveable format of the source type</p> <p>Returns:</p> Name Type Description <code>_str_</code> <code>str</code> <p>the saveable format</p> Source code in <code>chessapp\\model\\sourcetype.py</code> <pre><code>def sformat(self) -&gt; str:\n    \"\"\" saveable format of the source type\n\n    Returns:\n        _str_: the saveable format\n    \"\"\"\n    return str(self)[len(\"SourceType.\"):]\n</code></pre>"},{"location":"chessapp/model/sourcetype/#source","title":"Source","text":"<pre><code>from enum import Enum\n\n\nclass SourceType(Enum):\n    \"\"\" represents the type of sources a move or node can have. This is meant as an annotation to hint at the quality of the move or node.\n    For example a move that was played in a GM game is more likely to be a good move than a move that was played in an amateur game. This\n    can be used to prioritize moves in the quiz or to filter moves in the explorer. Also analsying moves of a high quality in high depth\n    might be more useful than analysing low quality moves in low depth (for example blundering a queen usually is not worth while except\n    very rare cases that are sometimes seen by GMs). The source types are ordered by quality ascending.\n    \"\"\"\n\n    UNKNOWN = -3  # default value\n    ENGINE_SYNTHETIC = -2  # created by an engine\n    QUIZ_EXPLORATION = -1  # explored move during quiz\n    MANUAL_EXPLORATION = 0  # explored move in explorer\n    MANUAL = 1  # manually curated moves\n    AMATEUR_GAME = 2  # online or otb\n    INTERMEDIATE_GAME = 3  # online or otb\n    PROFESSIONAL_GAME = 4  # otb\n    MASTER_GAME = 5  # online or otb\n    GM_GAME = 6  # otb\n    THEORY_VIDEO = 7  # videos about opening theory\n    COURSE = 8  # opening course\n    BOOK = 9  # opening book\n\n    @staticmethod\n    def default_value():\n        \"\"\" returns the default value for a source type\n\n        Returns:\n            SourceType: the default value\n        \"\"\"\n        return SourceType.UNKNOWN\n\n    def sformat(self) -&gt; str:\n        \"\"\" saveable format of the source type\n\n        Returns:\n            _str_: the saveable format\n        \"\"\"\n        return str(self)[len(\"SourceType.\"):]\n\n    @staticmethod\n    def from_str(s: str):\n        \"\"\" creates a source type from a string in saveable format (@see sformat)\n\n        Args:\n            s (str): the string\n\n        Raises:\n            Exception: if the string is not a valid source type\n\n        Returns:\n            SourceType: the source type\n        \"\"\"\n        match s:\n            case \"ENGINE_SYNTHETIC\":\n                return SourceType.ENGINE_SYNTHETIC\n            case \"MANUAL\":\n                return SourceType.MANUAL\n            case \"AMATEUR_GAME\":\n                return SourceType.AMATEUR_GAME\n            case \"INTERMEDIATE_GAME\":\n                return SourceType.INTERMEDIATE_GAME\n            case \"PROFESSIONAL_GAME\":\n                return SourceType.PROFESSIONAL_GAME\n            case \"GM_GAME\":\n                return SourceType.GM_GAME\n            case \"THEORY_VIDEO\":\n                return SourceType.THEORY_VIDEO\n            case \"COURSE\":\n                return SourceType.COURSE\n            case \"BOOK\":\n                return SourceType.BOOK\n            case \"MASTER_GAME\":\n                return SourceType.MASTER_GAME\n            case \"QUIZ_EXPLORATION\":\n                return SourceType.QUIZ_EXPLORATION\n            case \"MANUAL_EXPLORATION\":\n                return SourceType.MANUAL_EXPLORATION\n            case \"UNKNOWN\":\n                return SourceType.UNKNOWN\n            case _:\n                raise Exception(\"source \\\"\" + s + \"\\\" not found\")\n</code></pre>"},{"location":"chessapp/sound/","title":"Sound","text":"<p>This package provides interfaces to load and play sound effects.</p>"},{"location":"chessapp/sound/chessboardsound/","title":"chessboardsound","text":""},{"location":"chessapp/sound/chessboardsound/#chessapp.sound.chessboardsound.SoundAttributes","title":"<code>chessapp.sound.chessboardsound.SoundAttributes</code>  <code>dataclass</code>","text":"<p>this class is used to store the file name and the sound object associated with a sound.</p> Source code in <code>chessapp\\sound\\chessboardsound.py</code> <pre><code>@dataclass\nclass SoundAttributes:\n    \"\"\" this class is used to store the file name and the sound object associated with a sound.\n    \"\"\"\n    file_name: str\n    sound: QSound = None\n</code></pre>"},{"location":"chessapp/sound/chessboardsound/#chessapp.sound.chessboardsound.ChessboardSound","title":"<code>chessapp.sound.chessboardsound.ChessboardSound</code>","text":"<p>             Bases: <code>Enum</code></p> <p>this class enables the use of typical sounds in a chess game associated with actions on a chessboard. Refer to  Stackoverflow: How to define custom properties in enumeration in Python and  Stackoverflow: Play Sound File in PyQt for more information on the methods used in this implementation.</p> Source code in <code>chessapp\\sound\\chessboardsound.py</code> <pre><code>class ChessboardSound(Enum):\n    \"\"\" this class enables the use of typical sounds in a chess game associated with actions on a chessboard. Refer to \n    [Stackoverflow: How to define custom properties in enumeration in Python](https://stackoverflow.com/questions/35567724/how-to-define-custom-properties-in-enumeration-in-python-javascript-like) and \n    [Stackoverflow: Play Sound File in PyQt](https://stackoverflow.com/questions/9861592/play-sound-file-in-pyqt)\n    for more information on the methods used in this implementation.\n    \"\"\"\n\n    CAPTURE_PIECE = SoundAttributes(\"capture.wav\")\n    MOVE_CHECK = SoundAttributes(\"move-check.wav\")\n    MOVE_OPPONENT = SoundAttributes(\"move-opponent.wav\")\n    MOVE_SELF = SoundAttributes(\"move-self.wav\")\n    MOVE_ILLEGAL = SoundAttributes(\"illegal.wav\")\n    GAME_START = SoundAttributes(\"game-start.wav\")\n    GAME_END = SoundAttributes(\"game-end.wav\")\n    RESULT_BAD = SoundAttributes(\"result-bad-2-15.wav\")\n    MOVE_CASTLE = SoundAttributes(\"castle.wav\")\n\n    def register(self):\n        \"\"\" This method tries to load the sound file associated with the enumeration value.\n        \"\"\"\n        self.value.sound = QSound(\n            join(get_audio_folder(), \"chessboard\", self.value.file_name))\n\n    def play(self):\n        \"\"\" plays the sound (if it was loaded successfully)\n        \"\"\"\n        if self.value.sound:\n            self.value.sound.play()\n</code></pre>"},{"location":"chessapp/sound/chessboardsound/#chessapp.sound.chessboardsound.ChessboardSound.play","title":"<code>play()</code>","text":"<p>plays the sound (if it was loaded successfully)</p> Source code in <code>chessapp\\sound\\chessboardsound.py</code> <pre><code>def play(self):\n    \"\"\" plays the sound (if it was loaded successfully)\n    \"\"\"\n    if self.value.sound:\n        self.value.sound.play()\n</code></pre>"},{"location":"chessapp/sound/chessboardsound/#chessapp.sound.chessboardsound.ChessboardSound.register","title":"<code>register()</code>","text":"<p>This method tries to load the sound file associated with the enumeration value.</p> Source code in <code>chessapp\\sound\\chessboardsound.py</code> <pre><code>def register(self):\n    \"\"\" This method tries to load the sound file associated with the enumeration value.\n    \"\"\"\n    self.value.sound = QSound(\n        join(get_audio_folder(), \"chessboard\", self.value.file_name))\n</code></pre>"},{"location":"chessapp/sound/chessboardsound/#source","title":"Source","text":"<pre><code>from dataclasses import dataclass\nfrom enum import Enum\nfrom PyQt5.QtMultimedia import QSound\nfrom chessapp.util.paths import get_audio_folder\nfrom os.path import join\n\n\n@dataclass\nclass SoundAttributes:\n    \"\"\" this class is used to store the file name and the sound object associated with a sound.\n    \"\"\"\n    file_name: str\n    sound: QSound = None\n\n\nclass ChessboardSound(Enum):\n    \"\"\" this class enables the use of typical sounds in a chess game associated with actions on a chessboard. Refer to \n    [Stackoverflow: How to define custom properties in enumeration in Python](https://stackoverflow.com/questions/35567724/how-to-define-custom-properties-in-enumeration-in-python-javascript-like) and \n    [Stackoverflow: Play Sound File in PyQt](https://stackoverflow.com/questions/9861592/play-sound-file-in-pyqt)\n    for more information on the methods used in this implementation.\n    \"\"\"\n\n    CAPTURE_PIECE = SoundAttributes(\"capture.wav\")\n    MOVE_CHECK = SoundAttributes(\"move-check.wav\")\n    MOVE_OPPONENT = SoundAttributes(\"move-opponent.wav\")\n    MOVE_SELF = SoundAttributes(\"move-self.wav\")\n    MOVE_ILLEGAL = SoundAttributes(\"illegal.wav\")\n    GAME_START = SoundAttributes(\"game-start.wav\")\n    GAME_END = SoundAttributes(\"game-end.wav\")\n    RESULT_BAD = SoundAttributes(\"result-bad-2-15.wav\")\n    MOVE_CASTLE = SoundAttributes(\"castle.wav\")\n\n    def register(self):\n        \"\"\" This method tries to load the sound file associated with the enumeration value.\n        \"\"\"\n        self.value.sound = QSound(\n            join(get_audio_folder(), \"chessboard\", self.value.file_name))\n\n    def play(self):\n        \"\"\" plays the sound (if it was loaded successfully)\n        \"\"\"\n        if self.value.sound:\n            self.value.sound.play()\n\n\ndef register_all_sounds():\n    \"\"\" call this method at some point before using the sounds in the application. This should be called by the main\n    application during startup. \n    \"\"\"\n    for sound in ChessboardSound:\n        sound.register()\n</code></pre>"},{"location":"chessapp/util/","title":"Util","text":"<p>This package provides utility classes that are used by multiple other modules.</p>"},{"location":"chessapp/util/fen/","title":"fen","text":""},{"location":"chessapp/util/fen/#source","title":"Source","text":"<pre><code>from chess import Board\n\n\ndef reduce_fen(fen: str) -&gt; str:\n    \"\"\" removes the last two parts of the fen string (halfmove clock and fullmove number)\n\n    Args:\n        fen (str): fen string\n\n    Returns:\n        str: fen string without the last two parts\n    \"\"\"\n    fen_arr = fen.split(\" \")\n    del fen_arr[-1]\n    del fen_arr[-1]\n    return \" \".join(fen_arr)\n\n\ndef get_reduced_fen_from_board(board: Board) -&gt; str:\n    \"\"\" returns the reduced fen string of a board\n\n    Args:\n        board (Board): the board\n\n    Returns:\n        str: the reduced fen string\n    \"\"\"\n    return reduce_fen(board.fen())\n</code></pre>"},{"location":"chessapp/util/font/","title":"font","text":""},{"location":"chessapp/util/font/#source","title":"Source","text":"<pre><code>from PyQt5.QtGui import QFont, QFontMetrics, QPainter\nfrom PyQt5.QtCore import QRect, QSize\n\ns_min_font_size = 2\ns_max_font_size = 100\n\n\ndef find_font_size(bounding_box: QSize, text: str, qp: QPainter = None) -&gt; int:\n    \"\"\"finds the best font size for the given text and bounding box to fill the box with the given text. the minimum font size is\n    s_min_font_size and the maximum font size is s_max_font_size. the font size is returned as the maximum lower bound thats fits\n    the text inside the box (unless the text is too large for the box even with the minimum font size applied) then the minimum\n    font size is returned.\n\n    Args:\n        bounding_box (QSize): bounding box of the text\n        bounding_box (QPainter, optional): QPainter of the GUI. Defaults to None.\n        text (str): text to fit inside the bounding box\n\n    Returns:\n        the font size that fits the text inside the bounding box in PointSize\n    \"\"\"\n    if qp:\n        font = qp.font()\n    else:\n        font = QFont()\n    low = s_min_font_size\n    high = s_max_font_size\n    # binary search for the best font size\n    while high - low &gt; 1:\n        mid = (low + high) // 2\n        font.setPointSize(mid)\n        metrics = QFontMetrics(font)\n        bounding_font_rect: QRect = metrics.boundingRect(text)\n        if bounding_font_rect.width() &gt;= bounding_box.width() or bounding_font_rect.height() &gt;= bounding_box.height():\n            high = mid\n        else:\n            low = mid\n    return low\n</code></pre>"},{"location":"chessapp/util/paths/","title":"paths","text":""},{"location":"chessapp/util/paths/#source","title":"Source","text":"<pre><code>from pathlib import Path\nfrom os.path import join, exists\nfrom chessapp.configuration import ROOT_DIR, PIECES_IMAGES_FOLDER_NAME\n\n\ndef get_audio_folder() -&gt; Path:\n    \"\"\"path to the audio folder. audio files are used for sound effects.\n\n    Returns:\n        Path: path to the audio folder\n    \"\"\"\n    return join(get_assets_folder(), \"audio\")\n\n\ndef get_assets_folder() -&gt; Path:\n    \"\"\"path to the assets folder. assets are files that are not code, e.g. images, audio, etc.\n\n    Returns:\n        Path: path to the assets folder\n    \"\"\"\n    return join(ROOT_DIR, \"assets\")\n\n\ndef get_images_folder() -&gt; Path:\n    \"\"\"path to the folder that contains all images. images are used for the GUI.\n\n    Returns:\n        Path: path to the images folder\n    \"\"\"\n    return join(get_assets_folder(), \"img\")\n\n\ndef get_chess_pieces_folder() -&gt; Path:\n    \"\"\"path to the folder that contains all chess pieces using configuration.PIECES_IMAGES_FOLDER_NAME as subfolder in which the\n    image files of the pieces are contained.\n\n    Returns:\n        Path: path to the folder that contains all chess pieces\n    \"\"\"\n    return join(get_images_folder(), \"chessboard\", \"pieces\", PIECES_IMAGES_FOLDER_NAME)\n\n\ndef get_data_folder() -&gt; Path:\n    \"\"\"path to the data folder. data files are used for storing data, e.g. openings, puzzles, etc.\n\n    Returns:\n        Path: path to the data folder\n    \"\"\"\n    return join(ROOT_DIR, \"data\")\n\n\ndef get_openings_folder() -&gt; Path:\n    \"\"\"path to the openings folder. openings are used for the opening tree. the subfolders also contain a lot of pgn files which are the basis\n    for the opening tree.\n\n    Returns:\n        Path: path to the openings folder\n    \"\"\"\n    return join(get_data_folder(), \"openings\")\n\n\ndef get_opening_tree_folder() -&gt; Path:\n    \"\"\"the opening tree folder contains the opening tree of the opening tree module. @see chessapp.controller.openingtree\n\n    Returns:\n        Path: path to the opening tree folder\n    \"\"\"\n    return join(get_data_folder(), \"opening_tree\")\n\n\ndef get_stockfish_exe() -&gt; Path:\n    \"\"\"path to the stockfish executable file. stockfish is used for calculating the best move.\n\n    Returns:\n        Path: path to the stockfish executable file\n    \"\"\"\n    return join(ROOT_DIR, \"engine\", \"stockfish\", \"16\", \"stockfish-windows-x86-64-avx2.exe\")\n\n\ndef get_puzzles_folder() -&gt; Path:\n    \"\"\"path to the puzzles folder. puzzles are used for the puzzle module @see chessapp.controller.puzzles\n\n    Returns:\n        Path: path to the puzzles folder\n    \"\"\"\n    return join(get_data_folder(), \"puzzles\")\n\n\ndef assure_file(file_path: str | Path):\n    \"\"\" creates a file if it does not exist\n\n    Args:\n        file_path (str | Path): path to the file\n    \"\"\"\n    if not exists(file_path):\n        with open(file_path, 'w'):\n            pass\n</code></pre>"},{"location":"chessapp/util/pgn/","title":"pgn","text":""},{"location":"chessapp/util/pgn/#source","title":"Source","text":"<pre><code>def moves_to_pgn(moves, white_first_move: bool) -&gt; str:\n    \"\"\" this method converts a list of moves to a pgn string\n\n    Args:\n        moves ([str]): array of moves as strings\n        white_first_move (bool): whether the first move is a move of the player with the white pieces\n\n    Returns:\n        str: the pgn string\n    \"\"\"\n    pgn = \"\"\n    for i in range(0, len(moves)):\n        if (i % 2 == 0 and white_first_move) or (i % 2 != 0 and not white_first_move):\n            pgn += \" \" + str(i // 2 + 1) + \".\"\n        if i == 0 and not white_first_move:\n            pgn += \"..\"\n        pgn += \" \" + str(moves[i])\n    return pgn\n</code></pre>"},{"location":"chessapp/view/","title":"View","text":"<p>This module concerns itself with everything visible in the GUI e.g. handling QWidgets, drawing a chessboard, displaying data, etc.</p>"},{"location":"chessapp/view/appwindow/","title":"appwindow","text":""},{"location":"chessapp/view/appwindow/#chessapp.view.appwindow.StatusMessage","title":"<code>chessapp.view.appwindow.StatusMessage</code>","text":"<p>A message that can be shown in the status bar of the main window.</p> Source code in <code>chessapp\\view\\appwindow.py</code> <pre><code>class StatusMessage:\n    \"\"\"A message that can be shown in the status bar of the main window.\n    \"\"\"\n\n    def __init__(self, text: str, timeout_milliseconds: int = 2000):\n        \"\"\"A message that can be shown in the status bar of the main window.\n\n        Args:\n            text (str): the text of the message\n            timeout_milliseconds (int, optional): Defaults to 2000. the time in milliseconds after which the message will disappear again\n        \"\"\"\n        self.text = text\n        self.timeout_milliseconds = timeout_milliseconds\n</code></pre>"},{"location":"chessapp/view/appwindow/#chessapp.view.appwindow.StatusMessage.__init__","title":"<code>__init__(text, timeout_milliseconds=2000)</code>","text":"<p>A message that can be shown in the status bar of the main window.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the text of the message</p> required <code>timeout_milliseconds</code> <code>int</code> <p>Defaults to 2000. the time in milliseconds after which the message will disappear again</p> <code>2000</code> Source code in <code>chessapp\\view\\appwindow.py</code> <pre><code>def __init__(self, text: str, timeout_milliseconds: int = 2000):\n    \"\"\"A message that can be shown in the status bar of the main window.\n\n    Args:\n        text (str): the text of the message\n        timeout_milliseconds (int, optional): Defaults to 2000. the time in milliseconds after which the message will disappear again\n    \"\"\"\n    self.text = text\n    self.timeout_milliseconds = timeout_milliseconds\n</code></pre>"},{"location":"chessapp/view/appwindow/#chessapp.view.appwindow.AppWindow","title":"<code>chessapp.view.appwindow.AppWindow</code>","text":"<p>             Bases: <code>QMainWindow</code></p> <p>The main window of the application.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Chessapp</code> <p>the main application</p> required Source code in <code>chessapp\\view\\appwindow.py</code> <pre><code>class AppWindow(QMainWindow):\n    \"\"\"The main window of the application.\n\n    Args:\n        app (chessapp.chessapp.Chessapp): the main application\n    \"\"\"\n\n    status_message_shown = pyqtSignal(StatusMessage)\n\n    def __init__(self, app):\n        \"\"\"initializes the main window of the application\n\n        Args:\n            app (chessapp.chessapp.Chessapp): the main application\n        \"\"\"\n        super().__init__()\n        self.app = app\n        self.setWindowTitle(\"Chess App\")\n        self.init_status_bar()\n\n    def on_status_message_shown(self, status_message: StatusMessage):\n        \"\"\"forwards the status message to the status bar\n\n        Args:\n            status_message (StatusMessage): this message will be shown in the status bar\n        \"\"\"\n        self.status_bar.showMessage(\n            status_message.text, status_message.timeout_milliseconds)\n\n    def init_status_bar(self):\n        \"\"\"initializes the status bar on the lower part of the window to display short messages that are received with on_status_message_shown\n        \"\"\"\n        self.status_bar = self.statusBar()\n        self.status_message_shown.connect(self.on_status_message_shown)\n</code></pre>"},{"location":"chessapp/view/appwindow/#chessapp.view.appwindow.AppWindow.__init__","title":"<code>__init__(app)</code>","text":"<p>initializes the main window of the application</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Chessapp</code> <p>the main application</p> required Source code in <code>chessapp\\view\\appwindow.py</code> <pre><code>def __init__(self, app):\n    \"\"\"initializes the main window of the application\n\n    Args:\n        app (chessapp.chessapp.Chessapp): the main application\n    \"\"\"\n    super().__init__()\n    self.app = app\n    self.setWindowTitle(\"Chess App\")\n    self.init_status_bar()\n</code></pre>"},{"location":"chessapp/view/appwindow/#chessapp.view.appwindow.AppWindow.init_status_bar","title":"<code>init_status_bar()</code>","text":"<p>initializes the status bar on the lower part of the window to display short messages that are received with on_status_message_shown</p> Source code in <code>chessapp\\view\\appwindow.py</code> <pre><code>def init_status_bar(self):\n    \"\"\"initializes the status bar on the lower part of the window to display short messages that are received with on_status_message_shown\n    \"\"\"\n    self.status_bar = self.statusBar()\n    self.status_message_shown.connect(self.on_status_message_shown)\n</code></pre>"},{"location":"chessapp/view/appwindow/#chessapp.view.appwindow.AppWindow.on_status_message_shown","title":"<code>on_status_message_shown(status_message)</code>","text":"<p>forwards the status message to the status bar</p> <p>Parameters:</p> Name Type Description Default <code>status_message</code> <code>StatusMessage</code> <p>this message will be shown in the status bar</p> required Source code in <code>chessapp\\view\\appwindow.py</code> <pre><code>def on_status_message_shown(self, status_message: StatusMessage):\n    \"\"\"forwards the status message to the status bar\n\n    Args:\n        status_message (StatusMessage): this message will be shown in the status bar\n    \"\"\"\n    self.status_bar.showMessage(\n        status_message.text, status_message.timeout_milliseconds)\n</code></pre>"},{"location":"chessapp/view/appwindow/#source","title":"Source","text":"<pre><code>from PyQt5.QtWidgets import QMainWindow\nfrom PyQt5.QtCore import pyqtSignal\n\n\nclass StatusMessage:\n    \"\"\"A message that can be shown in the status bar of the main window.\n    \"\"\"\n\n    def __init__(self, text: str, timeout_milliseconds: int = 2000):\n        \"\"\"A message that can be shown in the status bar of the main window.\n\n        Args:\n            text (str): the text of the message\n            timeout_milliseconds (int, optional): Defaults to 2000. the time in milliseconds after which the message will disappear again\n        \"\"\"\n        self.text = text\n        self.timeout_milliseconds = timeout_milliseconds\n\n\nclass AppWindow(QMainWindow):\n    \"\"\"The main window of the application.\n\n    Args:\n        app (chessapp.chessapp.Chessapp): the main application\n    \"\"\"\n\n    status_message_shown = pyqtSignal(StatusMessage)\n\n    def __init__(self, app):\n        \"\"\"initializes the main window of the application\n\n        Args:\n            app (chessapp.chessapp.Chessapp): the main application\n        \"\"\"\n        super().__init__()\n        self.app = app\n        self.setWindowTitle(\"Chess App\")\n        self.init_status_bar()\n\n    def on_status_message_shown(self, status_message: StatusMessage):\n        \"\"\"forwards the status message to the status bar\n\n        Args:\n            status_message (StatusMessage): this message will be shown in the status bar\n        \"\"\"\n        self.status_bar.showMessage(\n            status_message.text, status_message.timeout_milliseconds)\n\n    def init_status_bar(self):\n        \"\"\"initializes the status bar on the lower part of the window to display short messages that are received with on_status_message_shown\n        \"\"\"\n        self.status_bar = self.statusBar()\n        self.status_message_shown.connect(self.on_status_message_shown)\n</code></pre>"},{"location":"chessapp/view/arrow/","title":"arrow","text":""},{"location":"chessapp/view/arrow/#chessapp.view.arrow.Arrow","title":"<code>chessapp.view.arrow.Arrow</code>","text":"<p>An arrow from source to destination point with a given width and color. The arrow can be indented and scaled.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>QPoint</code> <p>source point (root of the arrow)</p> <code>destination</code> <code>QPoint</code> <p>destination point (tip of the arrow)</p> <code>width</code> <code>int</code> <p>width of the arrow</p> <code>color</code> <code>QColor</code> <p>color of the arrow</p> <code>indentation</code> <code>float</code> <p>indentation of the arrow (0 = no indentation, 1 = full indentation). TODO: describe indentation</p> <code>arrow_head_length_scale</code> <code>float</code> <p>scale of the arrow head length (0 = no arrow head, 1 = full arrow head)</p> <code>arrow_head_width_scale</code> <code>float</code> <p>scale of the arrow head width (0 = no arrow head, 1 = full arrow head)</p> Source code in <code>chessapp\\view\\arrow.py</code> <pre><code>class Arrow:\n    \"\"\" An arrow from source to destination point with a given width and color. The arrow can be indented and scaled.\n\n    Attributes:\n        source (QPoint): source point (root of the arrow)\n        destination (QPoint): destination point (tip of the arrow)\n        width (int): width of the arrow\n        color (QColor): color of the arrow\n        indentation (float): indentation of the arrow (0 = no indentation, 1 = full indentation). TODO: describe indentation\n        arrow_head_length_scale (float): scale of the arrow head length (0 = no arrow head, 1 = full arrow head)\n        arrow_head_width_scale (float): scale of the arrow head width (0 = no arrow head, 1 = full arrow head)\n    \"\"\"\n\n    def __init__(self, source: QPoint, destination: QPoint):\n        \"\"\" initialize an arrow\n\n        Args:\n            source (QPoint): source point (root of the arrow)\n            destination (QPoint): destination point (tip of the arrow)\n        \"\"\"\n        self.source = source\n        self.destination = destination\n        self.width = 10\n        self.color = QColor(0, 0, 128, 64)\n        self.indentation: float = 0\n        self.arrow_head_length_scale: float = 1\n        self.arrow_head_width_scale: float = 1\n\n    def drawOn(self, qp: QPainter, bound: QRect, offset: QPointF):\n        \"\"\" draw the arrow on the given painter\n\n        Args:\n            qp (QPainter): the painter to draw on\n            bound (QRect): the bounding rectangle of the arrow\n            offset (QSize): the offset of the arrow\n        \"\"\"\n        head_width = self.width * 2 * max(0, self.arrow_head_width_scale)\n        sx: float = self.source.x() + bound.x() + offset.x()\n        sy: float = self.source.y() + bound.y() + offset.y()\n        s = QPointF(sx, sy)\n        dx: float = self.destination.x() + bound.x() + offset.x()\n        dy: float = self.destination.y() + bound.y() + offset.y()\n        d = QPointF(dx, dy)\n        vx: float = dx - sx\n        vy: float = dy - sy\n        length: float = sqrt(vx * vx + vy * vy)\n        if length &lt;= head_width:\n            return\n        if vx == 0:\n            ax = 1\n            ay = 0\n        else:\n            ax = vy / length\n            ay = -vx / length\n        normal_vector = QPointF(ax, ay)\n        direction_vector = QPointF(vx / length, vy / length)\n        p0 = s + normal_vector * self.width / 2\n        p6 = s - normal_vector * self.width / 2\n        head_length: float = min(\n            head_width * max(0, self.arrow_head_length_scale), 0.5 * length)\n        base_length: float = length - head_length\n        p1 = p0 + direction_vector * base_length\n        p5 = p6 + direction_vector * base_length\n        width_head_width_diff: float = head_width - self.width\n        p2 = p1 + normal_vector * width_head_width_diff\n        p7 = p5 - normal_vector * width_head_width_diff\n        # if there is an indentation\n        if self.indentation &gt; 0:\n            indentation_base_length = length + head_length * \\\n                (0.5 * max(0, min(1, self.indentation)) - 1)\n            p1 = p0 + direction_vector * indentation_base_length\n            p5 = p6 + direction_vector * indentation_base_length\n        path: QPainterPath = QPainterPath()\n        path.moveTo(s)  # center of base and source point\n        path.lineTo(p0)  # corner 1 of base\n        path.lineTo(p1)  # corner 1 of indentation\n        path.lineTo(p2)  # corner 1 of outer head\n        path.lineTo(d)  # destination point\n        path.lineTo(p7)  # corner 2 of outer head\n        path.lineTo(p5)  # corner 2 of indentation\n        path.lineTo(p6)  # corner 2 of base\n        qp.fillPath(path, self.color)\n</code></pre>"},{"location":"chessapp/view/arrow/#chessapp.view.arrow.Arrow.__init__","title":"<code>__init__(source, destination)</code>","text":"<p>initialize an arrow</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>QPoint</code> <p>source point (root of the arrow)</p> required <code>destination</code> <code>QPoint</code> <p>destination point (tip of the arrow)</p> required Source code in <code>chessapp\\view\\arrow.py</code> <pre><code>def __init__(self, source: QPoint, destination: QPoint):\n    \"\"\" initialize an arrow\n\n    Args:\n        source (QPoint): source point (root of the arrow)\n        destination (QPoint): destination point (tip of the arrow)\n    \"\"\"\n    self.source = source\n    self.destination = destination\n    self.width = 10\n    self.color = QColor(0, 0, 128, 64)\n    self.indentation: float = 0\n    self.arrow_head_length_scale: float = 1\n    self.arrow_head_width_scale: float = 1\n</code></pre>"},{"location":"chessapp/view/arrow/#chessapp.view.arrow.Arrow.drawOn","title":"<code>drawOn(qp, bound, offset)</code>","text":"<p>draw the arrow on the given painter</p> <p>Parameters:</p> Name Type Description Default <code>qp</code> <code>QPainter</code> <p>the painter to draw on</p> required <code>bound</code> <code>QRect</code> <p>the bounding rectangle of the arrow</p> required <code>offset</code> <code>QSize</code> <p>the offset of the arrow</p> required Source code in <code>chessapp\\view\\arrow.py</code> <pre><code>def drawOn(self, qp: QPainter, bound: QRect, offset: QPointF):\n    \"\"\" draw the arrow on the given painter\n\n    Args:\n        qp (QPainter): the painter to draw on\n        bound (QRect): the bounding rectangle of the arrow\n        offset (QSize): the offset of the arrow\n    \"\"\"\n    head_width = self.width * 2 * max(0, self.arrow_head_width_scale)\n    sx: float = self.source.x() + bound.x() + offset.x()\n    sy: float = self.source.y() + bound.y() + offset.y()\n    s = QPointF(sx, sy)\n    dx: float = self.destination.x() + bound.x() + offset.x()\n    dy: float = self.destination.y() + bound.y() + offset.y()\n    d = QPointF(dx, dy)\n    vx: float = dx - sx\n    vy: float = dy - sy\n    length: float = sqrt(vx * vx + vy * vy)\n    if length &lt;= head_width:\n        return\n    if vx == 0:\n        ax = 1\n        ay = 0\n    else:\n        ax = vy / length\n        ay = -vx / length\n    normal_vector = QPointF(ax, ay)\n    direction_vector = QPointF(vx / length, vy / length)\n    p0 = s + normal_vector * self.width / 2\n    p6 = s - normal_vector * self.width / 2\n    head_length: float = min(\n        head_width * max(0, self.arrow_head_length_scale), 0.5 * length)\n    base_length: float = length - head_length\n    p1 = p0 + direction_vector * base_length\n    p5 = p6 + direction_vector * base_length\n    width_head_width_diff: float = head_width - self.width\n    p2 = p1 + normal_vector * width_head_width_diff\n    p7 = p5 - normal_vector * width_head_width_diff\n    # if there is an indentation\n    if self.indentation &gt; 0:\n        indentation_base_length = length + head_length * \\\n            (0.5 * max(0, min(1, self.indentation)) - 1)\n        p1 = p0 + direction_vector * indentation_base_length\n        p5 = p6 + direction_vector * indentation_base_length\n    path: QPainterPath = QPainterPath()\n    path.moveTo(s)  # center of base and source point\n    path.lineTo(p0)  # corner 1 of base\n    path.lineTo(p1)  # corner 1 of indentation\n    path.lineTo(p2)  # corner 1 of outer head\n    path.lineTo(d)  # destination point\n    path.lineTo(p7)  # corner 2 of outer head\n    path.lineTo(p5)  # corner 2 of indentation\n    path.lineTo(p6)  # corner 2 of base\n    qp.fillPath(path, self.color)\n</code></pre>"},{"location":"chessapp/view/arrow/#source","title":"Source","text":"<pre><code>from PyQt5.QtGui import QPainter, QPainterPath, QColor\nfrom PyQt5.QtCore import QRect, QPoint, QPointF\nfrom chessapp.view.pieces import QSize\nfrom math import sqrt\n\n\nclass Arrow:\n    \"\"\" An arrow from source to destination point with a given width and color. The arrow can be indented and scaled.\n\n    Attributes:\n        source (QPoint): source point (root of the arrow)\n        destination (QPoint): destination point (tip of the arrow)\n        width (int): width of the arrow\n        color (QColor): color of the arrow\n        indentation (float): indentation of the arrow (0 = no indentation, 1 = full indentation). TODO: describe indentation\n        arrow_head_length_scale (float): scale of the arrow head length (0 = no arrow head, 1 = full arrow head)\n        arrow_head_width_scale (float): scale of the arrow head width (0 = no arrow head, 1 = full arrow head)\n    \"\"\"\n\n    def __init__(self, source: QPoint, destination: QPoint):\n        \"\"\" initialize an arrow\n\n        Args:\n            source (QPoint): source point (root of the arrow)\n            destination (QPoint): destination point (tip of the arrow)\n        \"\"\"\n        self.source = source\n        self.destination = destination\n        self.width = 10\n        self.color = QColor(0, 0, 128, 64)\n        self.indentation: float = 0\n        self.arrow_head_length_scale: float = 1\n        self.arrow_head_width_scale: float = 1\n\n    def drawOn(self, qp: QPainter, bound: QRect, offset: QPointF):\n        \"\"\" draw the arrow on the given painter\n\n        Args:\n            qp (QPainter): the painter to draw on\n            bound (QRect): the bounding rectangle of the arrow\n            offset (QSize): the offset of the arrow\n        \"\"\"\n        head_width = self.width * 2 * max(0, self.arrow_head_width_scale)\n        sx: float = self.source.x() + bound.x() + offset.x()\n        sy: float = self.source.y() + bound.y() + offset.y()\n        s = QPointF(sx, sy)\n        dx: float = self.destination.x() + bound.x() + offset.x()\n        dy: float = self.destination.y() + bound.y() + offset.y()\n        d = QPointF(dx, dy)\n        vx: float = dx - sx\n        vy: float = dy - sy\n        length: float = sqrt(vx * vx + vy * vy)\n        if length &lt;= head_width:\n            return\n        if vx == 0:\n            ax = 1\n            ay = 0\n        else:\n            ax = vy / length\n            ay = -vx / length\n        normal_vector = QPointF(ax, ay)\n        direction_vector = QPointF(vx / length, vy / length)\n        p0 = s + normal_vector * self.width / 2\n        p6 = s - normal_vector * self.width / 2\n        head_length: float = min(\n            head_width * max(0, self.arrow_head_length_scale), 0.5 * length)\n        base_length: float = length - head_length\n        p1 = p0 + direction_vector * base_length\n        p5 = p6 + direction_vector * base_length\n        width_head_width_diff: float = head_width - self.width\n        p2 = p1 + normal_vector * width_head_width_diff\n        p7 = p5 - normal_vector * width_head_width_diff\n        # if there is an indentation\n        if self.indentation &gt; 0:\n            indentation_base_length = length + head_length * \\\n                (0.5 * max(0, min(1, self.indentation)) - 1)\n            p1 = p0 + direction_vector * indentation_base_length\n            p5 = p6 + direction_vector * indentation_base_length\n        path: QPainterPath = QPainterPath()\n        path.moveTo(s)  # center of base and source point\n        path.lineTo(p0)  # corner 1 of base\n        path.lineTo(p1)  # corner 1 of indentation\n        path.lineTo(p2)  # corner 1 of outer head\n        path.lineTo(d)  # destination point\n        path.lineTo(p7)  # corner 2 of outer head\n        path.lineTo(p5)  # corner 2 of indentation\n        path.lineTo(p6)  # corner 2 of base\n        qp.fillPath(path, self.color)\n</code></pre>"},{"location":"chessapp/view/chessboard/","title":"chessboard","text":""},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.SquareIconType","title":"<code>chessapp.view.chessboard.SquareIconType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>a SquareIconType represents the kind of icon that should be displayed on a certain move, e.g. ?? for blunders, ?! for inaccuracies, etc.</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>class SquareIconType(Enum):\n    \"\"\" a SquareIconType represents the kind of icon that should be displayed on a certain move, e.g. ?? for blunders, ?! for inaccuracies, etc.\n    \"\"\"\n    BEST_MOVE = 1\n    ONLY_MOVE = 2\n    BRILLIANT_MOVE = 3\n    GOOD_MOVE = 4\n    INACCURACY = 5\n    BLUNDER = 6\n    BOOK_MOVE = 7\n    EXCELLENT_MOVE = 8\n    MISTAKE = 9\n\n    def sformat(self) -&gt; str:\n        \"\"\" Returns the string representation of the enum value\n\n        Returns:\n            str: the string representation of the enum value\n        \"\"\"\n        return str(self).replace(\"SquareIconType.\", \"\")\n\n    def from_cp_loss(cp_loss: int, is_book: bool, is_best_known: bool):\n        \"\"\" Returns the SquareIconType that corresponds to the given cp_loss, is_book and is_best_known values\n\n        Args:\n            cp_loss (int): the cp loss of the move\n            is_book (bool): true if it is a book move\n            is_best_known (bool): true if it is a best known move\n\n        TODO: this is not something the icon type should decide..\n\n        Returns:\n            SquareIconType: the SquareIconType that corresponds to the given cp_loss, is_book and is_best_known values\n        \"\"\"\n        if cp_loss &lt;= 35 and is_book:\n            return SquareIconType.BOOK_MOVE\n        if SquareIconType.is_best(cp_loss, is_best_known):\n            return SquareIconType.BEST_MOVE\n        if cp_loss &lt;= 15:\n            return SquareIconType.EXCELLENT_MOVE\n        if cp_loss &lt;= 25:\n            return SquareIconType.GOOD_MOVE\n        if cp_loss &lt;= 40:\n            return SquareIconType.INACCURACY\n        if cp_loss &lt;= 99:\n            return SquareIconType.MISTAKE\n        return SquareIconType.BLUNDER\n\n    def is_best(cp_loss: int, is_best_known: bool) -&gt; bool:\n        \"\"\" Returns true if the given cp_loss and is_best_known values correspond to a best move\n\n        TODO: this is not something the icon type should decide..\n\n        Args:\n            cp_loss (int): the cp loss of the move\n            is_best_known (bool): true if it is a best known move\n\n        Returns:\n            bool: true if the given cp_loss and is_best_known values correspond to a best move\n        \"\"\"\n        return cp_loss == 0 or is_best_known and cp_loss &lt;= 10\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.SquareIconType.from_cp_loss","title":"<code>from_cp_loss(cp_loss, is_book, is_best_known)</code>","text":"<p>Returns the SquareIconType that corresponds to the given cp_loss, is_book and is_best_known values</p> <p>Parameters:</p> Name Type Description Default <code>cp_loss</code> <code>int</code> <p>the cp loss of the move</p> required <code>is_book</code> <code>bool</code> <p>true if it is a book move</p> required <code>is_best_known</code> <code>bool</code> <p>true if it is a best known move</p> required <p>TODO: this is not something the icon type should decide..</p> <p>Returns:</p> Name Type Description <code>SquareIconType</code> <p>the SquareIconType that corresponds to the given cp_loss, is_book and is_best_known values</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def from_cp_loss(cp_loss: int, is_book: bool, is_best_known: bool):\n    \"\"\" Returns the SquareIconType that corresponds to the given cp_loss, is_book and is_best_known values\n\n    Args:\n        cp_loss (int): the cp loss of the move\n        is_book (bool): true if it is a book move\n        is_best_known (bool): true if it is a best known move\n\n    TODO: this is not something the icon type should decide..\n\n    Returns:\n        SquareIconType: the SquareIconType that corresponds to the given cp_loss, is_book and is_best_known values\n    \"\"\"\n    if cp_loss &lt;= 35 and is_book:\n        return SquareIconType.BOOK_MOVE\n    if SquareIconType.is_best(cp_loss, is_best_known):\n        return SquareIconType.BEST_MOVE\n    if cp_loss &lt;= 15:\n        return SquareIconType.EXCELLENT_MOVE\n    if cp_loss &lt;= 25:\n        return SquareIconType.GOOD_MOVE\n    if cp_loss &lt;= 40:\n        return SquareIconType.INACCURACY\n    if cp_loss &lt;= 99:\n        return SquareIconType.MISTAKE\n    return SquareIconType.BLUNDER\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.SquareIconType.is_best","title":"<code>is_best(cp_loss, is_best_known)</code>","text":"<p>Returns true if the given cp_loss and is_best_known values correspond to a best move</p> <p>TODO: this is not something the icon type should decide..</p> <p>Parameters:</p> Name Type Description Default <code>cp_loss</code> <code>int</code> <p>the cp loss of the move</p> required <code>is_best_known</code> <code>bool</code> <p>true if it is a best known move</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if the given cp_loss and is_best_known values correspond to a best move</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def is_best(cp_loss: int, is_best_known: bool) -&gt; bool:\n    \"\"\" Returns true if the given cp_loss and is_best_known values correspond to a best move\n\n    TODO: this is not something the icon type should decide..\n\n    Args:\n        cp_loss (int): the cp loss of the move\n        is_best_known (bool): true if it is a best known move\n\n    Returns:\n        bool: true if the given cp_loss and is_best_known values correspond to a best move\n    \"\"\"\n    return cp_loss == 0 or is_best_known and cp_loss &lt;= 10\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.SquareIconType.sformat","title":"<code>sformat()</code>","text":"<p>Returns the string representation of the enum value</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the string representation of the enum value</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def sformat(self) -&gt; str:\n    \"\"\" Returns the string representation of the enum value\n\n    Returns:\n        str: the string representation of the enum value\n    \"\"\"\n    return str(self).replace(\"SquareIconType.\", \"\")\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.SquareIcon","title":"<code>chessapp.view.chessboard.SquareIcon</code>","text":"<p>A SquareIcon represents an icon that should be displayed on a certain move, e.g. ?? for blunders, ?! for inaccuracies, etc.</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>class SquareIcon:\n    \"\"\" A SquareIcon represents an icon that should be displayed on a certain move, e.g. ?? for blunders, ?! for inaccuracies, etc.\n    \"\"\"\n\n    def __init__(self, square_icon_type: SquareIconType):\n        \"\"\" loads the icon from the images folder with the subfolder chessboard/square_icon and the name of the square_icon_type\n        e.g. \"[...]/chessboard/square_icon/blunder.png\"\n\n        Args:\n            square_icon_type (SquareIconType): the type of the icon\n        \"\"\"\n        self.path = join(get_images_folder(), \"chessboard\", \"square_icon\",\n                         square_icon_type.sformat().lower() + \".png\")\n        self.icon = QPixmap(self.path)\n\n    def drawOn(self, qp: QPainter, pos: QPoint, dim: QSize):\n        \"\"\" Draws the icon on the given position with the given dimensions of a square\n\n        Args:\n            qp (QPainter): painter to draw on\n            pos (QPoint): position to draw the icon\n            dim (QSize): dimension of a square on the chessboard\n        \"\"\"\n        target_width = int(SQUARE_ICON_SQUARE_PERCENTAGE * dim.width)\n        target_height = int(SQUARE_ICON_SQUARE_PERCENTAGE * dim.height)\n        qp.drawPixmap(pos.x() + dim.width - target_width, pos.y(), target_width, target_height,\n                      self.icon, 0, 0, s_square_icon_source_width, s_square_icon_source_height)\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.SquareIcon.__init__","title":"<code>__init__(square_icon_type)</code>","text":"<p>loads the icon from the images folder with the subfolder chessboard/square_icon and the name of the square_icon_type e.g. \"[...]/chessboard/square_icon/blunder.png\"</p> <p>Parameters:</p> Name Type Description Default <code>square_icon_type</code> <code>SquareIconType</code> <p>the type of the icon</p> required Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def __init__(self, square_icon_type: SquareIconType):\n    \"\"\" loads the icon from the images folder with the subfolder chessboard/square_icon and the name of the square_icon_type\n    e.g. \"[...]/chessboard/square_icon/blunder.png\"\n\n    Args:\n        square_icon_type (SquareIconType): the type of the icon\n    \"\"\"\n    self.path = join(get_images_folder(), \"chessboard\", \"square_icon\",\n                     square_icon_type.sformat().lower() + \".png\")\n    self.icon = QPixmap(self.path)\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.SquareIcon.drawOn","title":"<code>drawOn(qp, pos, dim)</code>","text":"<p>Draws the icon on the given position with the given dimensions of a square</p> <p>Parameters:</p> Name Type Description Default <code>qp</code> <code>QPainter</code> <p>painter to draw on</p> required <code>pos</code> <code>QPoint</code> <p>position to draw the icon</p> required <code>dim</code> <code>QSize</code> <p>dimension of a square on the chessboard</p> required Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def drawOn(self, qp: QPainter, pos: QPoint, dim: QSize):\n    \"\"\" Draws the icon on the given position with the given dimensions of a square\n\n    Args:\n        qp (QPainter): painter to draw on\n        pos (QPoint): position to draw the icon\n        dim (QSize): dimension of a square on the chessboard\n    \"\"\"\n    target_width = int(SQUARE_ICON_SQUARE_PERCENTAGE * dim.width)\n    target_height = int(SQUARE_ICON_SQUARE_PERCENTAGE * dim.height)\n    qp.drawPixmap(pos.x() + dim.width - target_width, pos.y(), target_width, target_height,\n                  self.icon, 0, 0, s_square_icon_source_width, s_square_icon_source_height)\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard","title":"<code>chessapp.view.chessboard.ChessBoard</code>","text":"<p>a chessboard is a 8x8 grid with pieces on it. It can be drawn on a QPainter. The ascii_board is a string representation of the board state with the pieces using the following letters:</p> <ul> <li>r: black rook</li> <li>n: black knight</li> <li>b: black bishop</li> <li>q: black queen</li> <li>k: black king</li> <li>p: black pawn</li> <li>R: white rook</li> <li>N: white knight</li> <li>B: white bishop</li> <li>Q: white queen</li> <li>K: white king</li> <li>P: white pawn</li> <li>.: empty square</li> </ul> <p>The side with the black pieces is always at the top and the side with the white pieces is always at the bottom regardless if the chessboard is flipped or not. Flipping a board only affects how the board is displayed and how the user interacts with the board, but not the internal representation.</p> <p>The SquareIcons are loaded.</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>class ChessBoard:\n    \"\"\" a chessboard is a 8x8 grid with pieces on it. It can be drawn on a QPainter. The ascii_board is a string\n    representation of the board state with the pieces using the following letters:\n\n    * r: black rook\n    * n: black knight\n    * b: black bishop\n    * q: black queen\n    * k: black king\n    * p: black pawn\n    * R: white rook\n    * N: white knight\n    * B: white bishop\n    * Q: white queen\n    * K: white king\n    * P: white pawn\n    * .: empty square\n\n    The side with the black pieces is always at the top and the side with the white pieces is always at the bottom regardless\n    if the chessboard is flipped or not. Flipping a board only affects how the board is displayed and how the user interacts\n    with the board, but not the internal representation.\n\n    The SquareIcons are loaded.\n    \"\"\"\n\n    def __init__(self):\n        self.icon_map = {}\n        self.white_square_color = QColor(228, 238, 210, 255)\n        self.black_square_color = QColor(118, 150, 86, 255)\n        self.red_square_color = QColor(255, 0, 0, 255)\n        self.ascii_board: str = \"\"\"r n b q k b n r\np p p p p p p p\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\nP P P P P P P P\nR N B Q K B N R\"\"\"\n        self.flip_board: bool = True\n        self.enable_piece_to_cursor: bool = False\n        self.mouse_x: float = 0\n        self.mouse_y: float = 0\n        self.active_piece = None\n        self.active_piece_origin: str = \"\"\n        self.legal_moves = []\n        self.active_piece_legal_move_destinations = []\n        self.last_move_cp_loss: int = 0\n        self.last_move_source: str = \"\"\n        self.last_move_destination: str = \"\"\n        self.last_move_is_book: bool = False\n        self.last_move_is_best_known: bool = False\n        self.node_depth: int = 0\n        self.best_move: str = None\n        self.show_best_move: bool = False\n        self.best_move_cp_loss: int = 0\n        self.show_last_move_arrow: bool = True\n        self.show_last_move_icon: bool = True\n        for icon_type in SquareIconType:\n            self.icon_map[icon_type] = SquareIcon(icon_type)\n\n    def coords_to_square(self, x: int, y: int, width: int, height: int) -&gt; str:\n        \"\"\" Converts the given x and y coordinates to a square on the chessboard\n\n        TODO: this method can be extracted into a helper class because it only depends on self.flip_board\n\n        Args:\n            x (int): x coordinate\n            y (int): y coordinate\n            width (int): width of the chessboard\n            height (int): height of the chessboard\n\n        Returns:\n            str: the square on the chessboard\n        \"\"\"\n        square_row: str = \"\"\n        square_col: str = \"\"\n        row: int = 8 * y // height\n        col: int = 8 * x // width\n        if self.flip_board:\n            square_row = str(row + 1)\n            square_col = chr(ord(\"h\") - col)\n        else:\n            square_row = str(8 - row)\n            square_col = chr(ord(\"a\") + col)\n        return square_col + square_row\n\n    def square_to_coords(self, square: str, widht: int, height: int) -&gt; tuple[int, int]:\n        \"\"\" Converts the given square on the chessboard to x and y coordinates\n\n        TODO: this method can be extracted into a helper class because it only depends on self.flip_board\n\n        Args:\n            square (str): SAN representation of the square\n            widht (int): width of the chessboard\n            height (int): height of the chessboard\n\n        Returns:\n            tuple[int, int]: x and y coordinates\n        \"\"\"\n        piece_width = widht // 8\n        piece_height = height // 8\n        row = 8 - int(square[1])\n        col = ord(square[0]) - ord(\"a\")\n        if self.flip_board:\n            col = 7 - col\n            row = 7 - row\n        x = col * piece_width\n        y = row * piece_height\n        return x, y\n\n    def select_piece(self, x: int, y: int, width: int, height: int):\n        \"\"\" Selects the piece on the given x and y coordinates\n\n        Args:\n            x (int): x coordinate\n            y (int): y coordinate\n            width (int): width of the chessboard\n            height (int): height of the chessboard\n        \"\"\"\n        row = 8 * y // height\n        col = 8 * x // width\n        if self.flip_board:\n            row = 7 - row\n            col = 7 - col\n        self.active_piece_origin = self.coords_to_square(x, y, width, height)\n        self.active_piece = get_piece_from(\n            self.ascii_board.split(\"\\n\")[row].split(\" \")[col])\n        self.active_piece_legal_move_destinations = []\n        if not self.legal_moves:\n            return\n        for move in self.legal_moves:\n            if str(move).startswith(self.active_piece_origin):\n                self.active_piece_legal_move_destinations.append(\n                    str(move)[2:])\n\n    def flip(self):\n        \"\"\" Flips the board\n        \"\"\"\n        self.flip_board = not self.flip_board\n\n    def view_black(self):\n        \"\"\" Views the board from the black side\n\n        TODO: is this method necessary?\n        \"\"\"\n        self.flip_board = True\n\n    def view_white(self):\n        \"\"\" Views the board from the white side\n\n        TODO: is this method necessary?\n        \"\"\"\n        self.flip_board = False\n\n    def is_active_piece(self, row: int, col: int) -&gt; bool:\n        \"\"\" Returns true if the piece on the given row and column is the active piece\n\n        Args:\n            row (int): row number of the piece\n            col (int): col number of the piece\n\n        Returns:\n            bool: true if the piece on the given row and column is the active piece\n        \"\"\"\n        return self.active_piece and self.active_piece_origin and col == (ord(self.active_piece_origin[0]) - ord('a')) and row == (int(self.active_piece_origin[1]) - 1)\n\n    def should_draw_active_piece(self) -&gt; bool:\n        \"\"\" Returns true if the active piece should be drawn\n\n        Returns:\n            bool: true if the active piece should be drawn\n        \"\"\"\n        return self.active_piece and len(self.active_piece_legal_move_destinations) &gt; 0\n\n    def drawOn(self, qp: QPainter, bound: QRect):\n        \"\"\" draws the chessboard on the given painter within the given bounds\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n        \"\"\"\n        dim = QSize()\n        dim.width = bound.width() // 8\n        dim.height = bound.height() // 8\n        self.draw_squares(qp, bound, dim)\n        self.draw_pieces(qp, bound, dim)\n        self.draw_last_move_arrow(qp, bound, dim)\n        self.draw_best_move_arrow(qp, bound, dim)\n        self.draw_square_icon_last_move(qp, bound, dim)\n        self.draw_piece_movement(qp, bound, dim)\n\n    def draw_squares(self, qp: QPainter, bound: QRect, dim: QSize):\n        \"\"\" draws the squares of the chessboard on the given painter within the given bounds\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n            dim (QSize): dimensions of a square on the chessboard\n        \"\"\"\n        square_color = None\n        for row in range(0, 8):\n            for col in range(0, 8):\n                square_color = self.black_square_color if row % 2 == col % 2 else self.white_square_color\n                if (not self.flip_board and self.is_active_piece(row, col)) or (self.flip_board and self.is_active_piece(7 - row, 7 - col)):\n                    square_color = self.red_square_color\n                qp.fillRect(col * dim.width + bound.x(), (7 - row) * dim.height + bound.y(),\n                            dim.width, dim.height, square_color)\n\n    def draw_pieces(self, qp: QPainter, bound: QRect, dim: QSize):\n        \"\"\" draws the pieces of the chessboard on the given painter within the given bounds\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n            dim (QSize): dimensions of a square on the chessboard\n        \"\"\"\n        rows = self.ascii_board.split(\"\\n\")\n        for i in range(0, 8):\n            row = rows[i].split(\" \")\n            for j in range(0, 8):\n                piece: ChessPiece = get_piece_from(row[j])\n                i_value = i\n                j_value = j\n                if self.flip_board:\n                    i_value = 7 - i\n                    j_value = 7 - j\n                if piece and not (self.is_active_piece(7 - i, j) and self.should_draw_active_piece()):\n                    piece.drawOn(qp, QPoint(\n                        dim.width * j_value + bound.x(), dim.height * i_value + bound.y()), dim)\n\n    def draw_last_move_arrow(self, qp: QPainter, bound: QRect, dim: QSize):\n        \"\"\" draws the last move arrow on the given painter within the given bounds\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n            dim (QSize): dimensions of a square on the chessboard\n        \"\"\"\n        if not self.last_move_source or not self.last_move_destination:\n            return\n        sx, sy = self.square_to_coords(\n            self.last_move_source, bound.width(), bound.height())\n        dx, dy = self.square_to_coords(\n            self.last_move_destination, bound.width(), bound.height())\n        arrow = Arrow(QPoint(sx, sy), QPoint(dx, dy))\n        arrow.width = min(dim.width, dim.height) / 10\n        arrow.arrow_head_width_scale = 1.1\n        arrow.arrow_head_length_scale = 1.3\n        arrow.color = QColor(252, 186, 3, 192)\n        arrow.indentation = 0.4\n        arrow.drawOn(qp, bound, QPointF(0.5 * dim.width, 0.5 * dim.height))\n\n    def draw_best_move_arrow(self, qp: QPainter, bound: QRect, dim: QSize):\n        \"\"\" draws the best move arrow on the given painter within the given bounds\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n            dim (QSize): dimensions of a square on the chessboard\n        \"\"\"\n        if not self.show_best_move or not self.best_move or not SquareIconType.is_best(self.best_move_cp_loss, True) or not self.show_last_move_arrow:\n            return\n        sx, sy = self.square_to_coords(\n            self.best_move[:2], bound.width(), bound.height())\n        dx, dy = self.square_to_coords(\n            self.best_move[2:], bound.width(), bound.height())\n        arrow = Arrow(QPoint(sx, sy), QPoint(dx, dy))\n        arrow.width = min(dim.width, dim.height) / 5\n        arrow.drawOn(qp, bound, QPointF(0.5 * dim.width, 0.5 * dim.height))\n\n    def draw_square_icon_last_move(self, qp: QPainter, bound: QRect, dim: QSize):\n        \"\"\" draws the square icon of the last move on the given painter within the given bounds\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n            dim (QSize): dimensions of a square on the chessboard\n        \"\"\"\n        if not self.last_move_destination or self.node_depth &lt;= 0 or not self.show_last_move_icon:\n            return\n        x, y = self.square_to_coords(\n            self.last_move_destination, bound.width(), bound.height())\n        self.icon_map[SquareIconType.from_cp_loss(self.last_move_cp_loss, self.last_move_is_book, self.last_move_is_best_known)].drawOn(\n            qp, QPoint(bound.x() + x, bound.y() + y), dim)\n\n    def draw_piece_movement(self, qp: QPainter, bound: QRect, dim: QSize):\n        \"\"\" draws the piece movement on the given painter within the given bounds (active piece and legal destinations)\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n            dim (QSize): dimensions of a square on the chessboard\n        \"\"\"\n        if not self.should_draw_active_piece() or not self.enable_piece_to_cursor:\n            return\n        # draw possible destinations\n        for destination in self.active_piece_legal_move_destinations:\n            x, y = self.square_to_coords(\n                destination, bound.width(), bound.height())\n            qp.setPen(QColor(0, 0, 0, 255))\n            qp.drawEllipse(QPoint(x + bound.x() + dim.width // 2, y + bound.y() + dim.height // 2),\n                           dim.width // 6, dim.height // 6)\n            qp.drawEllipse(QPoint(x + bound.x() + dim.width // 2, y + bound.y() + dim.height // 2),\n                           dim.width // 5, dim.height // 5)\n        # draw piece itself\n        self.active_piece.drawOn(qp, QPoint(\n            int(self.mouse_x - (dim.width / 2)), int(self.mouse_y - (dim.height / 2))), dim)\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.coords_to_square","title":"<code>coords_to_square(x, y, width, height)</code>","text":"<p>Converts the given x and y coordinates to a square on the chessboard</p> <p>TODO: this method can be extracted into a helper class because it only depends on self.flip_board</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>x coordinate</p> required <code>y</code> <code>int</code> <p>y coordinate</p> required <code>width</code> <code>int</code> <p>width of the chessboard</p> required <code>height</code> <code>int</code> <p>height of the chessboard</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the square on the chessboard</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def coords_to_square(self, x: int, y: int, width: int, height: int) -&gt; str:\n    \"\"\" Converts the given x and y coordinates to a square on the chessboard\n\n    TODO: this method can be extracted into a helper class because it only depends on self.flip_board\n\n    Args:\n        x (int): x coordinate\n        y (int): y coordinate\n        width (int): width of the chessboard\n        height (int): height of the chessboard\n\n    Returns:\n        str: the square on the chessboard\n    \"\"\"\n    square_row: str = \"\"\n    square_col: str = \"\"\n    row: int = 8 * y // height\n    col: int = 8 * x // width\n    if self.flip_board:\n        square_row = str(row + 1)\n        square_col = chr(ord(\"h\") - col)\n    else:\n        square_row = str(8 - row)\n        square_col = chr(ord(\"a\") + col)\n    return square_col + square_row\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.drawOn","title":"<code>drawOn(qp, bound)</code>","text":"<p>draws the chessboard on the given painter within the given bounds</p> <p>Parameters:</p> Name Type Description Default <code>qp</code> <code>QPainter</code> <p>painter to draw on</p> required <code>bound</code> <code>QRect</code> <p>bounds to draw the chessboard in</p> required Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def drawOn(self, qp: QPainter, bound: QRect):\n    \"\"\" draws the chessboard on the given painter within the given bounds\n\n    Args:\n        qp (QPainter): painter to draw on\n        bound (QRect): bounds to draw the chessboard in\n    \"\"\"\n    dim = QSize()\n    dim.width = bound.width() // 8\n    dim.height = bound.height() // 8\n    self.draw_squares(qp, bound, dim)\n    self.draw_pieces(qp, bound, dim)\n    self.draw_last_move_arrow(qp, bound, dim)\n    self.draw_best_move_arrow(qp, bound, dim)\n    self.draw_square_icon_last_move(qp, bound, dim)\n    self.draw_piece_movement(qp, bound, dim)\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.draw_best_move_arrow","title":"<code>draw_best_move_arrow(qp, bound, dim)</code>","text":"<p>draws the best move arrow on the given painter within the given bounds</p> <p>Parameters:</p> Name Type Description Default <code>qp</code> <code>QPainter</code> <p>painter to draw on</p> required <code>bound</code> <code>QRect</code> <p>bounds to draw the chessboard in</p> required <code>dim</code> <code>QSize</code> <p>dimensions of a square on the chessboard</p> required Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def draw_best_move_arrow(self, qp: QPainter, bound: QRect, dim: QSize):\n    \"\"\" draws the best move arrow on the given painter within the given bounds\n\n    Args:\n        qp (QPainter): painter to draw on\n        bound (QRect): bounds to draw the chessboard in\n        dim (QSize): dimensions of a square on the chessboard\n    \"\"\"\n    if not self.show_best_move or not self.best_move or not SquareIconType.is_best(self.best_move_cp_loss, True) or not self.show_last_move_arrow:\n        return\n    sx, sy = self.square_to_coords(\n        self.best_move[:2], bound.width(), bound.height())\n    dx, dy = self.square_to_coords(\n        self.best_move[2:], bound.width(), bound.height())\n    arrow = Arrow(QPoint(sx, sy), QPoint(dx, dy))\n    arrow.width = min(dim.width, dim.height) / 5\n    arrow.drawOn(qp, bound, QPointF(0.5 * dim.width, 0.5 * dim.height))\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.draw_last_move_arrow","title":"<code>draw_last_move_arrow(qp, bound, dim)</code>","text":"<p>draws the last move arrow on the given painter within the given bounds</p> <p>Parameters:</p> Name Type Description Default <code>qp</code> <code>QPainter</code> <p>painter to draw on</p> required <code>bound</code> <code>QRect</code> <p>bounds to draw the chessboard in</p> required <code>dim</code> <code>QSize</code> <p>dimensions of a square on the chessboard</p> required Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def draw_last_move_arrow(self, qp: QPainter, bound: QRect, dim: QSize):\n    \"\"\" draws the last move arrow on the given painter within the given bounds\n\n    Args:\n        qp (QPainter): painter to draw on\n        bound (QRect): bounds to draw the chessboard in\n        dim (QSize): dimensions of a square on the chessboard\n    \"\"\"\n    if not self.last_move_source or not self.last_move_destination:\n        return\n    sx, sy = self.square_to_coords(\n        self.last_move_source, bound.width(), bound.height())\n    dx, dy = self.square_to_coords(\n        self.last_move_destination, bound.width(), bound.height())\n    arrow = Arrow(QPoint(sx, sy), QPoint(dx, dy))\n    arrow.width = min(dim.width, dim.height) / 10\n    arrow.arrow_head_width_scale = 1.1\n    arrow.arrow_head_length_scale = 1.3\n    arrow.color = QColor(252, 186, 3, 192)\n    arrow.indentation = 0.4\n    arrow.drawOn(qp, bound, QPointF(0.5 * dim.width, 0.5 * dim.height))\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.draw_piece_movement","title":"<code>draw_piece_movement(qp, bound, dim)</code>","text":"<p>draws the piece movement on the given painter within the given bounds (active piece and legal destinations)</p> <p>Parameters:</p> Name Type Description Default <code>qp</code> <code>QPainter</code> <p>painter to draw on</p> required <code>bound</code> <code>QRect</code> <p>bounds to draw the chessboard in</p> required <code>dim</code> <code>QSize</code> <p>dimensions of a square on the chessboard</p> required Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def draw_piece_movement(self, qp: QPainter, bound: QRect, dim: QSize):\n    \"\"\" draws the piece movement on the given painter within the given bounds (active piece and legal destinations)\n\n    Args:\n        qp (QPainter): painter to draw on\n        bound (QRect): bounds to draw the chessboard in\n        dim (QSize): dimensions of a square on the chessboard\n    \"\"\"\n    if not self.should_draw_active_piece() or not self.enable_piece_to_cursor:\n        return\n    # draw possible destinations\n    for destination in self.active_piece_legal_move_destinations:\n        x, y = self.square_to_coords(\n            destination, bound.width(), bound.height())\n        qp.setPen(QColor(0, 0, 0, 255))\n        qp.drawEllipse(QPoint(x + bound.x() + dim.width // 2, y + bound.y() + dim.height // 2),\n                       dim.width // 6, dim.height // 6)\n        qp.drawEllipse(QPoint(x + bound.x() + dim.width // 2, y + bound.y() + dim.height // 2),\n                       dim.width // 5, dim.height // 5)\n    # draw piece itself\n    self.active_piece.drawOn(qp, QPoint(\n        int(self.mouse_x - (dim.width / 2)), int(self.mouse_y - (dim.height / 2))), dim)\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.draw_pieces","title":"<code>draw_pieces(qp, bound, dim)</code>","text":"<p>draws the pieces of the chessboard on the given painter within the given bounds</p> <p>Parameters:</p> Name Type Description Default <code>qp</code> <code>QPainter</code> <p>painter to draw on</p> required <code>bound</code> <code>QRect</code> <p>bounds to draw the chessboard in</p> required <code>dim</code> <code>QSize</code> <p>dimensions of a square on the chessboard</p> required Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def draw_pieces(self, qp: QPainter, bound: QRect, dim: QSize):\n    \"\"\" draws the pieces of the chessboard on the given painter within the given bounds\n\n    Args:\n        qp (QPainter): painter to draw on\n        bound (QRect): bounds to draw the chessboard in\n        dim (QSize): dimensions of a square on the chessboard\n    \"\"\"\n    rows = self.ascii_board.split(\"\\n\")\n    for i in range(0, 8):\n        row = rows[i].split(\" \")\n        for j in range(0, 8):\n            piece: ChessPiece = get_piece_from(row[j])\n            i_value = i\n            j_value = j\n            if self.flip_board:\n                i_value = 7 - i\n                j_value = 7 - j\n            if piece and not (self.is_active_piece(7 - i, j) and self.should_draw_active_piece()):\n                piece.drawOn(qp, QPoint(\n                    dim.width * j_value + bound.x(), dim.height * i_value + bound.y()), dim)\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.draw_square_icon_last_move","title":"<code>draw_square_icon_last_move(qp, bound, dim)</code>","text":"<p>draws the square icon of the last move on the given painter within the given bounds</p> <p>Parameters:</p> Name Type Description Default <code>qp</code> <code>QPainter</code> <p>painter to draw on</p> required <code>bound</code> <code>QRect</code> <p>bounds to draw the chessboard in</p> required <code>dim</code> <code>QSize</code> <p>dimensions of a square on the chessboard</p> required Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def draw_square_icon_last_move(self, qp: QPainter, bound: QRect, dim: QSize):\n    \"\"\" draws the square icon of the last move on the given painter within the given bounds\n\n    Args:\n        qp (QPainter): painter to draw on\n        bound (QRect): bounds to draw the chessboard in\n        dim (QSize): dimensions of a square on the chessboard\n    \"\"\"\n    if not self.last_move_destination or self.node_depth &lt;= 0 or not self.show_last_move_icon:\n        return\n    x, y = self.square_to_coords(\n        self.last_move_destination, bound.width(), bound.height())\n    self.icon_map[SquareIconType.from_cp_loss(self.last_move_cp_loss, self.last_move_is_book, self.last_move_is_best_known)].drawOn(\n        qp, QPoint(bound.x() + x, bound.y() + y), dim)\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.draw_squares","title":"<code>draw_squares(qp, bound, dim)</code>","text":"<p>draws the squares of the chessboard on the given painter within the given bounds</p> <p>Parameters:</p> Name Type Description Default <code>qp</code> <code>QPainter</code> <p>painter to draw on</p> required <code>bound</code> <code>QRect</code> <p>bounds to draw the chessboard in</p> required <code>dim</code> <code>QSize</code> <p>dimensions of a square on the chessboard</p> required Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def draw_squares(self, qp: QPainter, bound: QRect, dim: QSize):\n    \"\"\" draws the squares of the chessboard on the given painter within the given bounds\n\n    Args:\n        qp (QPainter): painter to draw on\n        bound (QRect): bounds to draw the chessboard in\n        dim (QSize): dimensions of a square on the chessboard\n    \"\"\"\n    square_color = None\n    for row in range(0, 8):\n        for col in range(0, 8):\n            square_color = self.black_square_color if row % 2 == col % 2 else self.white_square_color\n            if (not self.flip_board and self.is_active_piece(row, col)) or (self.flip_board and self.is_active_piece(7 - row, 7 - col)):\n                square_color = self.red_square_color\n            qp.fillRect(col * dim.width + bound.x(), (7 - row) * dim.height + bound.y(),\n                        dim.width, dim.height, square_color)\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.flip","title":"<code>flip()</code>","text":"<p>Flips the board</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def flip(self):\n    \"\"\" Flips the board\n    \"\"\"\n    self.flip_board = not self.flip_board\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.is_active_piece","title":"<code>is_active_piece(row, col)</code>","text":"<p>Returns true if the piece on the given row and column is the active piece</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>int</code> <p>row number of the piece</p> required <code>col</code> <code>int</code> <p>col number of the piece</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if the piece on the given row and column is the active piece</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def is_active_piece(self, row: int, col: int) -&gt; bool:\n    \"\"\" Returns true if the piece on the given row and column is the active piece\n\n    Args:\n        row (int): row number of the piece\n        col (int): col number of the piece\n\n    Returns:\n        bool: true if the piece on the given row and column is the active piece\n    \"\"\"\n    return self.active_piece and self.active_piece_origin and col == (ord(self.active_piece_origin[0]) - ord('a')) and row == (int(self.active_piece_origin[1]) - 1)\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.select_piece","title":"<code>select_piece(x, y, width, height)</code>","text":"<p>Selects the piece on the given x and y coordinates</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>x coordinate</p> required <code>y</code> <code>int</code> <p>y coordinate</p> required <code>width</code> <code>int</code> <p>width of the chessboard</p> required <code>height</code> <code>int</code> <p>height of the chessboard</p> required Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def select_piece(self, x: int, y: int, width: int, height: int):\n    \"\"\" Selects the piece on the given x and y coordinates\n\n    Args:\n        x (int): x coordinate\n        y (int): y coordinate\n        width (int): width of the chessboard\n        height (int): height of the chessboard\n    \"\"\"\n    row = 8 * y // height\n    col = 8 * x // width\n    if self.flip_board:\n        row = 7 - row\n        col = 7 - col\n    self.active_piece_origin = self.coords_to_square(x, y, width, height)\n    self.active_piece = get_piece_from(\n        self.ascii_board.split(\"\\n\")[row].split(\" \")[col])\n    self.active_piece_legal_move_destinations = []\n    if not self.legal_moves:\n        return\n    for move in self.legal_moves:\n        if str(move).startswith(self.active_piece_origin):\n            self.active_piece_legal_move_destinations.append(\n                str(move)[2:])\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.should_draw_active_piece","title":"<code>should_draw_active_piece()</code>","text":"<p>Returns true if the active piece should be drawn</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if the active piece should be drawn</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def should_draw_active_piece(self) -&gt; bool:\n    \"\"\" Returns true if the active piece should be drawn\n\n    Returns:\n        bool: true if the active piece should be drawn\n    \"\"\"\n    return self.active_piece and len(self.active_piece_legal_move_destinations) &gt; 0\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.square_to_coords","title":"<code>square_to_coords(square, widht, height)</code>","text":"<p>Converts the given square on the chessboard to x and y coordinates</p> <p>TODO: this method can be extracted into a helper class because it only depends on self.flip_board</p> <p>Parameters:</p> Name Type Description Default <code>square</code> <code>str</code> <p>SAN representation of the square</p> required <code>widht</code> <code>int</code> <p>width of the chessboard</p> required <code>height</code> <code>int</code> <p>height of the chessboard</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: x and y coordinates</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def square_to_coords(self, square: str, widht: int, height: int) -&gt; tuple[int, int]:\n    \"\"\" Converts the given square on the chessboard to x and y coordinates\n\n    TODO: this method can be extracted into a helper class because it only depends on self.flip_board\n\n    Args:\n        square (str): SAN representation of the square\n        widht (int): width of the chessboard\n        height (int): height of the chessboard\n\n    Returns:\n        tuple[int, int]: x and y coordinates\n    \"\"\"\n    piece_width = widht // 8\n    piece_height = height // 8\n    row = 8 - int(square[1])\n    col = ord(square[0]) - ord(\"a\")\n    if self.flip_board:\n        col = 7 - col\n        row = 7 - row\n    x = col * piece_width\n    y = row * piece_height\n    return x, y\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.view_black","title":"<code>view_black()</code>","text":"<p>Views the board from the black side</p> <p>TODO: is this method necessary?</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def view_black(self):\n    \"\"\" Views the board from the black side\n\n    TODO: is this method necessary?\n    \"\"\"\n    self.flip_board = True\n</code></pre>"},{"location":"chessapp/view/chessboard/#chessapp.view.chessboard.ChessBoard.view_white","title":"<code>view_white()</code>","text":"<p>Views the board from the white side</p> <p>TODO: is this method necessary?</p> Source code in <code>chessapp\\view\\chessboard.py</code> <pre><code>def view_white(self):\n    \"\"\" Views the board from the white side\n\n    TODO: is this method necessary?\n    \"\"\"\n    self.flip_board = False\n</code></pre>"},{"location":"chessapp/view/chessboard/#source","title":"Source","text":"<pre><code>from chessapp.view.pieces import get_piece_from, ChessPiece\nfrom PyQt5.QtGui import QPainter, QColor\nfrom PyQt5.QtCore import QRect, QPoint, QSize, QPointF\nfrom PyQt5.QtGui import QPainter, QPixmap\nfrom enum import Enum\nfrom chessapp.view.arrow import Arrow\nfrom chessapp.configuration import SQUARE_ICON_SQUARE_PERCENTAGE\nfrom os.path import join\nfrom chessapp.util.paths import get_images_folder\n\n\ns_square_icon_source_width: int = 64\ns_square_icon_source_height: int = 64\n\n\nclass SquareIconType(Enum):\n    \"\"\" a SquareIconType represents the kind of icon that should be displayed on a certain move, e.g. ?? for blunders, ?! for inaccuracies, etc.\n    \"\"\"\n    BEST_MOVE = 1\n    ONLY_MOVE = 2\n    BRILLIANT_MOVE = 3\n    GOOD_MOVE = 4\n    INACCURACY = 5\n    BLUNDER = 6\n    BOOK_MOVE = 7\n    EXCELLENT_MOVE = 8\n    MISTAKE = 9\n\n    def sformat(self) -&gt; str:\n        \"\"\" Returns the string representation of the enum value\n\n        Returns:\n            str: the string representation of the enum value\n        \"\"\"\n        return str(self).replace(\"SquareIconType.\", \"\")\n\n    def from_cp_loss(cp_loss: int, is_book: bool, is_best_known: bool):\n        \"\"\" Returns the SquareIconType that corresponds to the given cp_loss, is_book and is_best_known values\n\n        Args:\n            cp_loss (int): the cp loss of the move\n            is_book (bool): true if it is a book move\n            is_best_known (bool): true if it is a best known move\n\n        TODO: this is not something the icon type should decide..\n\n        Returns:\n            SquareIconType: the SquareIconType that corresponds to the given cp_loss, is_book and is_best_known values\n        \"\"\"\n        if cp_loss &lt;= 35 and is_book:\n            return SquareIconType.BOOK_MOVE\n        if SquareIconType.is_best(cp_loss, is_best_known):\n            return SquareIconType.BEST_MOVE\n        if cp_loss &lt;= 15:\n            return SquareIconType.EXCELLENT_MOVE\n        if cp_loss &lt;= 25:\n            return SquareIconType.GOOD_MOVE\n        if cp_loss &lt;= 40:\n            return SquareIconType.INACCURACY\n        if cp_loss &lt;= 99:\n            return SquareIconType.MISTAKE\n        return SquareIconType.BLUNDER\n\n    def is_best(cp_loss: int, is_best_known: bool) -&gt; bool:\n        \"\"\" Returns true if the given cp_loss and is_best_known values correspond to a best move\n\n        TODO: this is not something the icon type should decide..\n\n        Args:\n            cp_loss (int): the cp loss of the move\n            is_best_known (bool): true if it is a best known move\n\n        Returns:\n            bool: true if the given cp_loss and is_best_known values correspond to a best move\n        \"\"\"\n        return cp_loss == 0 or is_best_known and cp_loss &lt;= 10\n\n\nclass SquareIcon:\n    \"\"\" A SquareIcon represents an icon that should be displayed on a certain move, e.g. ?? for blunders, ?! for inaccuracies, etc.\n    \"\"\"\n\n    def __init__(self, square_icon_type: SquareIconType):\n        \"\"\" loads the icon from the images folder with the subfolder chessboard/square_icon and the name of the square_icon_type\n        e.g. \"[...]/chessboard/square_icon/blunder.png\"\n\n        Args:\n            square_icon_type (SquareIconType): the type of the icon\n        \"\"\"\n        self.path = join(get_images_folder(), \"chessboard\", \"square_icon\",\n                         square_icon_type.sformat().lower() + \".png\")\n        self.icon = QPixmap(self.path)\n\n    def drawOn(self, qp: QPainter, pos: QPoint, dim: QSize):\n        \"\"\" Draws the icon on the given position with the given dimensions of a square\n\n        Args:\n            qp (QPainter): painter to draw on\n            pos (QPoint): position to draw the icon\n            dim (QSize): dimension of a square on the chessboard\n        \"\"\"\n        target_width = int(SQUARE_ICON_SQUARE_PERCENTAGE * dim.width)\n        target_height = int(SQUARE_ICON_SQUARE_PERCENTAGE * dim.height)\n        qp.drawPixmap(pos.x() + dim.width - target_width, pos.y(), target_width, target_height,\n                      self.icon, 0, 0, s_square_icon_source_width, s_square_icon_source_height)\n\n\nclass ChessBoard:\n    \"\"\" a chessboard is a 8x8 grid with pieces on it. It can be drawn on a QPainter. The ascii_board is a string\n    representation of the board state with the pieces using the following letters:\n\n    * r: black rook\n    * n: black knight\n    * b: black bishop\n    * q: black queen\n    * k: black king\n    * p: black pawn\n    * R: white rook\n    * N: white knight\n    * B: white bishop\n    * Q: white queen\n    * K: white king\n    * P: white pawn\n    * .: empty square\n\n    The side with the black pieces is always at the top and the side with the white pieces is always at the bottom regardless\n    if the chessboard is flipped or not. Flipping a board only affects how the board is displayed and how the user interacts\n    with the board, but not the internal representation.\n\n    The SquareIcons are loaded.\n    \"\"\"\n\n    def __init__(self):\n        self.icon_map = {}\n        self.white_square_color = QColor(228, 238, 210, 255)\n        self.black_square_color = QColor(118, 150, 86, 255)\n        self.red_square_color = QColor(255, 0, 0, 255)\n        self.ascii_board: str = \"\"\"r n b q k b n r\np p p p p p p p\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\nP P P P P P P P\nR N B Q K B N R\"\"\"\n        self.flip_board: bool = True\n        self.enable_piece_to_cursor: bool = False\n        self.mouse_x: float = 0\n        self.mouse_y: float = 0\n        self.active_piece = None\n        self.active_piece_origin: str = \"\"\n        self.legal_moves = []\n        self.active_piece_legal_move_destinations = []\n        self.last_move_cp_loss: int = 0\n        self.last_move_source: str = \"\"\n        self.last_move_destination: str = \"\"\n        self.last_move_is_book: bool = False\n        self.last_move_is_best_known: bool = False\n        self.node_depth: int = 0\n        self.best_move: str = None\n        self.show_best_move: bool = False\n        self.best_move_cp_loss: int = 0\n        self.show_last_move_arrow: bool = True\n        self.show_last_move_icon: bool = True\n        for icon_type in SquareIconType:\n            self.icon_map[icon_type] = SquareIcon(icon_type)\n\n    def coords_to_square(self, x: int, y: int, width: int, height: int) -&gt; str:\n        \"\"\" Converts the given x and y coordinates to a square on the chessboard\n\n        TODO: this method can be extracted into a helper class because it only depends on self.flip_board\n\n        Args:\n            x (int): x coordinate\n            y (int): y coordinate\n            width (int): width of the chessboard\n            height (int): height of the chessboard\n\n        Returns:\n            str: the square on the chessboard\n        \"\"\"\n        square_row: str = \"\"\n        square_col: str = \"\"\n        row: int = 8 * y // height\n        col: int = 8 * x // width\n        if self.flip_board:\n            square_row = str(row + 1)\n            square_col = chr(ord(\"h\") - col)\n        else:\n            square_row = str(8 - row)\n            square_col = chr(ord(\"a\") + col)\n        return square_col + square_row\n\n    def square_to_coords(self, square: str, widht: int, height: int) -&gt; tuple[int, int]:\n        \"\"\" Converts the given square on the chessboard to x and y coordinates\n\n        TODO: this method can be extracted into a helper class because it only depends on self.flip_board\n\n        Args:\n            square (str): SAN representation of the square\n            widht (int): width of the chessboard\n            height (int): height of the chessboard\n\n        Returns:\n            tuple[int, int]: x and y coordinates\n        \"\"\"\n        piece_width = widht // 8\n        piece_height = height // 8\n        row = 8 - int(square[1])\n        col = ord(square[0]) - ord(\"a\")\n        if self.flip_board:\n            col = 7 - col\n            row = 7 - row\n        x = col * piece_width\n        y = row * piece_height\n        return x, y\n\n    def select_piece(self, x: int, y: int, width: int, height: int):\n        \"\"\" Selects the piece on the given x and y coordinates\n\n        Args:\n            x (int): x coordinate\n            y (int): y coordinate\n            width (int): width of the chessboard\n            height (int): height of the chessboard\n        \"\"\"\n        row = 8 * y // height\n        col = 8 * x // width\n        if self.flip_board:\n            row = 7 - row\n            col = 7 - col\n        self.active_piece_origin = self.coords_to_square(x, y, width, height)\n        self.active_piece = get_piece_from(\n            self.ascii_board.split(\"\\n\")[row].split(\" \")[col])\n        self.active_piece_legal_move_destinations = []\n        if not self.legal_moves:\n            return\n        for move in self.legal_moves:\n            if str(move).startswith(self.active_piece_origin):\n                self.active_piece_legal_move_destinations.append(\n                    str(move)[2:])\n\n    def flip(self):\n        \"\"\" Flips the board\n        \"\"\"\n        self.flip_board = not self.flip_board\n\n    def view_black(self):\n        \"\"\" Views the board from the black side\n\n        TODO: is this method necessary?\n        \"\"\"\n        self.flip_board = True\n\n    def view_white(self):\n        \"\"\" Views the board from the white side\n\n        TODO: is this method necessary?\n        \"\"\"\n        self.flip_board = False\n\n    def is_active_piece(self, row: int, col: int) -&gt; bool:\n        \"\"\" Returns true if the piece on the given row and column is the active piece\n\n        Args:\n            row (int): row number of the piece\n            col (int): col number of the piece\n\n        Returns:\n            bool: true if the piece on the given row and column is the active piece\n        \"\"\"\n        return self.active_piece and self.active_piece_origin and col == (ord(self.active_piece_origin[0]) - ord('a')) and row == (int(self.active_piece_origin[1]) - 1)\n\n    def should_draw_active_piece(self) -&gt; bool:\n        \"\"\" Returns true if the active piece should be drawn\n\n        Returns:\n            bool: true if the active piece should be drawn\n        \"\"\"\n        return self.active_piece and len(self.active_piece_legal_move_destinations) &gt; 0\n\n    def drawOn(self, qp: QPainter, bound: QRect):\n        \"\"\" draws the chessboard on the given painter within the given bounds\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n        \"\"\"\n        dim = QSize()\n        dim.width = bound.width() // 8\n        dim.height = bound.height() // 8\n        self.draw_squares(qp, bound, dim)\n        self.draw_pieces(qp, bound, dim)\n        self.draw_last_move_arrow(qp, bound, dim)\n        self.draw_best_move_arrow(qp, bound, dim)\n        self.draw_square_icon_last_move(qp, bound, dim)\n        self.draw_piece_movement(qp, bound, dim)\n\n    def draw_squares(self, qp: QPainter, bound: QRect, dim: QSize):\n        \"\"\" draws the squares of the chessboard on the given painter within the given bounds\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n            dim (QSize): dimensions of a square on the chessboard\n        \"\"\"\n        square_color = None\n        for row in range(0, 8):\n            for col in range(0, 8):\n                square_color = self.black_square_color if row % 2 == col % 2 else self.white_square_color\n                if (not self.flip_board and self.is_active_piece(row, col)) or (self.flip_board and self.is_active_piece(7 - row, 7 - col)):\n                    square_color = self.red_square_color\n                qp.fillRect(col * dim.width + bound.x(), (7 - row) * dim.height + bound.y(),\n                            dim.width, dim.height, square_color)\n\n    def draw_pieces(self, qp: QPainter, bound: QRect, dim: QSize):\n        \"\"\" draws the pieces of the chessboard on the given painter within the given bounds\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n            dim (QSize): dimensions of a square on the chessboard\n        \"\"\"\n        rows = self.ascii_board.split(\"\\n\")\n        for i in range(0, 8):\n            row = rows[i].split(\" \")\n            for j in range(0, 8):\n                piece: ChessPiece = get_piece_from(row[j])\n                i_value = i\n                j_value = j\n                if self.flip_board:\n                    i_value = 7 - i\n                    j_value = 7 - j\n                if piece and not (self.is_active_piece(7 - i, j) and self.should_draw_active_piece()):\n                    piece.drawOn(qp, QPoint(\n                        dim.width * j_value + bound.x(), dim.height * i_value + bound.y()), dim)\n\n    def draw_last_move_arrow(self, qp: QPainter, bound: QRect, dim: QSize):\n        \"\"\" draws the last move arrow on the given painter within the given bounds\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n            dim (QSize): dimensions of a square on the chessboard\n        \"\"\"\n        if not self.last_move_source or not self.last_move_destination:\n            return\n        sx, sy = self.square_to_coords(\n            self.last_move_source, bound.width(), bound.height())\n        dx, dy = self.square_to_coords(\n            self.last_move_destination, bound.width(), bound.height())\n        arrow = Arrow(QPoint(sx, sy), QPoint(dx, dy))\n        arrow.width = min(dim.width, dim.height) / 10\n        arrow.arrow_head_width_scale = 1.1\n        arrow.arrow_head_length_scale = 1.3\n        arrow.color = QColor(252, 186, 3, 192)\n        arrow.indentation = 0.4\n        arrow.drawOn(qp, bound, QPointF(0.5 * dim.width, 0.5 * dim.height))\n\n    def draw_best_move_arrow(self, qp: QPainter, bound: QRect, dim: QSize):\n        \"\"\" draws the best move arrow on the given painter within the given bounds\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n            dim (QSize): dimensions of a square on the chessboard\n        \"\"\"\n        if not self.show_best_move or not self.best_move or not SquareIconType.is_best(self.best_move_cp_loss, True) or not self.show_last_move_arrow:\n            return\n        sx, sy = self.square_to_coords(\n            self.best_move[:2], bound.width(), bound.height())\n        dx, dy = self.square_to_coords(\n            self.best_move[2:], bound.width(), bound.height())\n        arrow = Arrow(QPoint(sx, sy), QPoint(dx, dy))\n        arrow.width = min(dim.width, dim.height) / 5\n        arrow.drawOn(qp, bound, QPointF(0.5 * dim.width, 0.5 * dim.height))\n\n    def draw_square_icon_last_move(self, qp: QPainter, bound: QRect, dim: QSize):\n        \"\"\" draws the square icon of the last move on the given painter within the given bounds\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n            dim (QSize): dimensions of a square on the chessboard\n        \"\"\"\n        if not self.last_move_destination or self.node_depth &lt;= 0 or not self.show_last_move_icon:\n            return\n        x, y = self.square_to_coords(\n            self.last_move_destination, bound.width(), bound.height())\n        self.icon_map[SquareIconType.from_cp_loss(self.last_move_cp_loss, self.last_move_is_book, self.last_move_is_best_known)].drawOn(\n            qp, QPoint(bound.x() + x, bound.y() + y), dim)\n\n    def draw_piece_movement(self, qp: QPainter, bound: QRect, dim: QSize):\n        \"\"\" draws the piece movement on the given painter within the given bounds (active piece and legal destinations)\n\n        Args:\n            qp (QPainter): painter to draw on\n            bound (QRect): bounds to draw the chessboard in\n            dim (QSize): dimensions of a square on the chessboard\n        \"\"\"\n        if not self.should_draw_active_piece() or not self.enable_piece_to_cursor:\n            return\n        # draw possible destinations\n        for destination in self.active_piece_legal_move_destinations:\n            x, y = self.square_to_coords(\n                destination, bound.width(), bound.height())\n            qp.setPen(QColor(0, 0, 0, 255))\n            qp.drawEllipse(QPoint(x + bound.x() + dim.width // 2, y + bound.y() + dim.height // 2),\n                           dim.width // 6, dim.height // 6)\n            qp.drawEllipse(QPoint(x + bound.x() + dim.width // 2, y + bound.y() + dim.height // 2),\n                           dim.width // 5, dim.height // 5)\n        # draw piece itself\n        self.active_piece.drawOn(qp, QPoint(\n            int(self.mouse_x - (dim.width / 2)), int(self.mouse_y - (dim.height / 2))), dim)\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/","title":"chessboardwidget","text":""},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.PieceMovement","title":"<code>chessapp.view.chessboardwidget.PieceMovement</code>  <code>dataclass</code>","text":"<p>represents a move on a chessboard of a piece from a source square to a destination square</p> Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>@dataclass\nclass PieceMovement():\n    \"\"\" represents a move on a chessboard of a piece from a source square to a destination square\n    \"\"\"\n    source_square: str\n    destination_square: str\n\n    def uci_format(self) -&gt; str:\n        \"\"\" returns the move in UCI format\n\n        Returns:\n            str: the move in UCI format\n        \"\"\"\n        return self.source_square + self.destination_square\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.PieceMovement.uci_format","title":"<code>uci_format()</code>","text":"<p>returns the move in UCI format</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the move in UCI format</p> Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def uci_format(self) -&gt; str:\n    \"\"\" returns the move in UCI format\n\n    Returns:\n        str: the move in UCI format\n    \"\"\"\n    return self.source_square + self.destination_square\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget","title":"<code>chessapp.view.chessboardwidget.ChessBoardWidget</code>","text":"<p>             Bases: <code>QWidget</code></p> <p>a widget that displays a chessboard and allows to play moves. It also displays an eval bar if enabled.</p> Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>class ChessBoardWidget(QWidget):\n    \"\"\" a widget that displays a chessboard and allows to play moves. It also displays an eval bar if enabled.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\" constructor for the ChessBoardWidget class. It initializes the chessboard and the eval bar.\n        \"\"\"\n        super().__init__()\n        self.board = ChessBoard()\n        self.last_press_x = 0\n        self.last_press_y = 0\n        self.piece_movement_observer = []\n        self.back_actions = []\n        self.eval_bar = EvalBar()\n\n    def sizeHint(self) -&gt; QSize:\n        \"\"\" returns the size hint for the widget that is used to calculate the size of the widget\n\n        Returns:\n            QSize: the size hint for the widget\n        \"\"\"\n        return QSize(s_width_hint, s_height_hint)\n\n    def get_board_length(self) -&gt; int:\n        \"\"\" the length of the board is the minimum of the width and the height of the widget (the evalbar width is also respected).\n        the length then is used as a width and height of the bounding box of the chessboard.\n\n        Returns:\n            int: the length of the board\n        \"\"\"\n        return 8 * (min(self.width() - self.eval_bar.width, self.height()) // 8)\n\n    def paintEvent(self, event: QPaintEvent):\n        \"\"\" paints the widget and is called when the widget needs to be updated\n\n        Args:\n            event (QPaintEvent): the paint event\n        \"\"\"\n        qp = QPainter(self)\n        qp.fillRect(0, 0, self.width(), self.height(), Qt.GlobalColor.black)\n        # make sure there is enough width for an eval bar\n        if self.eval_bar.is_visible and self.width() &gt; 2 * s_eval_bar_min_width:\n            self.eval_bar.width = max(\n                s_eval_bar_min_width, int(self.width() * 0.03))\n            self.eval_bar.drawOn(\n                qp, QRect(0, 0, self.eval_bar.width, self.get_board_length()))\n        else:\n            self.eval_bar.width = 0\n        self.board.drawOn(qp, QRect(self.eval_bar.width, 0,\n                          self.get_board_length(), self.get_board_length()))\n\n    def display(self, board: Board, node: Node = None, previous_node: Node = None, last_move: chessapp.model.move.Move = None, show_last_move_icon: bool = True, last_move_is_opponent_move: bool = False, play_sound: bool = False):\n        \"\"\" displays the chessboard in a way that is compatible with the given board.\n\n            TODO: refactor the playing of sound. The sound should not be depend on when the move is displayed but when the move is played.\n\n        Args:\n            board (Board): the board to display\n            node (Node, optional): used to display the eval bar (e.g. evaluation value)\n            previous_node (Node, optional): used to calculate the last move cp loss to display corresponding last move icon (e.g. best move, blunder, etc.)\n            last_move (chessapp.model.move.Move, optional): the last move that was played (used together with previous_node to calculate the last move cp loss)\n            show_last_move_icon (bool, optional): True if the last move icon should be displayed.\n            last_move_is_opponent_move (bool, optional): true if the last move played was the opponent's move.\n            play_sound (bool, optional): true if a sound should be played when the last move is displayed.\n        \"\"\"\n        self.board.ascii_board = str(board)\n        self.board.legal_moves = []\n        for move in board.legal_moves:\n            self.board.legal_moves.append(move)\n        self.eval_bar.node = node\n        self.board.last_move_source = None\n        self.board.last_move_destination = None\n        self.board.last_move_is_best_known = False\n        self.board.last_move_is_book = False\n        self.board.best_move = None\n        self.board.show_last_move_icon = show_last_move_icon\n        if node:\n            move = node.get_best_move(min_depth=s_min_depth_best_move)\n            if move:\n                self.board.best_move = board.uci(board.parse_san(move.san))\n                self.board.best_move_cp_loss = node.get_cp_loss(move)\n        if previous_node and last_move:\n            previous_board = Board(previous_node.state)\n            try:\n                self.board.last_move_cp_loss = previous_node.get_cp_loss(\n                    last_move)\n                # https://www.reddit.com/r/ComputerChess/comments/qisai2/conversion_from_algebraic_notation_to_uci_notation/\n                uci_text = previous_board.push_san(last_move.san).uci()\n                self.board.last_move_destination = uci_text[2:]\n                self.board.last_move_source = uci_text[0:2]\n            except:\n                print(\"error while trying to set SquareIcon associated with last move\")\n                print(traceback.format_exc())\n            equivalent_move = previous_node.get_equivalent_move(last_move)\n            if equivalent_move:\n                last_move = equivalent_move\n            self.board.last_move_is_book = last_move.source == SourceType.BOOK\n            # can be None if no move is known\n            previous_node_best_move = previous_node.get_best_move()\n            self.board.last_move_is_best_known = previous_node_best_move and previous_node_best_move.is_equivalent_to(\n                last_move)\n            if node:\n                self.board.node_depth = node.eval_depth\n        self.update()\n        # play move sound\n        if play_sound:\n            if last_move and \"#\" in last_move.san:\n                ChessboardSound.GAME_END.play()\n            elif last_move and \"+\" in last_move.san:\n                ChessboardSound.MOVE_CHECK.play()\n            elif last_move and \"-\" in last_move.san:\n                ChessboardSound.MOVE_CASTLE.play()\n            elif last_move and \"x\" in last_move.san:\n                ChessboardSound.CAPTURE_PIECE.play()\n            elif last_move_is_opponent_move:\n                ChessboardSound.MOVE_OPPONENT.play()\n            else:\n                ChessboardSound.MOVE_SELF.play()\n\n    def flip_board(self):\n        \"\"\" flips the board and the eval bar\n        \"\"\"\n        self.board.flip()\n        self.eval_bar.flip()\n        self.update()\n\n    def view_white(self):\n        \"\"\" sets the perspective to white\n\n        TODO: is this even needed?\n        \"\"\"\n        self.perspective(\"w\")\n\n    def view_black(self):\n        \"\"\" sets the perspective to black\n\n        TODO: is this even needed?\n        \"\"\"\n        self.perspective(\"b\")\n\n    def perspective(self, perspective: str):\n        \"\"\" sets the perspective of the board\n\n        TODO: is this even needed?\n\n        Args:\n            perspective (str): \"w\" for white, \"b\" for black\n        \"\"\"\n        self.board.flip_board = perspective != \"w\"\n        self.eval_bar.is_flipped = perspective != \"w\"\n        self.update()\n\n    def is_inside_bounding_box(self, event: QMouseEvent) -&gt; bool:\n        \"\"\" checks if the event is inside the bounding box of the chessboard\n\n        Args:\n            event (QMouseEvent): the mouse event\n\n        Returns:\n            bool: true if the event is inside the bounding box of the chessboard\n        \"\"\"\n        return self.eval_bar.width &lt; event.x() and event.x() &lt; self.get_board_length(\n        ) + self.eval_bar.width and event.y() &lt; self.get_board_length() and event.y() &gt;= 0\n\n    def keyReleaseEvent(self, key_event: QKeyEvent) -&gt; None:\n        \"\"\" handles the key release event. If the left arrow key or the backspace key is pressed, the back actions are executed.\n\n        Args:\n            key_event (QKeyEvent): the key event\n        \"\"\"\n        if key_event.key() == Qt.Key.Key_Left or key_event.key() == Qt.Key.Key_Backspace:\n            for back_action in self.back_actions:\n                back_action()\n\n    def mousePressEvent(self, event: QMouseEvent) -&gt; None:\n        \"\"\" handles the mouse press event. If the left mouse button is pressed, the piece is selected if it is inside the bounding box of the chessboard.\n\n        Args:\n            event (QMouseEvent): the mouse event\n        \"\"\"\n        self.board.mouse_x = event.x()\n        self.board.mouse_y = event.y()\n        if self.is_inside_bounding_box(event) and event.button() == Qt.MouseButton.LeftButton:\n            self.board.select_piece(event.x() - self.eval_bar.width, event.y(),\n                                    self.get_board_length(), self.get_board_length())\n        self.board.enable_piece_to_cursor = True\n        self.update()\n\n    def mouseReleaseEvent(self, event: QMouseEvent) -&gt; None:\n        \"\"\" handles the mouse release event. If the left mouse button is released, the piece is moved if it is inside\n        the bounding box of the chessboard and the destination square is not the current square of the piece. If the\n        squares are the same then the peice is \"clicked\" and selected. This is used to display legal moves of the piece.\n        If the piece is actually moved then the piece movement observers are called.\n\n        Args:\n            event (QMouseEvent): the mouse event\n        \"\"\"\n        self.board.mouse_x = event.x()\n        self.board.mouse_y = event.y()\n        self.board.enable_piece_to_cursor = False\n        self.board.active_piece = None\n        if self.is_inside_bounding_box(event) and event.button() == Qt.MouseButton.LeftButton:\n            piece_movement = PieceMovement(self.board.active_piece_origin, self.board.coords_to_square(\n                event.x() - self.eval_bar.width, event.y(), self.get_board_length(), self.get_board_length()))\n            if piece_movement.source_square != piece_movement.destination_square:\n                if chess.Move.from_uci(piece_movement.uci_format()) in self.board.legal_moves:\n                    for observer in self.piece_movement_observer:\n                        observer(PieceMovement(self.board.active_piece_origin, self.board.coords_to_square(\n                            event.x() - self.eval_bar.width, event.y(), self.get_board_length(), self.get_board_length())))\n                else:\n                    ChessboardSound.MOVE_ILLEGAL.play()\n        self.update()\n\n    def mouseMoveEvent(self, event: QMouseEvent) -&gt; None:\n        \"\"\" handles the mouse move event. the position of the mouse is saved to handle the piece movement before the mouse\n        is released (e.g. drag and drop)\n\n        Args:\n            event (QMouseEvent): the mouse event\n        \"\"\"\n        self.board.mouse_x = event.x()\n        self.board.mouse_y = event.y()\n        self.update()\n\n    def reset(self):\n        \"\"\" resets the chessboard to its initial state\n        \"\"\"\n        self.last_press_x = 0\n        self.last_press_y = 0\n        self.board.last_move_destination = None\n        self.board.last_move_source = None\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.__init__","title":"<code>__init__()</code>","text":"<p>constructor for the ChessBoardWidget class. It initializes the chessboard and the eval bar.</p> Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def __init__(self):\n    \"\"\" constructor for the ChessBoardWidget class. It initializes the chessboard and the eval bar.\n    \"\"\"\n    super().__init__()\n    self.board = ChessBoard()\n    self.last_press_x = 0\n    self.last_press_y = 0\n    self.piece_movement_observer = []\n    self.back_actions = []\n    self.eval_bar = EvalBar()\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.display","title":"<code>display(board, node=None, previous_node=None, last_move=None, show_last_move_icon=True, last_move_is_opponent_move=False, play_sound=False)</code>","text":"<p>displays the chessboard in a way that is compatible with the given board.</p> <pre><code>TODO: refactor the playing of sound. The sound should not be depend on when the move is displayed but when the move is played.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>the board to display</p> required <code>node</code> <code>Node</code> <p>used to display the eval bar (e.g. evaluation value)</p> <code>None</code> <code>previous_node</code> <code>Node</code> <p>used to calculate the last move cp loss to display corresponding last move icon (e.g. best move, blunder, etc.)</p> <code>None</code> <code>last_move</code> <code>Move</code> <p>the last move that was played (used together with previous_node to calculate the last move cp loss)</p> <code>None</code> <code>show_last_move_icon</code> <code>bool</code> <p>True if the last move icon should be displayed.</p> <code>True</code> <code>last_move_is_opponent_move</code> <code>bool</code> <p>true if the last move played was the opponent's move.</p> <code>False</code> <code>play_sound</code> <code>bool</code> <p>true if a sound should be played when the last move is displayed.</p> <code>False</code> Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def display(self, board: Board, node: Node = None, previous_node: Node = None, last_move: chessapp.model.move.Move = None, show_last_move_icon: bool = True, last_move_is_opponent_move: bool = False, play_sound: bool = False):\n    \"\"\" displays the chessboard in a way that is compatible with the given board.\n\n        TODO: refactor the playing of sound. The sound should not be depend on when the move is displayed but when the move is played.\n\n    Args:\n        board (Board): the board to display\n        node (Node, optional): used to display the eval bar (e.g. evaluation value)\n        previous_node (Node, optional): used to calculate the last move cp loss to display corresponding last move icon (e.g. best move, blunder, etc.)\n        last_move (chessapp.model.move.Move, optional): the last move that was played (used together with previous_node to calculate the last move cp loss)\n        show_last_move_icon (bool, optional): True if the last move icon should be displayed.\n        last_move_is_opponent_move (bool, optional): true if the last move played was the opponent's move.\n        play_sound (bool, optional): true if a sound should be played when the last move is displayed.\n    \"\"\"\n    self.board.ascii_board = str(board)\n    self.board.legal_moves = []\n    for move in board.legal_moves:\n        self.board.legal_moves.append(move)\n    self.eval_bar.node = node\n    self.board.last_move_source = None\n    self.board.last_move_destination = None\n    self.board.last_move_is_best_known = False\n    self.board.last_move_is_book = False\n    self.board.best_move = None\n    self.board.show_last_move_icon = show_last_move_icon\n    if node:\n        move = node.get_best_move(min_depth=s_min_depth_best_move)\n        if move:\n            self.board.best_move = board.uci(board.parse_san(move.san))\n            self.board.best_move_cp_loss = node.get_cp_loss(move)\n    if previous_node and last_move:\n        previous_board = Board(previous_node.state)\n        try:\n            self.board.last_move_cp_loss = previous_node.get_cp_loss(\n                last_move)\n            # https://www.reddit.com/r/ComputerChess/comments/qisai2/conversion_from_algebraic_notation_to_uci_notation/\n            uci_text = previous_board.push_san(last_move.san).uci()\n            self.board.last_move_destination = uci_text[2:]\n            self.board.last_move_source = uci_text[0:2]\n        except:\n            print(\"error while trying to set SquareIcon associated with last move\")\n            print(traceback.format_exc())\n        equivalent_move = previous_node.get_equivalent_move(last_move)\n        if equivalent_move:\n            last_move = equivalent_move\n        self.board.last_move_is_book = last_move.source == SourceType.BOOK\n        # can be None if no move is known\n        previous_node_best_move = previous_node.get_best_move()\n        self.board.last_move_is_best_known = previous_node_best_move and previous_node_best_move.is_equivalent_to(\n            last_move)\n        if node:\n            self.board.node_depth = node.eval_depth\n    self.update()\n    # play move sound\n    if play_sound:\n        if last_move and \"#\" in last_move.san:\n            ChessboardSound.GAME_END.play()\n        elif last_move and \"+\" in last_move.san:\n            ChessboardSound.MOVE_CHECK.play()\n        elif last_move and \"-\" in last_move.san:\n            ChessboardSound.MOVE_CASTLE.play()\n        elif last_move and \"x\" in last_move.san:\n            ChessboardSound.CAPTURE_PIECE.play()\n        elif last_move_is_opponent_move:\n            ChessboardSound.MOVE_OPPONENT.play()\n        else:\n            ChessboardSound.MOVE_SELF.play()\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.flip_board","title":"<code>flip_board()</code>","text":"<p>flips the board and the eval bar</p> Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def flip_board(self):\n    \"\"\" flips the board and the eval bar\n    \"\"\"\n    self.board.flip()\n    self.eval_bar.flip()\n    self.update()\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.get_board_length","title":"<code>get_board_length()</code>","text":"<p>the length of the board is the minimum of the width and the height of the widget (the evalbar width is also respected). the length then is used as a width and height of the bounding box of the chessboard.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the length of the board</p> Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def get_board_length(self) -&gt; int:\n    \"\"\" the length of the board is the minimum of the width and the height of the widget (the evalbar width is also respected).\n    the length then is used as a width and height of the bounding box of the chessboard.\n\n    Returns:\n        int: the length of the board\n    \"\"\"\n    return 8 * (min(self.width() - self.eval_bar.width, self.height()) // 8)\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.is_inside_bounding_box","title":"<code>is_inside_bounding_box(event)</code>","text":"<p>checks if the event is inside the bounding box of the chessboard</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QMouseEvent</code> <p>the mouse event</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if the event is inside the bounding box of the chessboard</p> Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def is_inside_bounding_box(self, event: QMouseEvent) -&gt; bool:\n    \"\"\" checks if the event is inside the bounding box of the chessboard\n\n    Args:\n        event (QMouseEvent): the mouse event\n\n    Returns:\n        bool: true if the event is inside the bounding box of the chessboard\n    \"\"\"\n    return self.eval_bar.width &lt; event.x() and event.x() &lt; self.get_board_length(\n    ) + self.eval_bar.width and event.y() &lt; self.get_board_length() and event.y() &gt;= 0\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.keyReleaseEvent","title":"<code>keyReleaseEvent(key_event)</code>","text":"<p>handles the key release event. If the left arrow key or the backspace key is pressed, the back actions are executed.</p> <p>Parameters:</p> Name Type Description Default <code>key_event</code> <code>QKeyEvent</code> <p>the key event</p> required Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def keyReleaseEvent(self, key_event: QKeyEvent) -&gt; None:\n    \"\"\" handles the key release event. If the left arrow key or the backspace key is pressed, the back actions are executed.\n\n    Args:\n        key_event (QKeyEvent): the key event\n    \"\"\"\n    if key_event.key() == Qt.Key.Key_Left or key_event.key() == Qt.Key.Key_Backspace:\n        for back_action in self.back_actions:\n            back_action()\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.mouseMoveEvent","title":"<code>mouseMoveEvent(event)</code>","text":"<p>handles the mouse move event. the position of the mouse is saved to handle the piece movement before the mouse is released (e.g. drag and drop)</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QMouseEvent</code> <p>the mouse event</p> required Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def mouseMoveEvent(self, event: QMouseEvent) -&gt; None:\n    \"\"\" handles the mouse move event. the position of the mouse is saved to handle the piece movement before the mouse\n    is released (e.g. drag and drop)\n\n    Args:\n        event (QMouseEvent): the mouse event\n    \"\"\"\n    self.board.mouse_x = event.x()\n    self.board.mouse_y = event.y()\n    self.update()\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.mousePressEvent","title":"<code>mousePressEvent(event)</code>","text":"<p>handles the mouse press event. If the left mouse button is pressed, the piece is selected if it is inside the bounding box of the chessboard.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QMouseEvent</code> <p>the mouse event</p> required Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def mousePressEvent(self, event: QMouseEvent) -&gt; None:\n    \"\"\" handles the mouse press event. If the left mouse button is pressed, the piece is selected if it is inside the bounding box of the chessboard.\n\n    Args:\n        event (QMouseEvent): the mouse event\n    \"\"\"\n    self.board.mouse_x = event.x()\n    self.board.mouse_y = event.y()\n    if self.is_inside_bounding_box(event) and event.button() == Qt.MouseButton.LeftButton:\n        self.board.select_piece(event.x() - self.eval_bar.width, event.y(),\n                                self.get_board_length(), self.get_board_length())\n    self.board.enable_piece_to_cursor = True\n    self.update()\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.mouseReleaseEvent","title":"<code>mouseReleaseEvent(event)</code>","text":"<p>handles the mouse release event. If the left mouse button is released, the piece is moved if it is inside the bounding box of the chessboard and the destination square is not the current square of the piece. If the squares are the same then the peice is \"clicked\" and selected. This is used to display legal moves of the piece. If the piece is actually moved then the piece movement observers are called.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QMouseEvent</code> <p>the mouse event</p> required Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def mouseReleaseEvent(self, event: QMouseEvent) -&gt; None:\n    \"\"\" handles the mouse release event. If the left mouse button is released, the piece is moved if it is inside\n    the bounding box of the chessboard and the destination square is not the current square of the piece. If the\n    squares are the same then the peice is \"clicked\" and selected. This is used to display legal moves of the piece.\n    If the piece is actually moved then the piece movement observers are called.\n\n    Args:\n        event (QMouseEvent): the mouse event\n    \"\"\"\n    self.board.mouse_x = event.x()\n    self.board.mouse_y = event.y()\n    self.board.enable_piece_to_cursor = False\n    self.board.active_piece = None\n    if self.is_inside_bounding_box(event) and event.button() == Qt.MouseButton.LeftButton:\n        piece_movement = PieceMovement(self.board.active_piece_origin, self.board.coords_to_square(\n            event.x() - self.eval_bar.width, event.y(), self.get_board_length(), self.get_board_length()))\n        if piece_movement.source_square != piece_movement.destination_square:\n            if chess.Move.from_uci(piece_movement.uci_format()) in self.board.legal_moves:\n                for observer in self.piece_movement_observer:\n                    observer(PieceMovement(self.board.active_piece_origin, self.board.coords_to_square(\n                        event.x() - self.eval_bar.width, event.y(), self.get_board_length(), self.get_board_length())))\n            else:\n                ChessboardSound.MOVE_ILLEGAL.play()\n    self.update()\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.paintEvent","title":"<code>paintEvent(event)</code>","text":"<p>paints the widget and is called when the widget needs to be updated</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QPaintEvent</code> <p>the paint event</p> required Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def paintEvent(self, event: QPaintEvent):\n    \"\"\" paints the widget and is called when the widget needs to be updated\n\n    Args:\n        event (QPaintEvent): the paint event\n    \"\"\"\n    qp = QPainter(self)\n    qp.fillRect(0, 0, self.width(), self.height(), Qt.GlobalColor.black)\n    # make sure there is enough width for an eval bar\n    if self.eval_bar.is_visible and self.width() &gt; 2 * s_eval_bar_min_width:\n        self.eval_bar.width = max(\n            s_eval_bar_min_width, int(self.width() * 0.03))\n        self.eval_bar.drawOn(\n            qp, QRect(0, 0, self.eval_bar.width, self.get_board_length()))\n    else:\n        self.eval_bar.width = 0\n    self.board.drawOn(qp, QRect(self.eval_bar.width, 0,\n                      self.get_board_length(), self.get_board_length()))\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.perspective","title":"<code>perspective(perspective)</code>","text":"<p>sets the perspective of the board</p> <p>TODO: is this even needed?</p> <p>Parameters:</p> Name Type Description Default <code>perspective</code> <code>str</code> <p>\"w\" for white, \"b\" for black</p> required Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def perspective(self, perspective: str):\n    \"\"\" sets the perspective of the board\n\n    TODO: is this even needed?\n\n    Args:\n        perspective (str): \"w\" for white, \"b\" for black\n    \"\"\"\n    self.board.flip_board = perspective != \"w\"\n    self.eval_bar.is_flipped = perspective != \"w\"\n    self.update()\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.reset","title":"<code>reset()</code>","text":"<p>resets the chessboard to its initial state</p> Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def reset(self):\n    \"\"\" resets the chessboard to its initial state\n    \"\"\"\n    self.last_press_x = 0\n    self.last_press_y = 0\n    self.board.last_move_destination = None\n    self.board.last_move_source = None\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.sizeHint","title":"<code>sizeHint()</code>","text":"<p>returns the size hint for the widget that is used to calculate the size of the widget</p> <p>Returns:</p> Name Type Description <code>QSize</code> <code>QSize</code> <p>the size hint for the widget</p> Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def sizeHint(self) -&gt; QSize:\n    \"\"\" returns the size hint for the widget that is used to calculate the size of the widget\n\n    Returns:\n        QSize: the size hint for the widget\n    \"\"\"\n    return QSize(s_width_hint, s_height_hint)\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.view_black","title":"<code>view_black()</code>","text":"<p>sets the perspective to black</p> <p>TODO: is this even needed?</p> Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def view_black(self):\n    \"\"\" sets the perspective to black\n\n    TODO: is this even needed?\n    \"\"\"\n    self.perspective(\"b\")\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#chessapp.view.chessboardwidget.ChessBoardWidget.view_white","title":"<code>view_white()</code>","text":"<p>sets the perspective to white</p> <p>TODO: is this even needed?</p> Source code in <code>chessapp\\view\\chessboardwidget.py</code> <pre><code>def view_white(self):\n    \"\"\" sets the perspective to white\n\n    TODO: is this even needed?\n    \"\"\"\n    self.perspective(\"w\")\n</code></pre>"},{"location":"chessapp/view/chessboardwidget/#source","title":"Source","text":"<pre><code>import chess\nfrom PyQt5.QtGui import QKeyEvent, QMouseEvent, QPainter, QPaintEvent\nfrom PyQt5.QtCore import QRect, Qt, QSize\nfrom PyQt5.QtWidgets import QWidget\nfrom chessapp.view.chessboard import ChessBoard\nfrom chess import Board\nfrom chessapp.view.evalbar import EvalBar\nfrom chessapp.model.node import Node\nimport chessapp.model.move\nfrom chessapp.model.sourcetype import SourceType\nfrom chessapp.sound.chessboardsound import ChessboardSound\nimport traceback\nfrom dataclasses import dataclass\n\ns_size_scale = 100\ns_width_hint = 8 * s_size_scale\ns_height_hint = s_width_hint\ns_eval_bar_min_width = 10\ns_min_depth_best_move = 20\n\n\n@dataclass\nclass PieceMovement():\n    \"\"\" represents a move on a chessboard of a piece from a source square to a destination square\n    \"\"\"\n    source_square: str\n    destination_square: str\n\n    def uci_format(self) -&gt; str:\n        \"\"\" returns the move in UCI format\n\n        Returns:\n            str: the move in UCI format\n        \"\"\"\n        return self.source_square + self.destination_square\n\n\nclass ChessBoardWidget(QWidget):\n    \"\"\" a widget that displays a chessboard and allows to play moves. It also displays an eval bar if enabled.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\" constructor for the ChessBoardWidget class. It initializes the chessboard and the eval bar.\n        \"\"\"\n        super().__init__()\n        self.board = ChessBoard()\n        self.last_press_x = 0\n        self.last_press_y = 0\n        self.piece_movement_observer = []\n        self.back_actions = []\n        self.eval_bar = EvalBar()\n\n    def sizeHint(self) -&gt; QSize:\n        \"\"\" returns the size hint for the widget that is used to calculate the size of the widget\n\n        Returns:\n            QSize: the size hint for the widget\n        \"\"\"\n        return QSize(s_width_hint, s_height_hint)\n\n    def get_board_length(self) -&gt; int:\n        \"\"\" the length of the board is the minimum of the width and the height of the widget (the evalbar width is also respected).\n        the length then is used as a width and height of the bounding box of the chessboard.\n\n        Returns:\n            int: the length of the board\n        \"\"\"\n        return 8 * (min(self.width() - self.eval_bar.width, self.height()) // 8)\n\n    def paintEvent(self, event: QPaintEvent):\n        \"\"\" paints the widget and is called when the widget needs to be updated\n\n        Args:\n            event (QPaintEvent): the paint event\n        \"\"\"\n        qp = QPainter(self)\n        qp.fillRect(0, 0, self.width(), self.height(), Qt.GlobalColor.black)\n        # make sure there is enough width for an eval bar\n        if self.eval_bar.is_visible and self.width() &gt; 2 * s_eval_bar_min_width:\n            self.eval_bar.width = max(\n                s_eval_bar_min_width, int(self.width() * 0.03))\n            self.eval_bar.drawOn(\n                qp, QRect(0, 0, self.eval_bar.width, self.get_board_length()))\n        else:\n            self.eval_bar.width = 0\n        self.board.drawOn(qp, QRect(self.eval_bar.width, 0,\n                          self.get_board_length(), self.get_board_length()))\n\n    def display(self, board: Board, node: Node = None, previous_node: Node = None, last_move: chessapp.model.move.Move = None, show_last_move_icon: bool = True, last_move_is_opponent_move: bool = False, play_sound: bool = False):\n        \"\"\" displays the chessboard in a way that is compatible with the given board.\n\n            TODO: refactor the playing of sound. The sound should not be depend on when the move is displayed but when the move is played.\n\n        Args:\n            board (Board): the board to display\n            node (Node, optional): used to display the eval bar (e.g. evaluation value)\n            previous_node (Node, optional): used to calculate the last move cp loss to display corresponding last move icon (e.g. best move, blunder, etc.)\n            last_move (chessapp.model.move.Move, optional): the last move that was played (used together with previous_node to calculate the last move cp loss)\n            show_last_move_icon (bool, optional): True if the last move icon should be displayed.\n            last_move_is_opponent_move (bool, optional): true if the last move played was the opponent's move.\n            play_sound (bool, optional): true if a sound should be played when the last move is displayed.\n        \"\"\"\n        self.board.ascii_board = str(board)\n        self.board.legal_moves = []\n        for move in board.legal_moves:\n            self.board.legal_moves.append(move)\n        self.eval_bar.node = node\n        self.board.last_move_source = None\n        self.board.last_move_destination = None\n        self.board.last_move_is_best_known = False\n        self.board.last_move_is_book = False\n        self.board.best_move = None\n        self.board.show_last_move_icon = show_last_move_icon\n        if node:\n            move = node.get_best_move(min_depth=s_min_depth_best_move)\n            if move:\n                self.board.best_move = board.uci(board.parse_san(move.san))\n                self.board.best_move_cp_loss = node.get_cp_loss(move)\n        if previous_node and last_move:\n            previous_board = Board(previous_node.state)\n            try:\n                self.board.last_move_cp_loss = previous_node.get_cp_loss(\n                    last_move)\n                # https://www.reddit.com/r/ComputerChess/comments/qisai2/conversion_from_algebraic_notation_to_uci_notation/\n                uci_text = previous_board.push_san(last_move.san).uci()\n                self.board.last_move_destination = uci_text[2:]\n                self.board.last_move_source = uci_text[0:2]\n            except:\n                print(\"error while trying to set SquareIcon associated with last move\")\n                print(traceback.format_exc())\n            equivalent_move = previous_node.get_equivalent_move(last_move)\n            if equivalent_move:\n                last_move = equivalent_move\n            self.board.last_move_is_book = last_move.source == SourceType.BOOK\n            # can be None if no move is known\n            previous_node_best_move = previous_node.get_best_move()\n            self.board.last_move_is_best_known = previous_node_best_move and previous_node_best_move.is_equivalent_to(\n                last_move)\n            if node:\n                self.board.node_depth = node.eval_depth\n        self.update()\n        # play move sound\n        if play_sound:\n            if last_move and \"#\" in last_move.san:\n                ChessboardSound.GAME_END.play()\n            elif last_move and \"+\" in last_move.san:\n                ChessboardSound.MOVE_CHECK.play()\n            elif last_move and \"-\" in last_move.san:\n                ChessboardSound.MOVE_CASTLE.play()\n            elif last_move and \"x\" in last_move.san:\n                ChessboardSound.CAPTURE_PIECE.play()\n            elif last_move_is_opponent_move:\n                ChessboardSound.MOVE_OPPONENT.play()\n            else:\n                ChessboardSound.MOVE_SELF.play()\n\n    def flip_board(self):\n        \"\"\" flips the board and the eval bar\n        \"\"\"\n        self.board.flip()\n        self.eval_bar.flip()\n        self.update()\n\n    def view_white(self):\n        \"\"\" sets the perspective to white\n\n        TODO: is this even needed?\n        \"\"\"\n        self.perspective(\"w\")\n\n    def view_black(self):\n        \"\"\" sets the perspective to black\n\n        TODO: is this even needed?\n        \"\"\"\n        self.perspective(\"b\")\n\n    def perspective(self, perspective: str):\n        \"\"\" sets the perspective of the board\n\n        TODO: is this even needed?\n\n        Args:\n            perspective (str): \"w\" for white, \"b\" for black\n        \"\"\"\n        self.board.flip_board = perspective != \"w\"\n        self.eval_bar.is_flipped = perspective != \"w\"\n        self.update()\n\n    def is_inside_bounding_box(self, event: QMouseEvent) -&gt; bool:\n        \"\"\" checks if the event is inside the bounding box of the chessboard\n\n        Args:\n            event (QMouseEvent): the mouse event\n\n        Returns:\n            bool: true if the event is inside the bounding box of the chessboard\n        \"\"\"\n        return self.eval_bar.width &lt; event.x() and event.x() &lt; self.get_board_length(\n        ) + self.eval_bar.width and event.y() &lt; self.get_board_length() and event.y() &gt;= 0\n\n    def keyReleaseEvent(self, key_event: QKeyEvent) -&gt; None:\n        \"\"\" handles the key release event. If the left arrow key or the backspace key is pressed, the back actions are executed.\n\n        Args:\n            key_event (QKeyEvent): the key event\n        \"\"\"\n        if key_event.key() == Qt.Key.Key_Left or key_event.key() == Qt.Key.Key_Backspace:\n            for back_action in self.back_actions:\n                back_action()\n\n    def mousePressEvent(self, event: QMouseEvent) -&gt; None:\n        \"\"\" handles the mouse press event. If the left mouse button is pressed, the piece is selected if it is inside the bounding box of the chessboard.\n\n        Args:\n            event (QMouseEvent): the mouse event\n        \"\"\"\n        self.board.mouse_x = event.x()\n        self.board.mouse_y = event.y()\n        if self.is_inside_bounding_box(event) and event.button() == Qt.MouseButton.LeftButton:\n            self.board.select_piece(event.x() - self.eval_bar.width, event.y(),\n                                    self.get_board_length(), self.get_board_length())\n        self.board.enable_piece_to_cursor = True\n        self.update()\n\n    def mouseReleaseEvent(self, event: QMouseEvent) -&gt; None:\n        \"\"\" handles the mouse release event. If the left mouse button is released, the piece is moved if it is inside\n        the bounding box of the chessboard and the destination square is not the current square of the piece. If the\n        squares are the same then the peice is \"clicked\" and selected. This is used to display legal moves of the piece.\n        If the piece is actually moved then the piece movement observers are called.\n\n        Args:\n            event (QMouseEvent): the mouse event\n        \"\"\"\n        self.board.mouse_x = event.x()\n        self.board.mouse_y = event.y()\n        self.board.enable_piece_to_cursor = False\n        self.board.active_piece = None\n        if self.is_inside_bounding_box(event) and event.button() == Qt.MouseButton.LeftButton:\n            piece_movement = PieceMovement(self.board.active_piece_origin, self.board.coords_to_square(\n                event.x() - self.eval_bar.width, event.y(), self.get_board_length(), self.get_board_length()))\n            if piece_movement.source_square != piece_movement.destination_square:\n                if chess.Move.from_uci(piece_movement.uci_format()) in self.board.legal_moves:\n                    for observer in self.piece_movement_observer:\n                        observer(PieceMovement(self.board.active_piece_origin, self.board.coords_to_square(\n                            event.x() - self.eval_bar.width, event.y(), self.get_board_length(), self.get_board_length())))\n                else:\n                    ChessboardSound.MOVE_ILLEGAL.play()\n        self.update()\n\n    def mouseMoveEvent(self, event: QMouseEvent) -&gt; None:\n        \"\"\" handles the mouse move event. the position of the mouse is saved to handle the piece movement before the mouse\n        is released (e.g. drag and drop)\n\n        Args:\n            event (QMouseEvent): the mouse event\n        \"\"\"\n        self.board.mouse_x = event.x()\n        self.board.mouse_y = event.y()\n        self.update()\n\n    def reset(self):\n        \"\"\" resets the chessboard to its initial state\n        \"\"\"\n        self.last_press_x = 0\n        self.last_press_y = 0\n        self.board.last_move_destination = None\n        self.board.last_move_source = None\n</code></pre>"},{"location":"chessapp/view/evalbar/","title":"evalbar","text":""},{"location":"chessapp/view/evalbar/#chessapp.view.evalbar.EvalBar","title":"<code>chessapp.view.evalbar.EvalBar</code>","text":"<p>This class represents the evalbar of a chessboard. It is drawn on the left side of the chessboard and shows the evaluation of the current position. The evaluation is shown by a bar with coloring proportionally to the evaluation. In the center of the bar the evaluation is shown as text. The size of the text is chosen so that it fits into the bar (scaling fits). The bar is usually flipped if the chessboard gets flipped.</p> Source code in <code>chessapp\\view\\evalbar.py</code> <pre><code>class EvalBar():\n    \"\"\" This class represents the evalbar of a chessboard. It is drawn on the left side of the chessboard\n    and shows the evaluation of the current position. The evaluation is shown by a bar with coloring\n    proportionally to the evaluation. In the center of the bar the evaluation is shown as text. The size of\n    the text is chosen so that it fits into the bar (scaling fits). The bar is usually flipped if the chessboard\n    gets flipped.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\" Initializes the evalbar.\n        \"\"\"\n        self.width = 0\n        self.is_visible = False\n        self.node: Node = None\n        self.is_flipped = False\n\n    def flip(self):\n        \"\"\" Flips the evalbar. If the evalbar is flipped then white is on top and black on bottom. otherwise\n        black is on top and white on bottom.\n        \"\"\"\n        self.is_flipped = not self.is_flipped\n\n    def drawOn(self, qp: QPainter, bound: QRect):\n        \"\"\" Draws the evalbar on the given painter within the given bounds.\n\n        Args:\n            qp (QPainter): the painter to draw on\n            bound (QRect): the bounds to draw in\n        \"\"\"\n        # draw evalbar itself\n        second_color_height_percentage = (\n            MAX_EVALBAR_VALUE_ABS - self.node.eval) / (2 * MAX_EVALBAR_VALUE_ABS)\n        if self.is_flipped:\n            second_color_height_percentage = 1 - second_color_height_percentage\n        qp.fillRect(bound.x(), bound.y(), bound.width(), bound.height(\n        ), Qt.GlobalColor.black if self.is_flipped else Qt.GlobalColor.white)\n        qp.fillRect(bound.x(), bound.y(), bound.width(), int(second_color_height_percentage *\n                    bound.height()), Qt.GlobalColor.white if self.is_flipped else Qt.GlobalColor.black)\n        # draw evalbar text\n        font = qp.font()\n        eval_text: str = str(self.node.eval)\n        if self.node.eval &gt; 0:\n            eval_text = \"+\" + eval_text\n        elif self.node.eval == 0:\n            eval_text = \"=0.00\"\n        size = find_font_size(\n            QSize(bound.width(), bound.height()), eval_text)\n        font.setPointSize(size)\n        qp.setFont(font)\n        qp.drawText(bound, Qt.AlignCenter, eval_text)\n</code></pre>"},{"location":"chessapp/view/evalbar/#chessapp.view.evalbar.EvalBar.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the evalbar.</p> Source code in <code>chessapp\\view\\evalbar.py</code> <pre><code>def __init__(self):\n    \"\"\" Initializes the evalbar.\n    \"\"\"\n    self.width = 0\n    self.is_visible = False\n    self.node: Node = None\n    self.is_flipped = False\n</code></pre>"},{"location":"chessapp/view/evalbar/#chessapp.view.evalbar.EvalBar.drawOn","title":"<code>drawOn(qp, bound)</code>","text":"<p>Draws the evalbar on the given painter within the given bounds.</p> <p>Parameters:</p> Name Type Description Default <code>qp</code> <code>QPainter</code> <p>the painter to draw on</p> required <code>bound</code> <code>QRect</code> <p>the bounds to draw in</p> required Source code in <code>chessapp\\view\\evalbar.py</code> <pre><code>def drawOn(self, qp: QPainter, bound: QRect):\n    \"\"\" Draws the evalbar on the given painter within the given bounds.\n\n    Args:\n        qp (QPainter): the painter to draw on\n        bound (QRect): the bounds to draw in\n    \"\"\"\n    # draw evalbar itself\n    second_color_height_percentage = (\n        MAX_EVALBAR_VALUE_ABS - self.node.eval) / (2 * MAX_EVALBAR_VALUE_ABS)\n    if self.is_flipped:\n        second_color_height_percentage = 1 - second_color_height_percentage\n    qp.fillRect(bound.x(), bound.y(), bound.width(), bound.height(\n    ), Qt.GlobalColor.black if self.is_flipped else Qt.GlobalColor.white)\n    qp.fillRect(bound.x(), bound.y(), bound.width(), int(second_color_height_percentage *\n                bound.height()), Qt.GlobalColor.white if self.is_flipped else Qt.GlobalColor.black)\n    # draw evalbar text\n    font = qp.font()\n    eval_text: str = str(self.node.eval)\n    if self.node.eval &gt; 0:\n        eval_text = \"+\" + eval_text\n    elif self.node.eval == 0:\n        eval_text = \"=0.00\"\n    size = find_font_size(\n        QSize(bound.width(), bound.height()), eval_text)\n    font.setPointSize(size)\n    qp.setFont(font)\n    qp.drawText(bound, Qt.AlignCenter, eval_text)\n</code></pre>"},{"location":"chessapp/view/evalbar/#chessapp.view.evalbar.EvalBar.flip","title":"<code>flip()</code>","text":"<p>Flips the evalbar. If the evalbar is flipped then white is on top and black on bottom. otherwise black is on top and white on bottom.</p> Source code in <code>chessapp\\view\\evalbar.py</code> <pre><code>def flip(self):\n    \"\"\" Flips the evalbar. If the evalbar is flipped then white is on top and black on bottom. otherwise\n    black is on top and white on bottom.\n    \"\"\"\n    self.is_flipped = not self.is_flipped\n</code></pre>"},{"location":"chessapp/view/evalbar/#source","title":"Source","text":"<pre><code>from PyQt5.QtGui import QPainter\nfrom PyQt5.QtCore import QRect, QSize, Qt\nfrom chessapp.model.node import Node\nfrom chessapp.configuration import MAX_EVALBAR_VALUE_ABS\nfrom chessapp.util.font import find_font_size\n\n\nclass EvalBar():\n    \"\"\" This class represents the evalbar of a chessboard. It is drawn on the left side of the chessboard\n    and shows the evaluation of the current position. The evaluation is shown by a bar with coloring\n    proportionally to the evaluation. In the center of the bar the evaluation is shown as text. The size of\n    the text is chosen so that it fits into the bar (scaling fits). The bar is usually flipped if the chessboard\n    gets flipped.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\" Initializes the evalbar.\n        \"\"\"\n        self.width = 0\n        self.is_visible = False\n        self.node: Node = None\n        self.is_flipped = False\n\n    def flip(self):\n        \"\"\" Flips the evalbar. If the evalbar is flipped then white is on top and black on bottom. otherwise\n        black is on top and white on bottom.\n        \"\"\"\n        self.is_flipped = not self.is_flipped\n\n    def drawOn(self, qp: QPainter, bound: QRect):\n        \"\"\" Draws the evalbar on the given painter within the given bounds.\n\n        Args:\n            qp (QPainter): the painter to draw on\n            bound (QRect): the bounds to draw in\n        \"\"\"\n        # draw evalbar itself\n        second_color_height_percentage = (\n            MAX_EVALBAR_VALUE_ABS - self.node.eval) / (2 * MAX_EVALBAR_VALUE_ABS)\n        if self.is_flipped:\n            second_color_height_percentage = 1 - second_color_height_percentage\n        qp.fillRect(bound.x(), bound.y(), bound.width(), bound.height(\n        ), Qt.GlobalColor.black if self.is_flipped else Qt.GlobalColor.white)\n        qp.fillRect(bound.x(), bound.y(), bound.width(), int(second_color_height_percentage *\n                    bound.height()), Qt.GlobalColor.white if self.is_flipped else Qt.GlobalColor.black)\n        # draw evalbar text\n        font = qp.font()\n        eval_text: str = str(self.node.eval)\n        if self.node.eval &gt; 0:\n            eval_text = \"+\" + eval_text\n        elif self.node.eval == 0:\n            eval_text = \"=0.00\"\n        size = find_font_size(\n            QSize(bound.width(), bound.height()), eval_text)\n        font.setPointSize(size)\n        qp.setFont(font)\n        qp.drawText(bound, Qt.AlignCenter, eval_text)\n</code></pre>"},{"location":"chessapp/view/module/","title":"module","text":""},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule","title":"<code>chessapp.view.module.BaseModule</code>","text":"<p>             Bases: <code>QObject</code></p> <p>A module is a widget that offers the user GUI interactions with the program. It is registered in the menu bar with its own menu item whose display name is given by display_name. The menu item has a \"Focus\" action that makes the modules' central_widget the AppWindow's central widget. The central_widget is a QWidget that contains a QVBoxLayout with a header label, the main widget and a footer label. The main_widget is a QWidget that contains the main content of the module.</p> <p>Only change the content of main_widget or the text of the header_label and footer_label!</p> <p>TODO: This class needs to be refactored! The chessapp.controller classes are derived from it which mixes GUI and logic. Instead a controller should be able to offer a GUI-element to the application and interact through it with the user and vice versa.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>class BaseModule(QObject):\n    \"\"\" A module is a widget that offers the user GUI interactions with the program. It is registered in the menu bar with\n    its own menu item whose display name is given by display_name. The menu item has a \"Focus\" action that makes the modules'\n    central_widget the AppWindow's central widget. The central_widget is a QWidget that contains a QVBoxLayout with a header\n    label, the main widget and a footer label. The main_widget is a QWidget that contains the main content of the module.\n\n    Only change the content of main_widget or the text of the header_label and footer_label!\n\n    TODO: This class needs to be refactored! The chessapp.controller classes are derived from it which mixes GUI and logic. Instead a controller should be able to offer a GUI-element to the application and interact through it with the user and vice versa.\n    \"\"\"\n\n    def __init__(self, app, display_name: str, actions: list[QAction]) -&gt; None:\n        \"\"\" initialises the module with the given parameters. The module is not focused after initialisation. After\n        initialising this class the method init needs to be called on the GUI thread to finish up the initialisation.\n\n        Args:\n            app (ChessApp): the main application\n            display_name (str): the name of the module that is displayed in the menu bar\n            actions (list[QAction]): a list of actions that are displayed in the menu of the module\n        \"\"\"\n        super().__init__()\n        self.app = app\n        self.display_name: str = display_name\n        self.is_focused = False\n        self.central_widget = QWidget()\n        self.main_widget = QWidget()\n        self.header_label = QLabel()\n        self.footer_label = QLabel()\n        self.actions: [QAction] = actions\n        self.is_closing = False\n        self.is_closed = False\n\n    def init(self) -&gt; None:\n        \"\"\" call this method only once per instance and only on the GUI thread. This method finishes the initialisation of\n        the module.\n        \"\"\"\n        # widget configuration\n        self.header_label.setAlignment(Qt.AlignCenter)\n        self.header_label.setFont(QFont(\"Times\", 20, QFont.Bold))\n        self.footer_label.setAlignment(Qt.AlignCenter)\n        self.central_widget.setStyleSheet(\n            self.central_widget.styleSheet() + \";\" + DEFAULT_STYLESHEET)\n\n        # header, main, footer\n        v_layout = QVBoxLayout()\n        self.central_widget.setLayout(v_layout)\n        v_layout.addWidget(self.header_label)\n        v_layout.addWidget(self.main_widget)\n        v_layout.addWidget(self.footer_label)\n\n        # default values\n        self.header_label.setText(self.display_name)\n\n    def register(self):\n        \"\"\" this method is only called once by the main application. Don't call this in any other way.\n        It registers the module in the menu bar with the \"Focus\" action and the actions given in the constructor.\n        \"\"\"\n        menu_bar: QMenuBar = self.app.window.menuBar()\n        menu: QMenu = menu_bar.addMenu(\"&amp;\" + self.display_name)\n        focus_action = QAction(\"&amp;Focus\", self.app.window)\n        focus_action.triggered.connect(\n            lambda: self.app.threadpool.start(MethodAction(self.focus)))\n        menu.addAction(focus_action)\n        for action in self.actions:\n            menu.addAction(action)\n        self.on_register()\n\n    def about_to_close(self) -&gt; bool:\n        \"\"\" returns True if the module is about to close or is already closed. Closing happens when the main application\n        closes down itself. This method is used as an indicator by deriving classes to determine if it is feasible or\n        not to continue actions. Often it is prudent to include this method inside loops to abort actions when the program\n        wants to close.\n\n        Returns:\n            bool: True if the module is about to close or is already closed\n        \"\"\"\n        return self.is_closing or self.is_closed\n\n    def on_register(self):\n        \"\"\" override this method to react to the registration of the module in the main application.\n        \"\"\"\n        pass\n\n    def on_close(self):\n        \"\"\" override this method to react to the closing of the module.\n        \"\"\"\n        pass\n\n    def close(self):\n        \"\"\" closes the module\n        \"\"\"\n        if self.about_to_close():\n            return\n        self.is_closing = True\n        self.on_close()\n        # this way around \"self.about_to_close()\" stays True\n        self.is_closed = True\n        self.is_closing = False\n\n    def focus(self):\n        \"\"\" focuses this module by setting its central_widget as the main application's central widget and unfocusing all\n        other modules. This method is called by the \"Focus\" action in the menu bar.\n        \"\"\"\n        if self.is_focused:\n            return\n        self.app.unfocus_all_modules()\n        self.app.set_central_widget(self.central_widget)\n        self.is_focused = True\n        self.on_focus()\n\n    def unfocus(self):\n        \"\"\" unfocuses this module.\n        \"\"\"\n        if not self.is_focused:\n            return\n        self.is_focused = False\n        self.on_unfocus()\n\n    def on_focus(self):\n        \"\"\" override this method to react to the focusing of the module.\n        \"\"\"\n        pass\n\n    def on_unfocus(self):\n        \"\"\" override this method to react to the unfocusing of the module.\n        \"\"\"\n        pass\n\n    def dispatch_threadpool(self, callable):\n        \"\"\" dispatches the given callable to the threadpool of the main application.\n\n        Args:\n            callable (callable): any callable object like a method of an object or a lambda function\n        \"\"\"\n        self.app.threadpool.start(MethodAction(callable))\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule.__init__","title":"<code>__init__(app, display_name, actions)</code>","text":"<p>initialises the module with the given parameters. The module is not focused after initialisation. After initialising this class the method init needs to be called on the GUI thread to finish up the initialisation.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>ChessApp</code> <p>the main application</p> required <code>display_name</code> <code>str</code> <p>the name of the module that is displayed in the menu bar</p> required <code>actions</code> <code>list[QAction]</code> <p>a list of actions that are displayed in the menu of the module</p> required Source code in <code>chessapp\\view\\module.py</code> <pre><code>def __init__(self, app, display_name: str, actions: list[QAction]) -&gt; None:\n    \"\"\" initialises the module with the given parameters. The module is not focused after initialisation. After\n    initialising this class the method init needs to be called on the GUI thread to finish up the initialisation.\n\n    Args:\n        app (ChessApp): the main application\n        display_name (str): the name of the module that is displayed in the menu bar\n        actions (list[QAction]): a list of actions that are displayed in the menu of the module\n    \"\"\"\n    super().__init__()\n    self.app = app\n    self.display_name: str = display_name\n    self.is_focused = False\n    self.central_widget = QWidget()\n    self.main_widget = QWidget()\n    self.header_label = QLabel()\n    self.footer_label = QLabel()\n    self.actions: [QAction] = actions\n    self.is_closing = False\n    self.is_closed = False\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule.about_to_close","title":"<code>about_to_close()</code>","text":"<p>returns True if the module is about to close or is already closed. Closing happens when the main application closes down itself. This method is used as an indicator by deriving classes to determine if it is feasible or not to continue actions. Often it is prudent to include this method inside loops to abort actions when the program wants to close.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the module is about to close or is already closed</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def about_to_close(self) -&gt; bool:\n    \"\"\" returns True if the module is about to close or is already closed. Closing happens when the main application\n    closes down itself. This method is used as an indicator by deriving classes to determine if it is feasible or\n    not to continue actions. Often it is prudent to include this method inside loops to abort actions when the program\n    wants to close.\n\n    Returns:\n        bool: True if the module is about to close or is already closed\n    \"\"\"\n    return self.is_closing or self.is_closed\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule.close","title":"<code>close()</code>","text":"<p>closes the module</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def close(self):\n    \"\"\" closes the module\n    \"\"\"\n    if self.about_to_close():\n        return\n    self.is_closing = True\n    self.on_close()\n    # this way around \"self.about_to_close()\" stays True\n    self.is_closed = True\n    self.is_closing = False\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule.dispatch_threadpool","title":"<code>dispatch_threadpool(callable)</code>","text":"<p>dispatches the given callable to the threadpool of the main application.</p> <p>Parameters:</p> Name Type Description Default <code>callable</code> <code>callable</code> <p>any callable object like a method of an object or a lambda function</p> required Source code in <code>chessapp\\view\\module.py</code> <pre><code>def dispatch_threadpool(self, callable):\n    \"\"\" dispatches the given callable to the threadpool of the main application.\n\n    Args:\n        callable (callable): any callable object like a method of an object or a lambda function\n    \"\"\"\n    self.app.threadpool.start(MethodAction(callable))\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule.focus","title":"<code>focus()</code>","text":"<p>focuses this module by setting its central_widget as the main application's central widget and unfocusing all other modules. This method is called by the \"Focus\" action in the menu bar.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def focus(self):\n    \"\"\" focuses this module by setting its central_widget as the main application's central widget and unfocusing all\n    other modules. This method is called by the \"Focus\" action in the menu bar.\n    \"\"\"\n    if self.is_focused:\n        return\n    self.app.unfocus_all_modules()\n    self.app.set_central_widget(self.central_widget)\n    self.is_focused = True\n    self.on_focus()\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule.init","title":"<code>init()</code>","text":"<p>call this method only once per instance and only on the GUI thread. This method finishes the initialisation of the module.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def init(self) -&gt; None:\n    \"\"\" call this method only once per instance and only on the GUI thread. This method finishes the initialisation of\n    the module.\n    \"\"\"\n    # widget configuration\n    self.header_label.setAlignment(Qt.AlignCenter)\n    self.header_label.setFont(QFont(\"Times\", 20, QFont.Bold))\n    self.footer_label.setAlignment(Qt.AlignCenter)\n    self.central_widget.setStyleSheet(\n        self.central_widget.styleSheet() + \";\" + DEFAULT_STYLESHEET)\n\n    # header, main, footer\n    v_layout = QVBoxLayout()\n    self.central_widget.setLayout(v_layout)\n    v_layout.addWidget(self.header_label)\n    v_layout.addWidget(self.main_widget)\n    v_layout.addWidget(self.footer_label)\n\n    # default values\n    self.header_label.setText(self.display_name)\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule.on_close","title":"<code>on_close()</code>","text":"<p>override this method to react to the closing of the module.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def on_close(self):\n    \"\"\" override this method to react to the closing of the module.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule.on_focus","title":"<code>on_focus()</code>","text":"<p>override this method to react to the focusing of the module.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def on_focus(self):\n    \"\"\" override this method to react to the focusing of the module.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule.on_register","title":"<code>on_register()</code>","text":"<p>override this method to react to the registration of the module in the main application.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def on_register(self):\n    \"\"\" override this method to react to the registration of the module in the main application.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule.on_unfocus","title":"<code>on_unfocus()</code>","text":"<p>override this method to react to the unfocusing of the module.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def on_unfocus(self):\n    \"\"\" override this method to react to the unfocusing of the module.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule.register","title":"<code>register()</code>","text":"<p>this method is only called once by the main application. Don't call this in any other way. It registers the module in the menu bar with the \"Focus\" action and the actions given in the constructor.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def register(self):\n    \"\"\" this method is only called once by the main application. Don't call this in any other way.\n    It registers the module in the menu bar with the \"Focus\" action and the actions given in the constructor.\n    \"\"\"\n    menu_bar: QMenuBar = self.app.window.menuBar()\n    menu: QMenu = menu_bar.addMenu(\"&amp;\" + self.display_name)\n    focus_action = QAction(\"&amp;Focus\", self.app.window)\n    focus_action.triggered.connect(\n        lambda: self.app.threadpool.start(MethodAction(self.focus)))\n    menu.addAction(focus_action)\n    for action in self.actions:\n        menu.addAction(action)\n    self.on_register()\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.BaseModule.unfocus","title":"<code>unfocus()</code>","text":"<p>unfocuses this module.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def unfocus(self):\n    \"\"\" unfocuses this module.\n    \"\"\"\n    if not self.is_focused:\n        return\n    self.is_focused = False\n    self.on_unfocus()\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.LogModule","title":"<code>chessapp.view.module.LogModule</code>","text":"<p>             Bases: <code>BaseModule</code></p> <p>This derivation adds a log widget to the main widget. The log widget is a QListWidget that displays log messages.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>class LogModule(BaseModule):\n    \"\"\" This derivation adds a log widget to the main widget. The log widget is a QListWidget that displays log messages.\n    \"\"\"\n\n    log_message_received = pyqtSignal(str)\n\n    def __init__(self, app, display_name: str, actions: list[QAction]):\n        \"\"\" basically only calls the constructor of BaseModule and initialises the log widget.\n\n        Args:\n            app (ChessApp): the main application\n            display_name (str): the name of the module that is displayed in the menu bar\n            actions (list[QAction]): the actions that are displayed in the menu of the module\n        \"\"\"\n        super().__init__(app, display_name, actions)\n        self.log_widget = QListWidget()\n\n    def init(self):\n        \"\"\" @see BaseModule.init. Adds the log widget to the main widget.\n        \"\"\"\n        super().init()\n        # main: log\n        v_Layout = QVBoxLayout()\n        self.main_widget.setLayout(v_Layout)\n        v_Layout.addWidget(self.log_widget)\n        # connections\n        self.log_message_received.connect(self.__log_message)\n\n    def log_message(self, message: str, timeout_milliseconds: int = 2000):\n        \"\"\" logs the given message in the log widget and shows it as a status message in the status bar of the main application.\n\n        Args:\n            message (str): the message to log\n            timeout_milliseconds (int, optional): the timeout of the status message in milliseconds.\n        \"\"\"\n        self.log_message_received.emit(message)\n        self.app.show_status_message(message, timeout_milliseconds)\n\n    def __log_message(self, message: str):\n        \"\"\" internal method that is called by the GUI thread when a new status message is received.\n\n        Args:\n            message (str): the message to log\n        \"\"\"\n        QListWidgetItem(message, self.log_widget)\n        self.log_widget.scrollToBottom()\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.LogModule.__init__","title":"<code>__init__(app, display_name, actions)</code>","text":"<p>basically only calls the constructor of BaseModule and initialises the log widget.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>ChessApp</code> <p>the main application</p> required <code>display_name</code> <code>str</code> <p>the name of the module that is displayed in the menu bar</p> required <code>actions</code> <code>list[QAction]</code> <p>the actions that are displayed in the menu of the module</p> required Source code in <code>chessapp\\view\\module.py</code> <pre><code>def __init__(self, app, display_name: str, actions: list[QAction]):\n    \"\"\" basically only calls the constructor of BaseModule and initialises the log widget.\n\n    Args:\n        app (ChessApp): the main application\n        display_name (str): the name of the module that is displayed in the menu bar\n        actions (list[QAction]): the actions that are displayed in the menu of the module\n    \"\"\"\n    super().__init__(app, display_name, actions)\n    self.log_widget = QListWidget()\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.LogModule.__log_message","title":"<code>__log_message(message)</code>","text":"<p>internal method that is called by the GUI thread when a new status message is received.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message to log</p> required Source code in <code>chessapp\\view\\module.py</code> <pre><code>def __log_message(self, message: str):\n    \"\"\" internal method that is called by the GUI thread when a new status message is received.\n\n    Args:\n        message (str): the message to log\n    \"\"\"\n    QListWidgetItem(message, self.log_widget)\n    self.log_widget.scrollToBottom()\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.LogModule.init","title":"<code>init()</code>","text":"<p>@see BaseModule.init. Adds the log widget to the main widget.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def init(self):\n    \"\"\" @see BaseModule.init. Adds the log widget to the main widget.\n    \"\"\"\n    super().init()\n    # main: log\n    v_Layout = QVBoxLayout()\n    self.main_widget.setLayout(v_Layout)\n    v_Layout.addWidget(self.log_widget)\n    # connections\n    self.log_message_received.connect(self.__log_message)\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.LogModule.log_message","title":"<code>log_message(message, timeout_milliseconds=2000)</code>","text":"<p>logs the given message in the log widget and shows it as a status message in the status bar of the main application.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message to log</p> required <code>timeout_milliseconds</code> <code>int</code> <p>the timeout of the status message in milliseconds.</p> <code>2000</code> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def log_message(self, message: str, timeout_milliseconds: int = 2000):\n    \"\"\" logs the given message in the log widget and shows it as a status message in the status bar of the main application.\n\n    Args:\n        message (str): the message to log\n        timeout_milliseconds (int, optional): the timeout of the status message in milliseconds.\n    \"\"\"\n    self.log_message_received.emit(message)\n    self.app.show_status_message(message, timeout_milliseconds)\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.ChessboardAndLogModule","title":"<code>chessapp.view.module.ChessboardAndLogModule</code>","text":"<p>             Bases: <code>LogModule</code></p> <p>This derivation adds a ChessBoardWidget left of the log widget as a sort of split-screen. Override on_piece_movement and on_back to react to the user's actions on the chess board.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>class ChessboardAndLogModule(LogModule):\n    \"\"\" This derivation adds a ChessBoardWidget left of the log widget as a sort of split-screen. Override\n    on_piece_movement and on_back to react to the user's actions on the chess board.\n    \"\"\"\n\n    def __init__(self, app, display_name: str, actions: list[QAction]):\n        \"\"\" basically only calls the constructor of LogModule and initialises the ChessBoardWidget.\n\n        Args:\n            app (ChessApp): the main application\n            display_name (str): the name of the module that is displayed in the menu bar\n            actions (list[QAction]): the actions that are displayed in the menu of the module\n        \"\"\"\n        super().__init__(app, display_name, actions)\n        self.chess_board_widget = ChessBoardWidget()\n        self.chess_board_widget.piece_movement_observer.append(\n            self.on_piece_movement)\n        self.chess_board_widget.back_actions.append(\n            self.on_back)\n\n    def init(self):\n        \"\"\" @see LogModule.init. Adds the ChessBoardWidget to the main widget. In order to show the ChessBoardWidget\n        split-screen the log widget first needs to be removed from the main_widget and then placed inside it again.\n        TODO: change this behaviour so that the log widget is not removed and placed inside the main widget again.\n        \"\"\"\n        super().init()\n        # reset main widget because it is used differently in LogModule. also reset parent of log widget so that it is not deleted when\n        # the main widget is deleted/removed as a child\n        self.log_widget.setParent(None)\n        QWidget().setLayout(self.main_widget.layout())\n        # main: left chess board, right log\n        h_Layout = QHBoxLayout()\n        self.main_widget.setLayout(h_Layout)\n        h_Layout.addWidget(self.chess_board_widget)\n        h_Layout.addWidget(self.log_widget)\n\n    def on_piece_movement(self, piece_movement: PieceMovement):\n        \"\"\" this method is called when a piece has been move by the user on the chess board. Override this method\n        to react to this user input.\n\n        Args:\n            piece_movement (PieceMovement): the piece movement that has been performed\n        \"\"\"\n        pass\n\n    def on_back(self):\n        \"\"\" this method is called when the user presses the back button on the chess board. Override this method\n        to react to this user input.\n        \"\"\"\n        pass\n\n    def on_focus(self):\n        \"\"\" @see LogModule.on_focus. This method grabs the keyboard so that the ChessBoardWidget can receive keyboard\n        input by the user.\n        \"\"\"\n        super().on_focus()\n        self.chess_board_widget.grabKeyboard()\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.ChessboardAndLogModule.__init__","title":"<code>__init__(app, display_name, actions)</code>","text":"<p>basically only calls the constructor of LogModule and initialises the ChessBoardWidget.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>ChessApp</code> <p>the main application</p> required <code>display_name</code> <code>str</code> <p>the name of the module that is displayed in the menu bar</p> required <code>actions</code> <code>list[QAction]</code> <p>the actions that are displayed in the menu of the module</p> required Source code in <code>chessapp\\view\\module.py</code> <pre><code>def __init__(self, app, display_name: str, actions: list[QAction]):\n    \"\"\" basically only calls the constructor of LogModule and initialises the ChessBoardWidget.\n\n    Args:\n        app (ChessApp): the main application\n        display_name (str): the name of the module that is displayed in the menu bar\n        actions (list[QAction]): the actions that are displayed in the menu of the module\n    \"\"\"\n    super().__init__(app, display_name, actions)\n    self.chess_board_widget = ChessBoardWidget()\n    self.chess_board_widget.piece_movement_observer.append(\n        self.on_piece_movement)\n    self.chess_board_widget.back_actions.append(\n        self.on_back)\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.ChessboardAndLogModule.init","title":"<code>init()</code>","text":"<p>@see LogModule.init. Adds the ChessBoardWidget to the main widget. In order to show the ChessBoardWidget split-screen the log widget first needs to be removed from the main_widget and then placed inside it again. TODO: change this behaviour so that the log widget is not removed and placed inside the main widget again.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def init(self):\n    \"\"\" @see LogModule.init. Adds the ChessBoardWidget to the main widget. In order to show the ChessBoardWidget\n    split-screen the log widget first needs to be removed from the main_widget and then placed inside it again.\n    TODO: change this behaviour so that the log widget is not removed and placed inside the main widget again.\n    \"\"\"\n    super().init()\n    # reset main widget because it is used differently in LogModule. also reset parent of log widget so that it is not deleted when\n    # the main widget is deleted/removed as a child\n    self.log_widget.setParent(None)\n    QWidget().setLayout(self.main_widget.layout())\n    # main: left chess board, right log\n    h_Layout = QHBoxLayout()\n    self.main_widget.setLayout(h_Layout)\n    h_Layout.addWidget(self.chess_board_widget)\n    h_Layout.addWidget(self.log_widget)\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.ChessboardAndLogModule.on_back","title":"<code>on_back()</code>","text":"<p>this method is called when the user presses the back button on the chess board. Override this method to react to this user input.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def on_back(self):\n    \"\"\" this method is called when the user presses the back button on the chess board. Override this method\n    to react to this user input.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.ChessboardAndLogModule.on_focus","title":"<code>on_focus()</code>","text":"<p>@see LogModule.on_focus. This method grabs the keyboard so that the ChessBoardWidget can receive keyboard input by the user.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def on_focus(self):\n    \"\"\" @see LogModule.on_focus. This method grabs the keyboard so that the ChessBoardWidget can receive keyboard\n    input by the user.\n    \"\"\"\n    super().on_focus()\n    self.chess_board_widget.grabKeyboard()\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.ChessboardAndLogModule.on_piece_movement","title":"<code>on_piece_movement(piece_movement)</code>","text":"<p>this method is called when a piece has been move by the user on the chess board. Override this method to react to this user input.</p> <p>Parameters:</p> Name Type Description Default <code>piece_movement</code> <code>PieceMovement</code> <p>the piece movement that has been performed</p> required Source code in <code>chessapp\\view\\module.py</code> <pre><code>def on_piece_movement(self, piece_movement: PieceMovement):\n    \"\"\" this method is called when a piece has been move by the user on the chess board. Override this method\n    to react to this user input.\n\n    Args:\n        piece_movement (PieceMovement): the piece movement that has been performed\n    \"\"\"\n    pass\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.MethodAction","title":"<code>chessapp.view.module.MethodAction</code>","text":"<p>             Bases: <code>QRunnable</code></p> <p>This class is used to dispatch a method to the threadpool of the main application.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>class MethodAction(QRunnable):\n    \"\"\" This class is used to dispatch a method to the threadpool of the main application.\n    \"\"\"\n\n    def __init__(self, method):\n        \"\"\" initialises the MethodAction with the given method.\n\n        Args:\n            method (callable): any callable object like a method of an object or a lambda function\n        \"\"\"\n        super().__init__()\n        self.method = method\n\n    def run(self):\n        \"\"\" runs the method that was given in the constructor.\n        \"\"\"\n        self.method()\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.MethodAction.__init__","title":"<code>__init__(method)</code>","text":"<p>initialises the MethodAction with the given method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>callable</code> <p>any callable object like a method of an object or a lambda function</p> required Source code in <code>chessapp\\view\\module.py</code> <pre><code>def __init__(self, method):\n    \"\"\" initialises the MethodAction with the given method.\n\n    Args:\n        method (callable): any callable object like a method of an object or a lambda function\n    \"\"\"\n    super().__init__()\n    self.method = method\n</code></pre>"},{"location":"chessapp/view/module/#chessapp.view.module.MethodAction.run","title":"<code>run()</code>","text":"<p>runs the method that was given in the constructor.</p> Source code in <code>chessapp\\view\\module.py</code> <pre><code>def run(self):\n    \"\"\" runs the method that was given in the constructor.\n    \"\"\"\n    self.method()\n</code></pre>"},{"location":"chessapp/view/module/#source","title":"Source","text":"<pre><code>from PyQt5.QtCore import QRunnable, QObject, Qt\nfrom PyQt5.QtWidgets import QAction, QMenuBar, QMenu, QWidget, QListWidget, QHBoxLayout, QLabel, QVBoxLayout, QListWidgetItem\nfrom PyQt5.QtGui import QFont\nfrom chessapp.view.chessboardwidget import ChessBoardWidget, PieceMovement\nfrom PyQt5.QtCore import pyqtSignal\nfrom chessapp.configuration import DEFAULT_STYLESHEET\n\n\nclass BaseModule(QObject):\n    \"\"\" A module is a widget that offers the user GUI interactions with the program. It is registered in the menu bar with\n    its own menu item whose display name is given by display_name. The menu item has a \"Focus\" action that makes the modules'\n    central_widget the AppWindow's central widget. The central_widget is a QWidget that contains a QVBoxLayout with a header\n    label, the main widget and a footer label. The main_widget is a QWidget that contains the main content of the module.\n\n    Only change the content of main_widget or the text of the header_label and footer_label!\n\n    TODO: This class needs to be refactored! The chessapp.controller classes are derived from it which mixes GUI and logic. Instead a controller should be able to offer a GUI-element to the application and interact through it with the user and vice versa.\n    \"\"\"\n\n    def __init__(self, app, display_name: str, actions: list[QAction]) -&gt; None:\n        \"\"\" initialises the module with the given parameters. The module is not focused after initialisation. After\n        initialising this class the method init needs to be called on the GUI thread to finish up the initialisation.\n\n        Args:\n            app (ChessApp): the main application\n            display_name (str): the name of the module that is displayed in the menu bar\n            actions (list[QAction]): a list of actions that are displayed in the menu of the module\n        \"\"\"\n        super().__init__()\n        self.app = app\n        self.display_name: str = display_name\n        self.is_focused = False\n        self.central_widget = QWidget()\n        self.main_widget = QWidget()\n        self.header_label = QLabel()\n        self.footer_label = QLabel()\n        self.actions: [QAction] = actions\n        self.is_closing = False\n        self.is_closed = False\n\n    def init(self) -&gt; None:\n        \"\"\" call this method only once per instance and only on the GUI thread. This method finishes the initialisation of\n        the module.\n        \"\"\"\n        # widget configuration\n        self.header_label.setAlignment(Qt.AlignCenter)\n        self.header_label.setFont(QFont(\"Times\", 20, QFont.Bold))\n        self.footer_label.setAlignment(Qt.AlignCenter)\n        self.central_widget.setStyleSheet(\n            self.central_widget.styleSheet() + \";\" + DEFAULT_STYLESHEET)\n\n        # header, main, footer\n        v_layout = QVBoxLayout()\n        self.central_widget.setLayout(v_layout)\n        v_layout.addWidget(self.header_label)\n        v_layout.addWidget(self.main_widget)\n        v_layout.addWidget(self.footer_label)\n\n        # default values\n        self.header_label.setText(self.display_name)\n\n    def register(self):\n        \"\"\" this method is only called once by the main application. Don't call this in any other way.\n        It registers the module in the menu bar with the \"Focus\" action and the actions given in the constructor.\n        \"\"\"\n        menu_bar: QMenuBar = self.app.window.menuBar()\n        menu: QMenu = menu_bar.addMenu(\"&amp;\" + self.display_name)\n        focus_action = QAction(\"&amp;Focus\", self.app.window)\n        focus_action.triggered.connect(\n            lambda: self.app.threadpool.start(MethodAction(self.focus)))\n        menu.addAction(focus_action)\n        for action in self.actions:\n            menu.addAction(action)\n        self.on_register()\n\n    def about_to_close(self) -&gt; bool:\n        \"\"\" returns True if the module is about to close or is already closed. Closing happens when the main application\n        closes down itself. This method is used as an indicator by deriving classes to determine if it is feasible or\n        not to continue actions. Often it is prudent to include this method inside loops to abort actions when the program\n        wants to close.\n\n        Returns:\n            bool: True if the module is about to close or is already closed\n        \"\"\"\n        return self.is_closing or self.is_closed\n\n    def on_register(self):\n        \"\"\" override this method to react to the registration of the module in the main application.\n        \"\"\"\n        pass\n\n    def on_close(self):\n        \"\"\" override this method to react to the closing of the module.\n        \"\"\"\n        pass\n\n    def close(self):\n        \"\"\" closes the module\n        \"\"\"\n        if self.about_to_close():\n            return\n        self.is_closing = True\n        self.on_close()\n        # this way around \"self.about_to_close()\" stays True\n        self.is_closed = True\n        self.is_closing = False\n\n    def focus(self):\n        \"\"\" focuses this module by setting its central_widget as the main application's central widget and unfocusing all\n        other modules. This method is called by the \"Focus\" action in the menu bar.\n        \"\"\"\n        if self.is_focused:\n            return\n        self.app.unfocus_all_modules()\n        self.app.set_central_widget(self.central_widget)\n        self.is_focused = True\n        self.on_focus()\n\n    def unfocus(self):\n        \"\"\" unfocuses this module.\n        \"\"\"\n        if not self.is_focused:\n            return\n        self.is_focused = False\n        self.on_unfocus()\n\n    def on_focus(self):\n        \"\"\" override this method to react to the focusing of the module.\n        \"\"\"\n        pass\n\n    def on_unfocus(self):\n        \"\"\" override this method to react to the unfocusing of the module.\n        \"\"\"\n        pass\n\n    def dispatch_threadpool(self, callable):\n        \"\"\" dispatches the given callable to the threadpool of the main application.\n\n        Args:\n            callable (callable): any callable object like a method of an object or a lambda function\n        \"\"\"\n        self.app.threadpool.start(MethodAction(callable))\n\n\nclass LogModule(BaseModule):\n    \"\"\" This derivation adds a log widget to the main widget. The log widget is a QListWidget that displays log messages.\n    \"\"\"\n\n    log_message_received = pyqtSignal(str)\n\n    def __init__(self, app, display_name: str, actions: list[QAction]):\n        \"\"\" basically only calls the constructor of BaseModule and initialises the log widget.\n\n        Args:\n            app (ChessApp): the main application\n            display_name (str): the name of the module that is displayed in the menu bar\n            actions (list[QAction]): the actions that are displayed in the menu of the module\n        \"\"\"\n        super().__init__(app, display_name, actions)\n        self.log_widget = QListWidget()\n\n    def init(self):\n        \"\"\" @see BaseModule.init. Adds the log widget to the main widget.\n        \"\"\"\n        super().init()\n        # main: log\n        v_Layout = QVBoxLayout()\n        self.main_widget.setLayout(v_Layout)\n        v_Layout.addWidget(self.log_widget)\n        # connections\n        self.log_message_received.connect(self.__log_message)\n\n    def log_message(self, message: str, timeout_milliseconds: int = 2000):\n        \"\"\" logs the given message in the log widget and shows it as a status message in the status bar of the main application.\n\n        Args:\n            message (str): the message to log\n            timeout_milliseconds (int, optional): the timeout of the status message in milliseconds.\n        \"\"\"\n        self.log_message_received.emit(message)\n        self.app.show_status_message(message, timeout_milliseconds)\n\n    def __log_message(self, message: str):\n        \"\"\" internal method that is called by the GUI thread when a new status message is received.\n\n        Args:\n            message (str): the message to log\n        \"\"\"\n        QListWidgetItem(message, self.log_widget)\n        self.log_widget.scrollToBottom()\n\n\nclass ChessboardAndLogModule(LogModule):\n    \"\"\" This derivation adds a ChessBoardWidget left of the log widget as a sort of split-screen. Override\n    on_piece_movement and on_back to react to the user's actions on the chess board.\n    \"\"\"\n\n    def __init__(self, app, display_name: str, actions: list[QAction]):\n        \"\"\" basically only calls the constructor of LogModule and initialises the ChessBoardWidget.\n\n        Args:\n            app (ChessApp): the main application\n            display_name (str): the name of the module that is displayed in the menu bar\n            actions (list[QAction]): the actions that are displayed in the menu of the module\n        \"\"\"\n        super().__init__(app, display_name, actions)\n        self.chess_board_widget = ChessBoardWidget()\n        self.chess_board_widget.piece_movement_observer.append(\n            self.on_piece_movement)\n        self.chess_board_widget.back_actions.append(\n            self.on_back)\n\n    def init(self):\n        \"\"\" @see LogModule.init. Adds the ChessBoardWidget to the main widget. In order to show the ChessBoardWidget\n        split-screen the log widget first needs to be removed from the main_widget and then placed inside it again.\n        TODO: change this behaviour so that the log widget is not removed and placed inside the main widget again.\n        \"\"\"\n        super().init()\n        # reset main widget because it is used differently in LogModule. also reset parent of log widget so that it is not deleted when\n        # the main widget is deleted/removed as a child\n        self.log_widget.setParent(None)\n        QWidget().setLayout(self.main_widget.layout())\n        # main: left chess board, right log\n        h_Layout = QHBoxLayout()\n        self.main_widget.setLayout(h_Layout)\n        h_Layout.addWidget(self.chess_board_widget)\n        h_Layout.addWidget(self.log_widget)\n\n    def on_piece_movement(self, piece_movement: PieceMovement):\n        \"\"\" this method is called when a piece has been move by the user on the chess board. Override this method\n        to react to this user input.\n\n        Args:\n            piece_movement (PieceMovement): the piece movement that has been performed\n        \"\"\"\n        pass\n\n    def on_back(self):\n        \"\"\" this method is called when the user presses the back button on the chess board. Override this method\n        to react to this user input.\n        \"\"\"\n        pass\n\n    def on_focus(self):\n        \"\"\" @see LogModule.on_focus. This method grabs the keyboard so that the ChessBoardWidget can receive keyboard\n        input by the user.\n        \"\"\"\n        super().on_focus()\n        self.chess_board_widget.grabKeyboard()\n\n\nclass MethodAction(QRunnable):\n    \"\"\" This class is used to dispatch a method to the threadpool of the main application.\n    \"\"\"\n\n    def __init__(self, method):\n        \"\"\" initialises the MethodAction with the given method.\n\n        Args:\n            method (callable): any callable object like a method of an object or a lambda function\n        \"\"\"\n        super().__init__()\n        self.method = method\n\n    def run(self):\n        \"\"\" runs the method that was given in the constructor.\n        \"\"\"\n        self.method()\n\n\ndef create_method_action(app, display_name: str, method):\n    \"\"\" helper function to create a QAction that calls the given method when triggered.\n\n    Args:\n        app (ChessApp): the main application\n        display_name (str): the name of the action that is displayed in the menu\n        method (callable): the method that is called when the action is triggered\n\n    Returns:\n        MethodAction: the QAction that calls the given method when triggered\n    \"\"\"\n    method_action = QAction(\"&amp;\" + display_name)\n    method_action.triggered.connect(\n        lambda: app.threadpool.start(MethodAction(method)))\n    return method_action\n</code></pre>"},{"location":"chessapp/view/pieces/","title":"pieces","text":""},{"location":"chessapp/view/pieces/#chessapp.view.pieces.PieceColor","title":"<code>chessapp.view.pieces.PieceColor</code>","text":"<p>             Bases: <code>Enum</code></p> <p>color of a chess piece: white (w) or black (b)</p> Source code in <code>chessapp\\view\\pieces.py</code> <pre><code>class PieceColor(Enum):\n    \"\"\"color of a chess piece: white (w) or black (b)\n    \"\"\"\n    WHITE = \"w\"\n    BLACK = \"b\"\n</code></pre>"},{"location":"chessapp/view/pieces/#chessapp.view.pieces.PieceType","title":"<code>chessapp.view.pieces.PieceType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>representation of the different chess pieces: queen (q), king (k), rook (r), knight (n), bishop (b) and pawn (p)</p> Source code in <code>chessapp\\view\\pieces.py</code> <pre><code>class PieceType(Enum):\n    \"\"\"representation of the different chess pieces: queen (q), king (k), rook (r), knight (n), bishop (b) and pawn (p)\n    \"\"\"\n    QUEEN = \"q\"\n    KING = \"k\"\n    ROOK = \"r\"\n    KNIGHT = \"n\"\n    BISHOP = \"b\"\n    PAWN = \"p\"\n</code></pre>"},{"location":"chessapp/view/pieces/#chessapp.view.pieces.ChessPiece","title":"<code>chessapp.view.pieces.ChessPiece</code>","text":"<p>This is the abstract base class for chess pieces. It tries to load a png file from the chess_pieces folder with the name .png and draws this image on the given position with the given dimensions. Known subclasses are Queen, King, Rook, Knight, Bishop and Pawn that are all located within chessapp.view.pieces. Source code in <code>chessapp\\view\\pieces.py</code> <pre><code>class ChessPiece():\n    \"\"\" This is the abstract base class for chess pieces. It tries to load a png file from the chess_pieces folder with the name &lt;piece_color&gt;&lt;piece_type&gt;.png\n    and draws this image on the given position with the given dimensions. Known subclasses are Queen, King, Rook, Knight, Bishop and Pawn that are all\n    located within chessapp.view.pieces.\n    \"\"\"\n\n    def __init__(self, piece_color: PieceColor, piece_type: PieceType):\n        \"\"\" Creates a new instance of a ChessPiece. Don't instantiate this class directly, use one of the subclasses instead.\n\n        Args:\n            piece_color (PieceColor): color of the piece (e.g. black or white)\n            piece_type (PieceType): type of the piece (e.g. queen, rook, pawn, ...)\n        \"\"\"\n        self.piece_color: PieceColor = piece_color\n        self.piece_type: PieceType = piece_type\n        self.pixmap: QPixmap = None\n\n    def load_pixmap(self):\n        \"\"\"tries to load the pixmap of the chess piece from the chess_pieces folder. if the file does not exist, the pixmap is set to None.\n        \"\"\"\n        image_path = join(get_chess_pieces_folder(), str(\n            self.piece_color.value) + str(self.piece_type.value) + \".png\")\n        self.pixmap = QPixmap(image_path) if exists(image_path) else None\n\n    def drawOn(self, qp: QPainter, position: QPoint, dimension: QSize):\n        \"\"\"draws the piece on the given position with the given dimensions. if load_pixmap was not called before or no image for the piece exists,\n        then the piece is drawn as text (e.g. \"q\" for queen, \"r\" for rook, ...) with the color of the piece.\n        of the bounding box of the piece.\n\n        Args:\n            qp (QPainter): QPainter of the GUI\n            position (QPoint): position of the piece (x, y upper left corner)\n            dimension (PieceDimenson): dimensions of the piece (width and height)\n        \"\"\"\n        if self.pixmap:\n            qp.drawPixmap(position.x(), position.y(), dimension.width, dimension.height,\n                          self.pixmap, 0, 0, self.pixmap.width(), self.pixmap.height())\n        else:\n            qp.setPen(Qt.GlobalColor.black)\n            text: str = self.piece_type.value.lower()\n            if self.piece_color == PieceColor.WHITE:\n                qp.setPen(Qt.GlobalColor.white)\n                text = text.upper()\n            font = qp.font()\n            font.setPointSize(find_font_size(\n                QSize(dimension.width, dimension.height), text))\n            qp.setFont(font)\n            qp.drawText(QRect(position.x(), position.y(),\n                        dimension.width, dimension.height), Qt.AlignCenter, text)\n</code></pre>"},{"location":"chessapp/view/pieces/#chessapp.view.pieces.ChessPiece.__init__","title":"<code>__init__(piece_color, piece_type)</code>","text":"<p>Creates a new instance of a ChessPiece. Don't instantiate this class directly, use one of the subclasses instead.</p> <p>Parameters:</p> Name Type Description Default <code>piece_color</code> <code>PieceColor</code> <p>color of the piece (e.g. black or white)</p> required <code>piece_type</code> <code>PieceType</code> <p>type of the piece (e.g. queen, rook, pawn, ...)</p> required Source code in <code>chessapp\\view\\pieces.py</code> <pre><code>def __init__(self, piece_color: PieceColor, piece_type: PieceType):\n    \"\"\" Creates a new instance of a ChessPiece. Don't instantiate this class directly, use one of the subclasses instead.\n\n    Args:\n        piece_color (PieceColor): color of the piece (e.g. black or white)\n        piece_type (PieceType): type of the piece (e.g. queen, rook, pawn, ...)\n    \"\"\"\n    self.piece_color: PieceColor = piece_color\n    self.piece_type: PieceType = piece_type\n    self.pixmap: QPixmap = None\n</code></pre>"},{"location":"chessapp/view/pieces/#chessapp.view.pieces.ChessPiece.drawOn","title":"<code>drawOn(qp, position, dimension)</code>","text":"<p>draws the piece on the given position with the given dimensions. if load_pixmap was not called before or no image for the piece exists, then the piece is drawn as text (e.g. \"q\" for queen, \"r\" for rook, ...) with the color of the piece. of the bounding box of the piece.</p> <p>Parameters:</p> Name Type Description Default <code>qp</code> <code>QPainter</code> <p>QPainter of the GUI</p> required <code>position</code> <code>QPoint</code> <p>position of the piece (x, y upper left corner)</p> required <code>dimension</code> <code>PieceDimenson</code> <p>dimensions of the piece (width and height)</p> required Source code in <code>chessapp\\view\\pieces.py</code> <pre><code>def drawOn(self, qp: QPainter, position: QPoint, dimension: QSize):\n    \"\"\"draws the piece on the given position with the given dimensions. if load_pixmap was not called before or no image for the piece exists,\n    then the piece is drawn as text (e.g. \"q\" for queen, \"r\" for rook, ...) with the color of the piece.\n    of the bounding box of the piece.\n\n    Args:\n        qp (QPainter): QPainter of the GUI\n        position (QPoint): position of the piece (x, y upper left corner)\n        dimension (PieceDimenson): dimensions of the piece (width and height)\n    \"\"\"\n    if self.pixmap:\n        qp.drawPixmap(position.x(), position.y(), dimension.width, dimension.height,\n                      self.pixmap, 0, 0, self.pixmap.width(), self.pixmap.height())\n    else:\n        qp.setPen(Qt.GlobalColor.black)\n        text: str = self.piece_type.value.lower()\n        if self.piece_color == PieceColor.WHITE:\n            qp.setPen(Qt.GlobalColor.white)\n            text = text.upper()\n        font = qp.font()\n        font.setPointSize(find_font_size(\n            QSize(dimension.width, dimension.height), text))\n        qp.setFont(font)\n        qp.drawText(QRect(position.x(), position.y(),\n                    dimension.width, dimension.height), Qt.AlignCenter, text)\n</code></pre>"},{"location":"chessapp/view/pieces/#chessapp.view.pieces.ChessPiece.load_pixmap","title":"<code>load_pixmap()</code>","text":"<p>tries to load the pixmap of the chess piece from the chess_pieces folder. if the file does not exist, the pixmap is set to None.</p> Source code in <code>chessapp\\view\\pieces.py</code> <pre><code>def load_pixmap(self):\n    \"\"\"tries to load the pixmap of the chess piece from the chess_pieces folder. if the file does not exist, the pixmap is set to None.\n    \"\"\"\n    image_path = join(get_chess_pieces_folder(), str(\n        self.piece_color.value) + str(self.piece_type.value) + \".png\")\n    self.pixmap = QPixmap(image_path) if exists(image_path) else None\n</code></pre>"},{"location":"chessapp/view/pieces/#chessapp.view.pieces.Queen","title":"<code>chessapp.view.pieces.Queen</code>","text":"<p>             Bases: <code>ChessPiece</code></p> Source code in <code>chessapp\\view\\pieces.py</code> <pre><code>class Queen(ChessPiece):\n    def __init__(self, piece_color: PieceColor):\n        super().__init__(piece_color, PieceType.QUEEN)\n</code></pre>"},{"location":"chessapp/view/pieces/#chessapp.view.pieces.King","title":"<code>chessapp.view.pieces.King</code>","text":"<p>             Bases: <code>ChessPiece</code></p> Source code in <code>chessapp\\view\\pieces.py</code> <pre><code>class King(ChessPiece):\n    def __init__(self, piece_color: PieceColor):\n        super().__init__(piece_color, PieceType.KING)\n</code></pre>"},{"location":"chessapp/view/pieces/#chessapp.view.pieces.Rook","title":"<code>chessapp.view.pieces.Rook</code>","text":"<p>             Bases: <code>ChessPiece</code></p> Source code in <code>chessapp\\view\\pieces.py</code> <pre><code>class Rook(ChessPiece):\n    def __init__(self, piece_color: PieceColor):\n        super().__init__(piece_color, PieceType.ROOK)\n</code></pre>"},{"location":"chessapp/view/pieces/#chessapp.view.pieces.Knight","title":"<code>chessapp.view.pieces.Knight</code>","text":"<p>             Bases: <code>ChessPiece</code></p> Source code in <code>chessapp\\view\\pieces.py</code> <pre><code>class Knight(ChessPiece):\n    def __init__(self, piece_color: PieceColor):\n        super().__init__(piece_color, PieceType.KNIGHT)\n</code></pre>"},{"location":"chessapp/view/pieces/#chessapp.view.pieces.Bishop","title":"<code>chessapp.view.pieces.Bishop</code>","text":"<p>             Bases: <code>ChessPiece</code></p> Source code in <code>chessapp\\view\\pieces.py</code> <pre><code>class Bishop(ChessPiece):\n    def __init__(self, piece_color: PieceColor):\n        super().__init__(piece_color, PieceType.BISHOP)\n</code></pre>"},{"location":"chessapp/view/pieces/#chessapp.view.pieces.Pawn","title":"<code>chessapp.view.pieces.Pawn</code>","text":"<p>             Bases: <code>ChessPiece</code></p> Source code in <code>chessapp\\view\\pieces.py</code> <pre><code>class Pawn(ChessPiece):\n    def __init__(self, piece_color: PieceColor):\n        super().__init__(piece_color, PieceType.PAWN)\n</code></pre>"},{"location":"chessapp/view/pieces/#source","title":"Source","text":"<pre><code>from PyQt5.QtGui import QPainter, QPixmap, QFont\nfrom PyQt5.QtCore import QPoint, QSize\nfrom os.path import join, exists\nfrom chessapp.util.paths import get_chess_pieces_folder\nfrom enum import Enum\nfrom PyQt5.QtCore import QRect\nfrom PyQt5.QtCore import Qt\nfrom chessapp.util.font import find_font_size\n\n\nclass PieceColor(Enum):\n    \"\"\"color of a chess piece: white (w) or black (b)\n    \"\"\"\n    WHITE = \"w\"\n    BLACK = \"b\"\n\n\nclass PieceType(Enum):\n    \"\"\"representation of the different chess pieces: queen (q), king (k), rook (r), knight (n), bishop (b) and pawn (p)\n    \"\"\"\n    QUEEN = \"q\"\n    KING = \"k\"\n    ROOK = \"r\"\n    KNIGHT = \"n\"\n    BISHOP = \"b\"\n    PAWN = \"p\"\n\n\nclass ChessPiece():\n    \"\"\" This is the abstract base class for chess pieces. It tries to load a png file from the chess_pieces folder with the name &lt;piece_color&gt;&lt;piece_type&gt;.png\n    and draws this image on the given position with the given dimensions. Known subclasses are Queen, King, Rook, Knight, Bishop and Pawn that are all\n    located within chessapp.view.pieces.\n    \"\"\"\n\n    def __init__(self, piece_color: PieceColor, piece_type: PieceType):\n        \"\"\" Creates a new instance of a ChessPiece. Don't instantiate this class directly, use one of the subclasses instead.\n\n        Args:\n            piece_color (PieceColor): color of the piece (e.g. black or white)\n            piece_type (PieceType): type of the piece (e.g. queen, rook, pawn, ...)\n        \"\"\"\n        self.piece_color: PieceColor = piece_color\n        self.piece_type: PieceType = piece_type\n        self.pixmap: QPixmap = None\n\n    def load_pixmap(self):\n        \"\"\"tries to load the pixmap of the chess piece from the chess_pieces folder. if the file does not exist, the pixmap is set to None.\n        \"\"\"\n        image_path = join(get_chess_pieces_folder(), str(\n            self.piece_color.value) + str(self.piece_type.value) + \".png\")\n        self.pixmap = QPixmap(image_path) if exists(image_path) else None\n\n    def drawOn(self, qp: QPainter, position: QPoint, dimension: QSize):\n        \"\"\"draws the piece on the given position with the given dimensions. if load_pixmap was not called before or no image for the piece exists,\n        then the piece is drawn as text (e.g. \"q\" for queen, \"r\" for rook, ...) with the color of the piece.\n        of the bounding box of the piece.\n\n        Args:\n            qp (QPainter): QPainter of the GUI\n            position (QPoint): position of the piece (x, y upper left corner)\n            dimension (PieceDimenson): dimensions of the piece (width and height)\n        \"\"\"\n        if self.pixmap:\n            qp.drawPixmap(position.x(), position.y(), dimension.width, dimension.height,\n                          self.pixmap, 0, 0, self.pixmap.width(), self.pixmap.height())\n        else:\n            qp.setPen(Qt.GlobalColor.black)\n            text: str = self.piece_type.value.lower()\n            if self.piece_color == PieceColor.WHITE:\n                qp.setPen(Qt.GlobalColor.white)\n                text = text.upper()\n            font = qp.font()\n            font.setPointSize(find_font_size(\n                QSize(dimension.width, dimension.height), text))\n            qp.setFont(font)\n            qp.drawText(QRect(position.x(), position.y(),\n                        dimension.width, dimension.height), Qt.AlignCenter, text)\n\n\nclass Queen(ChessPiece):\n    def __init__(self, piece_color: PieceColor):\n        super().__init__(piece_color, PieceType.QUEEN)\n\n\nclass King(ChessPiece):\n    def __init__(self, piece_color: PieceColor):\n        super().__init__(piece_color, PieceType.KING)\n\n\nclass Rook(ChessPiece):\n    def __init__(self, piece_color: PieceColor):\n        super().__init__(piece_color, PieceType.ROOK)\n\n\nclass Knight(ChessPiece):\n    def __init__(self, piece_color: PieceColor):\n        super().__init__(piece_color, PieceType.KNIGHT)\n\n\nclass Bishop(ChessPiece):\n    def __init__(self, piece_color: PieceColor):\n        super().__init__(piece_color, PieceType.BISHOP)\n\n\nclass Pawn(ChessPiece):\n    def __init__(self, piece_color: PieceColor):\n        super().__init__(piece_color, PieceType.PAWN)\n\n\n\"\"\"this is a map that maps a letter to a chess piece. The letter is the first letter of the piece type (e.g. \"r\" for rook, \"q\" for queen, ...) except\nfor knights which start with \"n\" and not \"k\" because \"k\" is the king. The letter is lower case for black pieces and upper case for white pieces.\n\"\"\"\nLETTER_MAP = {\n    \"r\": Rook(PieceColor.BLACK),\n    \"R\": Rook(PieceColor.WHITE),\n    \"n\": Knight(PieceColor.BLACK),\n    \"N\": Knight(PieceColor.WHITE),\n    \"k\": King(PieceColor.BLACK),\n    \"K\": King(PieceColor.WHITE),\n    \"q\": Queen(PieceColor.BLACK),\n    \"Q\": Queen(PieceColor.WHITE),\n    \"b\": Bishop(PieceColor.BLACK),\n    \"B\": Bishop(PieceColor.WHITE),\n    \"p\": Pawn(PieceColor.BLACK),\n    \"P\": Pawn(PieceColor.WHITE)\n}\n\n\ndef load_pieces():\n    \"\"\"loads all the pixmaps of the chess pieces\n    \"\"\"\n    for piece in LETTER_MAP.values():\n        piece.load_pixmap()\n\n\ndef get_piece_from(letter: str) -&gt; ChessPiece | None:\n    \"\"\"returns the chess piece that is mapped by LETTER_MAP to the given letter (e.g. \"r\" for black rook, \"Q\" for white queen, ...)\n\n    Args:\n        letter (str): the letter that is mapped to a chess piece\n\n    Raises:\n        Exception: if the letter is not mapped to a chess piece\n\n    Returns:\n        None: if the letter is not mapped to a chess piece\n        ChessPiece: the chess piece that is mapped to the given letter\n    \"\"\"\n    if not letter in LETTER_MAP:\n        return None\n    return LETTER_MAP[letter]\n</code></pre>"}]}